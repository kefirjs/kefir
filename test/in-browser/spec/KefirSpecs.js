(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){
/*! Kefir.js v3.5.2
 *  https://github.com/rpominov/kefir
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.Kefir = global.Kefir || {})));
}(this, function (exports) { 'use strict';

	function createObj(proto) {
	  var F = function () {};
	  F.prototype = proto;
	  return new F();
	}

	function extend(target /*, mixin1, mixin2...*/) {
	  var length = arguments.length,
	      i = void 0,
	      prop = void 0;
	  for (i = 1; i < length; i++) {
	    for (prop in arguments[i]) {
	      target[prop] = arguments[i][prop];
	    }
	  }
	  return target;
	}

	function inherit(Child, Parent /*, mixin1, mixin2...*/) {
	  var length = arguments.length,
	      i = void 0;
	  Child.prototype = createObj(Parent.prototype);
	  Child.prototype.constructor = Child;
	  for (i = 2; i < length; i++) {
	    extend(Child.prototype, arguments[i]);
	  }
	  return Child;
	}

	var NOTHING = ['<nothing>'];
	var END = 'end';
	var VALUE = 'value';
	var ERROR = 'error';
	var ANY = 'any';

	function concat(a, b) {
	  var result = void 0,
	      length = void 0,
	      i = void 0,
	      j = void 0;
	  if (a.length === 0) {
	    return b;
	  }
	  if (b.length === 0) {
	    return a;
	  }
	  j = 0;
	  result = new Array(a.length + b.length);
	  length = a.length;
	  for (i = 0; i < length; i++, j++) {
	    result[j] = a[i];
	  }
	  length = b.length;
	  for (i = 0; i < length; i++, j++) {
	    result[j] = b[i];
	  }
	  return result;
	}

	function find(arr, value) {
	  var length = arr.length,
	      i = void 0;
	  for (i = 0; i < length; i++) {
	    if (arr[i] === value) {
	      return i;
	    }
	  }
	  return -1;
	}

	function findByPred(arr, pred) {
	  var length = arr.length,
	      i = void 0;
	  for (i = 0; i < length; i++) {
	    if (pred(arr[i])) {
	      return i;
	    }
	  }
	  return -1;
	}

	function cloneArray(input) {
	  var length = input.length,
	      result = new Array(length),
	      i = void 0;
	  for (i = 0; i < length; i++) {
	    result[i] = input[i];
	  }
	  return result;
	}

	function remove(input, index) {
	  var length = input.length,
	      result = void 0,
	      i = void 0,
	      j = void 0;
	  if (index >= 0 && index < length) {
	    if (length === 1) {
	      return [];
	    } else {
	      result = new Array(length - 1);
	      for (i = 0, j = 0; i < length; i++) {
	        if (i !== index) {
	          result[j] = input[i];
	          j++;
	        }
	      }
	      return result;
	    }
	  } else {
	    return input;
	  }
	}

	function map(input, fn) {
	  var length = input.length,
	      result = new Array(length),
	      i = void 0;
	  for (i = 0; i < length; i++) {
	    result[i] = fn(input[i]);
	  }
	  return result;
	}

	function forEach(arr, fn) {
	  var length = arr.length,
	      i = void 0;
	  for (i = 0; i < length; i++) {
	    fn(arr[i]);
	  }
	}

	function fillArray(arr, value) {
	  var length = arr.length,
	      i = void 0;
	  for (i = 0; i < length; i++) {
	    arr[i] = value;
	  }
	}

	function contains(arr, value) {
	  return find(arr, value) !== -1;
	}

	function slide(cur, next, max) {
	  var length = Math.min(max, cur.length + 1),
	      offset = cur.length - length + 1,
	      result = new Array(length),
	      i = void 0;
	  for (i = offset; i < length; i++) {
	    result[i - offset] = cur[i];
	  }
	  result[length - 1] = next;
	  return result;
	}

	function callSubscriber(type, fn, event) {
	  if (type === ANY) {
	    fn(event);
	  } else if (type === event.type) {
	    if (type === VALUE || type === ERROR) {
	      fn(event.value);
	    } else {
	      fn();
	    }
	  }
	}

	function Dispatcher() {
	  this._items = [];
	  this._inLoop = 0;
	  this._removedItems = null;
	}

	extend(Dispatcher.prototype, {
	  add: function (type, fn) {
	    this._items = concat(this._items, [{ type: type, fn: fn }]);
	    return this._items.length;
	  },
	  remove: function (type, fn) {
	    var index = findByPred(this._items, function (x) {
	      return x.type === type && x.fn === fn;
	    });

	    // if we're currently in a notification loop,
	    // remember this subscriber was removed
	    if (this._inLoop !== 0 && index !== -1) {
	      if (this._removedItems === null) {
	        this._removedItems = [];
	      }
	      this._removedItems.push(this._items[index]);
	    }

	    this._items = remove(this._items, index);
	    return this._items.length;
	  },
	  dispatch: function (event) {
	    this._inLoop++;
	    for (var i = 0, items = this._items; i < items.length; i++) {

	      // cleanup was called
	      if (this._items === null) {
	        break;
	      }

	      // this subscriber was removed
	      if (this._removedItems !== null && contains(this._removedItems, items[i])) {
	        continue;
	      }

	      callSubscriber(items[i].type, items[i].fn, event);
	    }
	    this._inLoop--;
	    if (this._inLoop === 0) {
	      this._removedItems = null;
	    }
	  },
	  cleanup: function () {
	    this._items = null;
	  }
	});

	function Observable() {
	  this._dispatcher = new Dispatcher();
	  this._active = false;
	  this._alive = true;
	  this._activating = false;
	  this._logHandlers = null;
	}

	extend(Observable.prototype, {

	  _name: 'observable',

	  _onActivation: function () {},
	  _onDeactivation: function () {},
	  _setActive: function (active) {
	    if (this._active !== active) {
	      this._active = active;
	      if (active) {
	        this._activating = true;
	        this._onActivation();
	        this._activating = false;
	      } else {
	        this._onDeactivation();
	      }
	    }
	  },
	  _clear: function () {
	    this._setActive(false);
	    this._dispatcher.cleanup();
	    this._dispatcher = null;
	    this._logHandlers = null;
	  },
	  _emit: function (type, x) {
	    switch (type) {
	      case VALUE:
	        return this._emitValue(x);
	      case ERROR:
	        return this._emitError(x);
	      case END:
	        return this._emitEnd();
	    }
	  },
	  _emitValue: function (value) {
	    if (this._alive) {
	      this._dispatcher.dispatch({ type: VALUE, value: value });
	    }
	  },
	  _emitError: function (value) {
	    if (this._alive) {
	      this._dispatcher.dispatch({ type: ERROR, value: value });
	    }
	  },
	  _emitEnd: function () {
	    if (this._alive) {
	      this._alive = false;
	      this._dispatcher.dispatch({ type: END });
	      this._clear();
	    }
	  },
	  _on: function (type, fn) {
	    if (this._alive) {
	      this._dispatcher.add(type, fn);
	      this._setActive(true);
	    } else {
	      callSubscriber(type, fn, { type: END });
	    }
	    return this;
	  },
	  _off: function (type, fn) {
	    if (this._alive) {
	      var count = this._dispatcher.remove(type, fn);
	      if (count === 0) {
	        this._setActive(false);
	      }
	    }
	    return this;
	  },
	  onValue: function (fn) {
	    return this._on(VALUE, fn);
	  },
	  onError: function (fn) {
	    return this._on(ERROR, fn);
	  },
	  onEnd: function (fn) {
	    return this._on(END, fn);
	  },
	  onAny: function (fn) {
	    return this._on(ANY, fn);
	  },
	  offValue: function (fn) {
	    return this._off(VALUE, fn);
	  },
	  offError: function (fn) {
	    return this._off(ERROR, fn);
	  },
	  offEnd: function (fn) {
	    return this._off(END, fn);
	  },
	  offAny: function (fn) {
	    return this._off(ANY, fn);
	  },
	  observe: function (observerOrOnValue, onError, onEnd) {
	    var _this = this;
	    var closed = false;

	    var observer = !observerOrOnValue || typeof observerOrOnValue === 'function' ? { value: observerOrOnValue, error: onError, end: onEnd } : observerOrOnValue;

	    var handler = function (event) {
	      if (event.type === END) {
	        closed = true;
	      }
	      if (event.type === VALUE && observer.value) {
	        observer.value(event.value);
	      } else if (event.type === ERROR && observer.error) {
	        observer.error(event.value);
	      } else if (event.type === END && observer.end) {
	        observer.end(event.value);
	      }
	    };

	    this.onAny(handler);

	    return {
	      unsubscribe: function () {
	        if (!closed) {
	          _this.offAny(handler);
	          closed = true;
	        }
	      },

	      get closed() {
	        return closed;
	      }
	    };
	  },


	  // A and B must be subclasses of Stream and Property (order doesn't matter)
	  _ofSameType: function (A, B) {
	    return A.prototype.getType() === this.getType() ? A : B;
	  },
	  setName: function (sourceObs /* optional */, selfName) {
	    this._name = selfName ? sourceObs._name + '.' + selfName : sourceObs;
	    return this;
	  },
	  log: function () {
	    var name = arguments.length <= 0 || arguments[0] === undefined ? this.toString() : arguments[0];


	    var isCurrent = void 0;
	    var handler = function (event) {
	      var type = '<' + event.type + (isCurrent ? ':current' : '') + '>';
	      if (event.type === END) {
	        console.log(name, type);
	      } else {
	        console.log(name, type, event.value);
	      }
	    };

	    if (this._alive) {
	      if (!this._logHandlers) {
	        this._logHandlers = [];
	      }
	      this._logHandlers.push({ name: name, handler: handler });
	    }

	    isCurrent = true;
	    this.onAny(handler);
	    isCurrent = false;

	    return this;
	  },
	  offLog: function () {
	    var name = arguments.length <= 0 || arguments[0] === undefined ? this.toString() : arguments[0];


	    if (this._logHandlers) {
	      var handlerIndex = findByPred(this._logHandlers, function (obj) {
	        return obj.name === name;
	      });
	      if (handlerIndex !== -1) {
	        this.offAny(this._logHandlers[handlerIndex].handler);
	        this._logHandlers.splice(handlerIndex, 1);
	      }
	    }

	    return this;
	  }
	});

	// extend() can't handle `toString` in IE8
	Observable.prototype.toString = function () {
	  return '[' + this._name + ']';
	};

	function Stream() {
	  Observable.call(this);
	}

	inherit(Stream, Observable, {

	  _name: 'stream',

	  getType: function () {
	    return 'stream';
	  }
	});

	function Property() {
	  Observable.call(this);
	  this._currentEvent = null;
	}

	inherit(Property, Observable, {

	  _name: 'property',

	  _emitValue: function (value) {
	    if (this._alive) {
	      this._currentEvent = { type: VALUE, value: value };
	      if (!this._activating) {
	        this._dispatcher.dispatch({ type: VALUE, value: value });
	      }
	    }
	  },
	  _emitError: function (value) {
	    if (this._alive) {
	      this._currentEvent = { type: ERROR, value: value };
	      if (!this._activating) {
	        this._dispatcher.dispatch({ type: ERROR, value: value });
	      }
	    }
	  },
	  _emitEnd: function () {
	    if (this._alive) {
	      this._alive = false;
	      if (!this._activating) {
	        this._dispatcher.dispatch({ type: END });
	      }
	      this._clear();
	    }
	  },
	  _on: function (type, fn) {
	    if (this._alive) {
	      this._dispatcher.add(type, fn);
	      this._setActive(true);
	    }
	    if (this._currentEvent !== null) {
	      callSubscriber(type, fn, this._currentEvent);
	    }
	    if (!this._alive) {
	      callSubscriber(type, fn, { type: END });
	    }
	    return this;
	  },
	  getType: function () {
	    return 'property';
	  }
	});

	var neverS = new Stream();
	neverS._emitEnd();
	neverS._name = 'never';

	function never() {
	  return neverS;
	}

	function timeBased(mixin) {

	  function AnonymousStream(wait, options) {
	    var _this = this;

	    Stream.call(this);
	    this._wait = wait;
	    this._intervalId = null;
	    this._$onTick = function () {
	      return _this._onTick();
	    };
	    this._init(options);
	  }

	  inherit(AnonymousStream, Stream, {
	    _init: function () {},
	    _free: function () {},
	    _onTick: function () {},
	    _onActivation: function () {
	      this._intervalId = setInterval(this._$onTick, this._wait);
	    },
	    _onDeactivation: function () {
	      if (this._intervalId !== null) {
	        clearInterval(this._intervalId);
	        this._intervalId = null;
	      }
	    },
	    _clear: function () {
	      Stream.prototype._clear.call(this);
	      this._$onTick = null;
	      this._free();
	    }
	  }, mixin);

	  return AnonymousStream;
	}

	var S = timeBased({

	  _name: 'later',

	  _init: function (_ref) {
	    var x = _ref.x;

	    this._x = x;
	  },
	  _free: function () {
	    this._x = null;
	  },
	  _onTick: function () {
	    this._emitValue(this._x);
	    this._emitEnd();
	  }
	});

	function later(wait, x) {
	  return new S(wait, { x: x });
	}

	var S$1 = timeBased({

	  _name: 'interval',

	  _init: function (_ref) {
	    var x = _ref.x;

	    this._x = x;
	  },
	  _free: function () {
	    this._x = null;
	  },
	  _onTick: function () {
	    this._emitValue(this._x);
	  }
	});

	function interval(wait, x) {
	  return new S$1(wait, { x: x });
	}

	var S$2 = timeBased({

	  _name: 'sequentially',

	  _init: function (_ref) {
	    var xs = _ref.xs;

	    this._xs = cloneArray(xs);
	  },
	  _free: function () {
	    this._xs = null;
	  },
	  _onTick: function () {
	    if (this._xs.length === 1) {
	      this._emitValue(this._xs[0]);
	      this._emitEnd();
	    } else {
	      this._emitValue(this._xs.shift());
	    }
	  }
	});

	function sequentially(wait, xs) {
	  return xs.length === 0 ? never() : new S$2(wait, { xs: xs });
	}

	var S$3 = timeBased({

	  _name: 'fromPoll',

	  _init: function (_ref) {
	    var fn = _ref.fn;

	    this._fn = fn;
	  },
	  _free: function () {
	    this._fn = null;
	  },
	  _onTick: function () {
	    var fn = this._fn;
	    this._emitValue(fn());
	  }
	});

	function fromPoll(wait, fn) {
	  return new S$3(wait, { fn: fn });
	}

	function emitter(obs) {

	  function value(x) {
	    obs._emitValue(x);
	    return obs._active;
	  }

	  function error(x) {
	    obs._emitError(x);
	    return obs._active;
	  }

	  function end() {
	    obs._emitEnd();
	    return obs._active;
	  }

	  function event(e) {
	    obs._emit(e.type, e.value);
	    return obs._active;
	  }

	  return {
	    value: value,
	    error: error,
	    end: end,
	    event: event,

	    // legacy
	    emit: value,
	    emitEvent: event
	  };
	}

	var S$4 = timeBased({

	  _name: 'withInterval',

	  _init: function (_ref) {
	    var fn = _ref.fn;

	    this._fn = fn;
	    this._emitter = emitter(this);
	  },
	  _free: function () {
	    this._fn = null;
	    this._emitter = null;
	  },
	  _onTick: function () {
	    var fn = this._fn;
	    fn(this._emitter);
	  }
	});

	function withInterval(wait, fn) {
	  return new S$4(wait, { fn: fn });
	}

	function S$5(fn) {
	  Stream.call(this);
	  this._fn = fn;
	  this._unsubscribe = null;
	}

	inherit(S$5, Stream, {

	  _name: 'stream',

	  _onActivation: function () {
	    var fn = this._fn;
	    var unsubscribe = fn(emitter(this));
	    this._unsubscribe = typeof unsubscribe === 'function' ? unsubscribe : null;

	    // fix https://github.com/rpominov/kefir/issues/35
	    if (!this._active) {
	      this._callUnsubscribe();
	    }
	  },
	  _callUnsubscribe: function () {
	    if (this._unsubscribe !== null) {
	      this._unsubscribe();
	      this._unsubscribe = null;
	    }
	  },
	  _onDeactivation: function () {
	    this._callUnsubscribe();
	  },
	  _clear: function () {
	    Stream.prototype._clear.call(this);
	    this._fn = null;
	  }
	});

	function stream(fn) {
	  return new S$5(fn);
	}

	function fromCallback(callbackConsumer) {

	  var called = false;

	  return stream(function (emitter) {

	    if (!called) {
	      callbackConsumer(function (x) {
	        emitter.emit(x);
	        emitter.end();
	      });
	      called = true;
	    }
	  }).setName('fromCallback');
	}

	function fromNodeCallback(callbackConsumer) {

	  var called = false;

	  return stream(function (emitter) {

	    if (!called) {
	      callbackConsumer(function (error, x) {
	        if (error) {
	          emitter.error(error);
	        } else {
	          emitter.emit(x);
	        }
	        emitter.end();
	      });
	      called = true;
	    }
	  }).setName('fromNodeCallback');
	}

	function spread(fn, length) {
	  switch (length) {
	    case 0:
	      return function () {
	        return fn();
	      };
	    case 1:
	      return function (a) {
	        return fn(a[0]);
	      };
	    case 2:
	      return function (a) {
	        return fn(a[0], a[1]);
	      };
	    case 3:
	      return function (a) {
	        return fn(a[0], a[1], a[2]);
	      };
	    case 4:
	      return function (a) {
	        return fn(a[0], a[1], a[2], a[3]);
	      };
	    default:
	      return function (a) {
	        return fn.apply(null, a);
	      };
	  }
	}

	function apply(fn, c, a) {
	  var aLength = a ? a.length : 0;
	  if (c == null) {
	    switch (aLength) {
	      case 0:
	        return fn();
	      case 1:
	        return fn(a[0]);
	      case 2:
	        return fn(a[0], a[1]);
	      case 3:
	        return fn(a[0], a[1], a[2]);
	      case 4:
	        return fn(a[0], a[1], a[2], a[3]);
	      default:
	        return fn.apply(null, a);
	    }
	  } else {
	    switch (aLength) {
	      case 0:
	        return fn.call(c);
	      default:
	        return fn.apply(c, a);
	    }
	  }
	}

	function fromSubUnsub(sub, unsub, transformer /* Function | falsey */) {
	  return stream(function (emitter) {

	    var handler = transformer ? function () {
	      emitter.emit(apply(transformer, this, arguments));
	    } : function (x) {
	      emitter.emit(x);
	    };

	    sub(handler);
	    return function () {
	      return unsub(handler);
	    };
	  }).setName('fromSubUnsub');
	}

	var pairs = [['addEventListener', 'removeEventListener'], ['addListener', 'removeListener'], ['on', 'off']];

	function fromEvents(target, eventName, transformer) {
	  var sub = void 0,
	      unsub = void 0;

	  for (var i = 0; i < pairs.length; i++) {
	    if (typeof target[pairs[i][0]] === 'function' && typeof target[pairs[i][1]] === 'function') {
	      sub = pairs[i][0];
	      unsub = pairs[i][1];
	      break;
	    }
	  }

	  if (sub === undefined) {
	    throw new Error('target don\'t support any of ' + 'addEventListener/removeEventListener, addListener/removeListener, on/off method pair');
	  }

	  return fromSubUnsub(function (handler) {
	    return target[sub](eventName, handler);
	  }, function (handler) {
	    return target[unsub](eventName, handler);
	  }, transformer).setName('fromEvents');
	}

	// HACK:
	//   We don't call parent Class constructor, but instead putting all necessary
	//   properties into prototype to simulate ended Property
	//   (see Propperty and Observable classes).

	function P(value) {
	  this._currentEvent = { type: 'value', value: value, current: true };
	}

	inherit(P, Property, {
	  _name: 'constant',
	  _active: false,
	  _activating: false,
	  _alive: false,
	  _dispatcher: null,
	  _logHandlers: null
	});

	function constant(x) {
	  return new P(x);
	}

	// HACK:
	//   We don't call parent Class constructor, but instead putting all necessary
	//   properties into prototype to simulate ended Property
	//   (see Propperty and Observable classes).

	function P$1(value) {
	  this._currentEvent = { type: 'error', value: value, current: true };
	}

	inherit(P$1, Property, {
	  _name: 'constantError',
	  _active: false,
	  _activating: false,
	  _alive: false,
	  _dispatcher: null,
	  _logHandlers: null
	});

	function constantError(x) {
	  return new P$1(x);
	}

	function createConstructor(BaseClass, name) {
	  return function AnonymousObservable(source, options) {
	    var _this = this;

	    BaseClass.call(this);
	    this._source = source;
	    this._name = source._name + '.' + name;
	    this._init(options);
	    this._$handleAny = function (event) {
	      return _this._handleAny(event);
	    };
	  };
	}

	function createClassMethods(BaseClass) {
	  return {
	    _init: function () {},
	    _free: function () {},
	    _handleValue: function (x) {
	      this._emitValue(x);
	    },
	    _handleError: function (x) {
	      this._emitError(x);
	    },
	    _handleEnd: function () {
	      this._emitEnd();
	    },
	    _handleAny: function (event) {
	      switch (event.type) {
	        case VALUE:
	          return this._handleValue(event.value);
	        case ERROR:
	          return this._handleError(event.value);
	        case END:
	          return this._handleEnd();
	      }
	    },
	    _onActivation: function () {
	      this._source.onAny(this._$handleAny);
	    },
	    _onDeactivation: function () {
	      this._source.offAny(this._$handleAny);
	    },
	    _clear: function () {
	      BaseClass.prototype._clear.call(this);
	      this._source = null;
	      this._$handleAny = null;
	      this._free();
	    }
	  };
	}

	function createStream(name, mixin) {
	  var S = createConstructor(Stream, name);
	  inherit(S, Stream, createClassMethods(Stream), mixin);
	  return S;
	}

	function createProperty(name, mixin) {
	  var P = createConstructor(Property, name);
	  inherit(P, Property, createClassMethods(Property), mixin);
	  return P;
	}

	var P$2 = createProperty('toProperty', {
	  _init: function (_ref) {
	    var fn = _ref.fn;

	    this._getInitialCurrent = fn;
	  },
	  _onActivation: function () {
	    if (this._getInitialCurrent !== null) {
	      var getInitial = this._getInitialCurrent;
	      this._emitValue(getInitial());
	    }
	    this._source.onAny(this._$handleAny); // copied from patterns/one-source
	  }
	});

	function toProperty(obs) {
	  var fn = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	  if (fn !== null && typeof fn !== 'function') {
	    throw new Error('You should call toProperty() with a function or no arguments.');
	  }
	  return new P$2(obs, { fn: fn });
	}

	var S$6 = createStream('changes', {
	  _handleValue: function (x) {
	    if (!this._activating) {
	      this._emitValue(x);
	    }
	  },
	  _handleError: function (x) {
	    if (!this._activating) {
	      this._emitError(x);
	    }
	  }
	});

	function changes(obs) {
	  return new S$6(obs);
	}

	function fromPromise(promise) {

	  var called = false;

	  var result = stream(function (emitter) {
	    if (!called) {
	      var onValue = function (x) {
	        emitter.emit(x);
	        emitter.end();
	      };
	      var onError = function (x) {
	        emitter.error(x);
	        emitter.end();
	      };
	      var _promise = promise.then(onValue, onError);

	      // prevent libraries like 'Q' or 'when' from swallowing exceptions
	      if (_promise && typeof _promise.done === 'function') {
	        _promise.done();
	      }

	      called = true;
	    }
	  });

	  return toProperty(result, null).setName('fromPromise');
	}

	function getGlodalPromise() {
	  if (typeof Promise === 'function') {
	    return Promise;
	  } else {
	    throw new Error('There isn\'t default Promise, use shim or parameter');
	  }
	}

	function toPromise (obs) {
	  var Promise = arguments.length <= 1 || arguments[1] === undefined ? getGlodalPromise() : arguments[1];

	  var last = null;
	  return new Promise(function (resolve, reject) {
	    obs.onAny(function (event) {
	      if (event.type === END && last !== null) {
	        (last.type === VALUE ? resolve : reject)(last.value);
	        last = null;
	      } else {
	        last = event;
	      }
	    });
	  });
	}

	var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {}

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var ponyfill = createCommonjsModule(function (module, exports) {
	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports['default'] = symbolObservablePonyfill;
	function symbolObservablePonyfill(root) {
		var result;
		var _Symbol = root.Symbol;

		if (typeof _Symbol === 'function') {
			if (_Symbol.observable) {
				result = _Symbol.observable;
			} else {
				result = _Symbol('observable');
				_Symbol.observable = result;
			}
		} else {
			result = '@@observable';
		}

		return result;
	};
	});

	var require$$0$1 = (ponyfill && typeof ponyfill === 'object' && 'default' in ponyfill ? ponyfill['default'] : ponyfill);

	var index$1 = createCommonjsModule(function (module, exports) {
	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _ponyfill = require$$0$1;

	var _ponyfill2 = _interopRequireDefault(_ponyfill);

	function _interopRequireDefault(obj) {
		return obj && obj.__esModule ? obj : { 'default': obj };
	}

	var root = undefined; /* global window */

	if (typeof commonjsGlobal !== 'undefined') {
		root = commonjsGlobal;
	} else if (typeof window !== 'undefined') {
		root = window;
	}

	var result = (0, _ponyfill2['default'])(root);
	exports['default'] = result;
	});

	var require$$0 = (index$1 && typeof index$1 === 'object' && 'default' in index$1 ? index$1['default'] : index$1);

	var index = createCommonjsModule(function (module) {
	module.exports = require$$0;
	});

	var $$observable = (index && typeof index === 'object' && 'default' in index ? index['default'] : index);

	function fromESObservable(_observable) {
	  var observable = _observable[$$observable] ? _observable[$$observable]() : _observable;
	  return stream(function (emitter) {
	    var unsub = observable.subscribe({
	      error: function (error) {
	        emitter.error(error);
	        emitter.end();
	      },
	      next: function (value) {
	        emitter.emit(value);
	      },
	      complete: function () {
	        emitter.end();
	      }
	    });

	    if (unsub.unsubscribe) {
	      return function () {
	        unsub.unsubscribe();
	      };
	    } else {
	      return unsub;
	    }
	  }).setName('fromESObservable');
	}

	function ESObservable(observable) {
	  this._observable = observable.takeErrors(1);
	}

	extend(ESObservable.prototype, {
	  subscribe: function (observerOrOnNext, onError, onComplete) {
	    var _this = this;

	    var observer = typeof observerOrOnNext === 'function' ? { next: observerOrOnNext, error: onError, complete: onComplete } : observerOrOnNext;

	    var fn = function (event) {
	      if (event.type === END) {
	        closed = true;
	      }

	      if (event.type === VALUE && observer.next) {
	        observer.next(event.value);
	      } else if (event.type === ERROR && observer.error) {
	        observer.error(event.value);
	      } else if (event.type === END && observer.complete) {
	        observer.complete(event.value);
	      }
	    };

	    this._observable.onAny(fn);
	    var closed = false;

	    var subscription = {
	      unsubscribe: function () {
	        closed = true;
	        _this._observable.offAny(fn);
	      },
	      get closed() {
	        return closed;
	      }
	    };
	    return subscription;
	  }
	});

	// Need to assign directly b/c Symbols aren't enumerable.
	ESObservable.prototype[$$observable] = function () {
	  return this;
	};

	function toESObservable() {
	  return new ESObservable(this);
	}

	function defaultErrorsCombinator(errors) {
	  var latestError = void 0;
	  for (var i = 0; i < errors.length; i++) {
	    if (errors[i] !== undefined) {
	      if (latestError === undefined || latestError.index < errors[i].index) {
	        latestError = errors[i];
	      }
	    }
	  }
	  return latestError.error;
	}

	function Combine(active, passive, combinator) {
	  var _this = this;

	  Stream.call(this);
	  this._activeCount = active.length;
	  this._sources = concat(active, passive);
	  this._combinator = combinator ? spread(combinator, this._sources.length) : function (x) {
	    return x;
	  };
	  this._aliveCount = 0;
	  this._latestValues = new Array(this._sources.length);
	  this._latestErrors = new Array(this._sources.length);
	  fillArray(this._latestValues, NOTHING);
	  this._emitAfterActivation = false;
	  this._endAfterActivation = false;
	  this._latestErrorIndex = 0;

	  this._$handlers = [];

	  var _loop = function (i) {
	    _this._$handlers.push(function (event) {
	      return _this._handleAny(i, event);
	    });
	  };

	  for (var i = 0; i < this._sources.length; i++) {
	    _loop(i);
	  }
	}

	inherit(Combine, Stream, {

	  _name: 'combine',

	  _onActivation: function () {
	    this._aliveCount = this._activeCount;

	    // we need to suscribe to _passive_ sources before _active_
	    // (see https://github.com/rpominov/kefir/issues/98)
	    for (var i = this._activeCount; i < this._sources.length; i++) {
	      this._sources[i].onAny(this._$handlers[i]);
	    }
	    for (var _i = 0; _i < this._activeCount; _i++) {
	      this._sources[_i].onAny(this._$handlers[_i]);
	    }

	    if (this._emitAfterActivation) {
	      this._emitAfterActivation = false;
	      this._emitIfFull();
	    }
	    if (this._endAfterActivation) {
	      this._emitEnd();
	    }
	  },
	  _onDeactivation: function () {
	    var length = this._sources.length,
	        i = void 0;
	    for (i = 0; i < length; i++) {
	      this._sources[i].offAny(this._$handlers[i]);
	    }
	  },
	  _emitIfFull: function () {
	    var hasAllValues = true;
	    var hasErrors = false;
	    var length = this._latestValues.length;
	    var valuesCopy = new Array(length);
	    var errorsCopy = new Array(length);

	    for (var i = 0; i < length; i++) {
	      valuesCopy[i] = this._latestValues[i];
	      errorsCopy[i] = this._latestErrors[i];

	      if (valuesCopy[i] === NOTHING) {
	        hasAllValues = false;
	      }

	      if (errorsCopy[i] !== undefined) {
	        hasErrors = true;
	      }
	    }

	    if (hasAllValues) {
	      var combinator = this._combinator;
	      this._emitValue(combinator(valuesCopy));
	    }
	    if (hasErrors) {
	      this._emitError(defaultErrorsCombinator(errorsCopy));
	    }
	  },
	  _handleAny: function (i, event) {

	    if (event.type === VALUE || event.type === ERROR) {

	      if (event.type === VALUE) {
	        this._latestValues[i] = event.value;
	        this._latestErrors[i] = undefined;
	      }
	      if (event.type === ERROR) {
	        this._latestValues[i] = NOTHING;
	        this._latestErrors[i] = {
	          index: this._latestErrorIndex++,
	          error: event.value
	        };
	      }

	      if (i < this._activeCount) {
	        if (this._activating) {
	          this._emitAfterActivation = true;
	        } else {
	          this._emitIfFull();
	        }
	      }
	    } else {
	      // END

	      if (i < this._activeCount) {
	        this._aliveCount--;
	        if (this._aliveCount === 0) {
	          if (this._activating) {
	            this._endAfterActivation = true;
	          } else {
	            this._emitEnd();
	          }
	        }
	      }
	    }
	  },
	  _clear: function () {
	    Stream.prototype._clear.call(this);
	    this._sources = null;
	    this._latestValues = null;
	    this._latestErrors = null;
	    this._combinator = null;
	    this._$handlers = null;
	  }
	});

	function combine(active) {
	  var passive = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
	  var combinator = arguments[2];

	  if (typeof passive === 'function') {
	    combinator = passive;
	    passive = [];
	  }
	  return active.length === 0 ? never() : new Combine(active, passive, combinator);
	}

	var Observable$1 = {
	  empty: function () {
	    return never();
	  },


	  // Monoid based on merge() seems more useful than one based on concat().
	  concat: function (a, b) {
	    return a.merge(b);
	  },
	  of: function (x) {
	    return constant(x);
	  },
	  map: function (fn, obs) {
	    return obs.map(fn);
	  },
	  bimap: function (fnErr, fnVal, obs) {
	    return obs.mapErrors(fnErr).map(fnVal);
	  },


	  // This ap strictly speaking incompatible with chain. If we derive ap from chain we get
	  // different (not very useful) behavior. But spec requires that if method can be derived
	  // it must have the same behavior as hand-written method. We intentionally violate the spec
	  // in hope that it won't cause many troubles in practice. And in return we have more useful type.
	  ap: function (obsFn, obsVal) {
	    return combine([obsFn, obsVal], function (fn, val) {
	      return fn(val);
	    });
	  },
	  chain: function (fn, obs) {
	    return obs.flatMap(fn);
	  }
	};



	var staticLand = Object.freeze({
	  Observable: Observable$1
	});

	var mixin = {
	  _init: function (_ref) {
	    var fn = _ref.fn;

	    this._fn = fn;
	  },
	  _free: function () {
	    this._fn = null;
	  },
	  _handleValue: function (x) {
	    var fn = this._fn;
	    this._emitValue(fn(x));
	  }
	};

	var S$7 = createStream('map', mixin);
	var P$3 = createProperty('map', mixin);

	var id = function (x) {
	  return x;
	};

	function map$1(obs) {
	  var fn = arguments.length <= 1 || arguments[1] === undefined ? id : arguments[1];

	  return new (obs._ofSameType(S$7, P$3))(obs, { fn: fn });
	}

	var mixin$1 = {
	  _init: function (_ref) {
	    var fn = _ref.fn;

	    this._fn = fn;
	  },
	  _free: function () {
	    this._fn = null;
	  },
	  _handleValue: function (x) {
	    var fn = this._fn;
	    if (fn(x)) {
	      this._emitValue(x);
	    }
	  }
	};

	var S$8 = createStream('filter', mixin$1);
	var P$4 = createProperty('filter', mixin$1);

	var id$1 = function (x) {
	  return x;
	};

	function filter(obs) {
	  var fn = arguments.length <= 1 || arguments[1] === undefined ? id$1 : arguments[1];

	  return new (obs._ofSameType(S$8, P$4))(obs, { fn: fn });
	}

	var mixin$2 = {
	  _init: function (_ref) {
	    var n = _ref.n;

	    this._n = n;
	    if (n <= 0) {
	      this._emitEnd();
	    }
	  },
	  _handleValue: function (x) {
	    this._n--;
	    this._emitValue(x);
	    if (this._n === 0) {
	      this._emitEnd();
	    }
	  }
	};

	var S$9 = createStream('take', mixin$2);
	var P$5 = createProperty('take', mixin$2);

	function take(obs, n) {
	  return new (obs._ofSameType(S$9, P$5))(obs, { n: n });
	}

	var mixin$3 = {
	  _init: function (_ref) {
	    var n = _ref.n;

	    this._n = n;
	    if (n <= 0) {
	      this._emitEnd();
	    }
	  },
	  _handleError: function (x) {
	    this._n--;
	    this._emitError(x);
	    if (this._n === 0) {
	      this._emitEnd();
	    }
	  }
	};

	var S$10 = createStream('takeErrors', mixin$3);
	var P$6 = createProperty('takeErrors', mixin$3);

	function takeErrors(obs, n) {
	  return new (obs._ofSameType(S$10, P$6))(obs, { n: n });
	}

	var mixin$4 = {
	  _init: function (_ref) {
	    var fn = _ref.fn;

	    this._fn = fn;
	  },
	  _free: function () {
	    this._fn = null;
	  },
	  _handleValue: function (x) {
	    var fn = this._fn;
	    if (fn(x)) {
	      this._emitValue(x);
	    } else {
	      this._emitEnd();
	    }
	  }
	};

	var S$11 = createStream('takeWhile', mixin$4);
	var P$7 = createProperty('takeWhile', mixin$4);

	var id$2 = function (x) {
	  return x;
	};

	function takeWhile(obs) {
	  var fn = arguments.length <= 1 || arguments[1] === undefined ? id$2 : arguments[1];

	  return new (obs._ofSameType(S$11, P$7))(obs, { fn: fn });
	}

	var mixin$5 = {
	  _init: function () {
	    this._lastValue = NOTHING;
	  },
	  _free: function () {
	    this._lastValue = null;
	  },
	  _handleValue: function (x) {
	    this._lastValue = x;
	  },
	  _handleEnd: function () {
	    if (this._lastValue !== NOTHING) {
	      this._emitValue(this._lastValue);
	    }
	    this._emitEnd();
	  }
	};

	var S$12 = createStream('last', mixin$5);
	var P$8 = createProperty('last', mixin$5);

	function last(obs) {
	  return new (obs._ofSameType(S$12, P$8))(obs);
	}

	var mixin$6 = {
	  _init: function (_ref) {
	    var n = _ref.n;

	    this._n = Math.max(0, n);
	  },
	  _handleValue: function (x) {
	    if (this._n === 0) {
	      this._emitValue(x);
	    } else {
	      this._n--;
	    }
	  }
	};

	var S$13 = createStream('skip', mixin$6);
	var P$9 = createProperty('skip', mixin$6);

	function skip(obs, n) {
	  return new (obs._ofSameType(S$13, P$9))(obs, { n: n });
	}

	var mixin$7 = {
	  _init: function (_ref) {
	    var fn = _ref.fn;

	    this._fn = fn;
	  },
	  _free: function () {
	    this._fn = null;
	  },
	  _handleValue: function (x) {
	    var fn = this._fn;
	    if (this._fn !== null && !fn(x)) {
	      this._fn = null;
	    }
	    if (this._fn === null) {
	      this._emitValue(x);
	    }
	  }
	};

	var S$14 = createStream('skipWhile', mixin$7);
	var P$10 = createProperty('skipWhile', mixin$7);

	var id$3 = function (x) {
	  return x;
	};

	function skipWhile(obs) {
	  var fn = arguments.length <= 1 || arguments[1] === undefined ? id$3 : arguments[1];

	  return new (obs._ofSameType(S$14, P$10))(obs, { fn: fn });
	}

	var mixin$8 = {
	  _init: function (_ref) {
	    var fn = _ref.fn;

	    this._fn = fn;
	    this._prev = NOTHING;
	  },
	  _free: function () {
	    this._fn = null;
	    this._prev = null;
	  },
	  _handleValue: function (x) {
	    var fn = this._fn;
	    if (this._prev === NOTHING || !fn(this._prev, x)) {
	      this._prev = x;
	      this._emitValue(x);
	    }
	  }
	};

	var S$15 = createStream('skipDuplicates', mixin$8);
	var P$11 = createProperty('skipDuplicates', mixin$8);

	var eq = function (a, b) {
	  return a === b;
	};

	function skipDuplicates(obs) {
	  var fn = arguments.length <= 1 || arguments[1] === undefined ? eq : arguments[1];

	  return new (obs._ofSameType(S$15, P$11))(obs, { fn: fn });
	}

	var mixin$9 = {
	  _init: function (_ref) {
	    var fn = _ref.fn;
	    var seed = _ref.seed;

	    this._fn = fn;
	    this._prev = seed;
	  },
	  _free: function () {
	    this._prev = null;
	    this._fn = null;
	  },
	  _handleValue: function (x) {
	    if (this._prev !== NOTHING) {
	      var fn = this._fn;
	      this._emitValue(fn(this._prev, x));
	    }
	    this._prev = x;
	  }
	};

	var S$16 = createStream('diff', mixin$9);
	var P$12 = createProperty('diff', mixin$9);

	function defaultFn(a, b) {
	  return [a, b];
	}

	function diff(obs, fn) {
	  var seed = arguments.length <= 2 || arguments[2] === undefined ? NOTHING : arguments[2];

	  return new (obs._ofSameType(S$16, P$12))(obs, { fn: fn || defaultFn, seed: seed });
	}

	var P$13 = createProperty('scan', {
	  _init: function (_ref) {
	    var fn = _ref.fn;
	    var seed = _ref.seed;

	    this._fn = fn;
	    this._seed = seed;
	    if (seed !== NOTHING) {
	      this._emitValue(seed);
	    }
	  },
	  _free: function () {
	    this._fn = null;
	    this._seed = null;
	  },
	  _handleValue: function (x) {
	    var fn = this._fn;
	    if (this._currentEvent === null || this._currentEvent.type === ERROR) {
	      this._emitValue(this._seed === NOTHING ? x : fn(this._seed, x));
	    } else {
	      this._emitValue(fn(this._currentEvent.value, x));
	    }
	  }
	});

	function scan(obs, fn) {
	  var seed = arguments.length <= 2 || arguments[2] === undefined ? NOTHING : arguments[2];

	  return new P$13(obs, { fn: fn, seed: seed });
	}

	var mixin$10 = {
	  _init: function (_ref) {
	    var fn = _ref.fn;

	    this._fn = fn;
	  },
	  _free: function () {
	    this._fn = null;
	  },
	  _handleValue: function (x) {
	    var fn = this._fn;
	    var xs = fn(x);
	    for (var i = 0; i < xs.length; i++) {
	      this._emitValue(xs[i]);
	    }
	  }
	};

	var S$17 = createStream('flatten', mixin$10);

	var id$4 = function (x) {
	  return x;
	};

	function flatten(obs) {
	  var fn = arguments.length <= 1 || arguments[1] === undefined ? id$4 : arguments[1];

	  return new S$17(obs, { fn: fn });
	}

	var END_MARKER = {};

	var mixin$11 = {
	  _init: function (_ref) {
	    var _this = this;

	    var wait = _ref.wait;

	    this._wait = Math.max(0, wait);
	    this._buff = [];
	    this._$shiftBuff = function () {
	      var value = _this._buff.shift();
	      if (value === END_MARKER) {
	        _this._emitEnd();
	      } else {
	        _this._emitValue(value);
	      }
	    };
	  },
	  _free: function () {
	    this._buff = null;
	    this._$shiftBuff = null;
	  },
	  _handleValue: function (x) {
	    if (this._activating) {
	      this._emitValue(x);
	    } else {
	      this._buff.push(x);
	      setTimeout(this._$shiftBuff, this._wait);
	    }
	  },
	  _handleEnd: function () {
	    if (this._activating) {
	      this._emitEnd();
	    } else {
	      this._buff.push(END_MARKER);
	      setTimeout(this._$shiftBuff, this._wait);
	    }
	  }
	};

	var S$18 = createStream('delay', mixin$11);
	var P$14 = createProperty('delay', mixin$11);

	function delay(obs, wait) {
	  return new (obs._ofSameType(S$18, P$14))(obs, { wait: wait });
	}

	var now = Date.now ? function () {
	  return Date.now();
	} : function () {
	  return new Date().getTime();
	};

	var mixin$12 = {
	  _init: function (_ref) {
	    var _this = this;

	    var wait = _ref.wait;
	    var leading = _ref.leading;
	    var trailing = _ref.trailing;

	    this._wait = Math.max(0, wait);
	    this._leading = leading;
	    this._trailing = trailing;
	    this._trailingValue = null;
	    this._timeoutId = null;
	    this._endLater = false;
	    this._lastCallTime = 0;
	    this._$trailingCall = function () {
	      return _this._trailingCall();
	    };
	  },
	  _free: function () {
	    this._trailingValue = null;
	    this._$trailingCall = null;
	  },
	  _handleValue: function (x) {
	    if (this._activating) {
	      this._emitValue(x);
	    } else {
	      var curTime = now();
	      if (this._lastCallTime === 0 && !this._leading) {
	        this._lastCallTime = curTime;
	      }
	      var remaining = this._wait - (curTime - this._lastCallTime);
	      if (remaining <= 0) {
	        this._cancelTrailing();
	        this._lastCallTime = curTime;
	        this._emitValue(x);
	      } else if (this._trailing) {
	        this._cancelTrailing();
	        this._trailingValue = x;
	        this._timeoutId = setTimeout(this._$trailingCall, remaining);
	      }
	    }
	  },
	  _handleEnd: function () {
	    if (this._activating) {
	      this._emitEnd();
	    } else {
	      if (this._timeoutId) {
	        this._endLater = true;
	      } else {
	        this._emitEnd();
	      }
	    }
	  },
	  _cancelTrailing: function () {
	    if (this._timeoutId !== null) {
	      clearTimeout(this._timeoutId);
	      this._timeoutId = null;
	    }
	  },
	  _trailingCall: function () {
	    this._emitValue(this._trailingValue);
	    this._timeoutId = null;
	    this._trailingValue = null;
	    this._lastCallTime = !this._leading ? 0 : now();
	    if (this._endLater) {
	      this._emitEnd();
	    }
	  }
	};

	var S$19 = createStream('throttle', mixin$12);
	var P$15 = createProperty('throttle', mixin$12);

	function throttle(obs, wait) {
	  var _ref2 = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

	  var _ref2$leading = _ref2.leading;
	  var leading = _ref2$leading === undefined ? true : _ref2$leading;
	  var _ref2$trailing = _ref2.trailing;
	  var trailing = _ref2$trailing === undefined ? true : _ref2$trailing;

	  return new (obs._ofSameType(S$19, P$15))(obs, { wait: wait, leading: leading, trailing: trailing });
	}

	var mixin$13 = {
	  _init: function (_ref) {
	    var _this = this;

	    var wait = _ref.wait;
	    var immediate = _ref.immediate;

	    this._wait = Math.max(0, wait);
	    this._immediate = immediate;
	    this._lastAttempt = 0;
	    this._timeoutId = null;
	    this._laterValue = null;
	    this._endLater = false;
	    this._$later = function () {
	      return _this._later();
	    };
	  },
	  _free: function () {
	    this._laterValue = null;
	    this._$later = null;
	  },
	  _handleValue: function (x) {
	    if (this._activating) {
	      this._emitValue(x);
	    } else {
	      this._lastAttempt = now();
	      if (this._immediate && !this._timeoutId) {
	        this._emitValue(x);
	      }
	      if (!this._timeoutId) {
	        this._timeoutId = setTimeout(this._$later, this._wait);
	      }
	      if (!this._immediate) {
	        this._laterValue = x;
	      }
	    }
	  },
	  _handleEnd: function () {
	    if (this._activating) {
	      this._emitEnd();
	    } else {
	      if (this._timeoutId && !this._immediate) {
	        this._endLater = true;
	      } else {
	        this._emitEnd();
	      }
	    }
	  },
	  _later: function () {
	    var last = now() - this._lastAttempt;
	    if (last < this._wait && last >= 0) {
	      this._timeoutId = setTimeout(this._$later, this._wait - last);
	    } else {
	      this._timeoutId = null;
	      if (!this._immediate) {
	        this._emitValue(this._laterValue);
	        this._laterValue = null;
	      }
	      if (this._endLater) {
	        this._emitEnd();
	      }
	    }
	  }
	};

	var S$20 = createStream('debounce', mixin$13);
	var P$16 = createProperty('debounce', mixin$13);

	function debounce(obs, wait) {
	  var _ref2 = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

	  var _ref2$immediate = _ref2.immediate;
	  var immediate = _ref2$immediate === undefined ? false : _ref2$immediate;

	  return new (obs._ofSameType(S$20, P$16))(obs, { wait: wait, immediate: immediate });
	}

	var mixin$14 = {
	  _init: function (_ref) {
	    var fn = _ref.fn;

	    this._fn = fn;
	  },
	  _free: function () {
	    this._fn = null;
	  },
	  _handleError: function (x) {
	    var fn = this._fn;
	    this._emitError(fn(x));
	  }
	};

	var S$21 = createStream('mapErrors', mixin$14);
	var P$17 = createProperty('mapErrors', mixin$14);

	var id$5 = function (x) {
	  return x;
	};

	function mapErrors(obs) {
	  var fn = arguments.length <= 1 || arguments[1] === undefined ? id$5 : arguments[1];

	  return new (obs._ofSameType(S$21, P$17))(obs, { fn: fn });
	}

	var mixin$15 = {
	  _init: function (_ref) {
	    var fn = _ref.fn;

	    this._fn = fn;
	  },
	  _free: function () {
	    this._fn = null;
	  },
	  _handleError: function (x) {
	    var fn = this._fn;
	    if (fn(x)) {
	      this._emitError(x);
	    }
	  }
	};

	var S$22 = createStream('filterErrors', mixin$15);
	var P$18 = createProperty('filterErrors', mixin$15);

	var id$6 = function (x) {
	  return x;
	};

	function filterErrors(obs) {
	  var fn = arguments.length <= 1 || arguments[1] === undefined ? id$6 : arguments[1];

	  return new (obs._ofSameType(S$22, P$18))(obs, { fn: fn });
	}

	var mixin$16 = {
	  _handleValue: function () {}
	};

	var S$23 = createStream('ignoreValues', mixin$16);
	var P$19 = createProperty('ignoreValues', mixin$16);

	function ignoreValues(obs) {
	  return new (obs._ofSameType(S$23, P$19))(obs);
	}

	var mixin$17 = {
	  _handleError: function () {}
	};

	var S$24 = createStream('ignoreErrors', mixin$17);
	var P$20 = createProperty('ignoreErrors', mixin$17);

	function ignoreErrors(obs) {
	  return new (obs._ofSameType(S$24, P$20))(obs);
	}

	var mixin$18 = {
	  _handleEnd: function () {}
	};

	var S$25 = createStream('ignoreEnd', mixin$18);
	var P$21 = createProperty('ignoreEnd', mixin$18);

	function ignoreEnd(obs) {
	  return new (obs._ofSameType(S$25, P$21))(obs);
	}

	var mixin$19 = {
	  _init: function (_ref) {
	    var fn = _ref.fn;

	    this._fn = fn;
	  },
	  _free: function () {
	    this._fn = null;
	  },
	  _handleEnd: function () {
	    var fn = this._fn;
	    this._emitValue(fn());
	    this._emitEnd();
	  }
	};

	var S$26 = createStream('beforeEnd', mixin$19);
	var P$22 = createProperty('beforeEnd', mixin$19);

	function beforeEnd(obs, fn) {
	  return new (obs._ofSameType(S$26, P$22))(obs, { fn: fn });
	}

	var mixin$20 = {
	  _init: function (_ref) {
	    var min = _ref.min;
	    var max = _ref.max;

	    this._max = max;
	    this._min = min;
	    this._buff = [];
	  },
	  _free: function () {
	    this._buff = null;
	  },
	  _handleValue: function (x) {
	    this._buff = slide(this._buff, x, this._max);
	    if (this._buff.length >= this._min) {
	      this._emitValue(this._buff);
	    }
	  }
	};

	var S$27 = createStream('slidingWindow', mixin$20);
	var P$23 = createProperty('slidingWindow', mixin$20);

	function slidingWindow(obs, max) {
	  var min = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];

	  return new (obs._ofSameType(S$27, P$23))(obs, { min: min, max: max });
	}

	var mixin$21 = {
	  _init: function (_ref) {
	    var fn = _ref.fn;
	    var flushOnEnd = _ref.flushOnEnd;

	    this._fn = fn;
	    this._flushOnEnd = flushOnEnd;
	    this._buff = [];
	  },
	  _free: function () {
	    this._buff = null;
	  },
	  _flush: function () {
	    if (this._buff !== null && this._buff.length !== 0) {
	      this._emitValue(this._buff);
	      this._buff = [];
	    }
	  },
	  _handleValue: function (x) {
	    this._buff.push(x);
	    var fn = this._fn;
	    if (!fn(x)) {
	      this._flush();
	    }
	  },
	  _handleEnd: function () {
	    if (this._flushOnEnd) {
	      this._flush();
	    }
	    this._emitEnd();
	  }
	};

	var S$28 = createStream('bufferWhile', mixin$21);
	var P$24 = createProperty('bufferWhile', mixin$21);

	var id$7 = function (x) {
	  return x;
	};

	function bufferWhile(obs, fn) {
	  var _ref2 = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

	  var _ref2$flushOnEnd = _ref2.flushOnEnd;
	  var flushOnEnd = _ref2$flushOnEnd === undefined ? true : _ref2$flushOnEnd;

	  return new (obs._ofSameType(S$28, P$24))(obs, { fn: fn || id$7, flushOnEnd: flushOnEnd });
	}

	var mixin$22 = {
	  _init: function (_ref) {
	    var count = _ref.count;
	    var flushOnEnd = _ref.flushOnEnd;

	    this._count = count;
	    this._flushOnEnd = flushOnEnd;
	    this._buff = [];
	  },
	  _free: function () {
	    this._buff = null;
	  },
	  _flush: function () {
	    if (this._buff !== null && this._buff.length !== 0) {
	      this._emitValue(this._buff);
	      this._buff = [];
	    }
	  },
	  _handleValue: function (x) {
	    this._buff.push(x);
	    if (this._buff.length >= this._count) {
	      this._flush();
	    }
	  },
	  _handleEnd: function () {
	    if (this._flushOnEnd) {
	      this._flush();
	    }
	    this._emitEnd();
	  }
	};

	var S$29 = createStream('bufferWithCount', mixin$22);
	var P$25 = createProperty('bufferWithCount', mixin$22);

	function bufferWhile$1(obs, count) {
	  var _ref2 = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

	  var _ref2$flushOnEnd = _ref2.flushOnEnd;
	  var flushOnEnd = _ref2$flushOnEnd === undefined ? true : _ref2$flushOnEnd;

	  return new (obs._ofSameType(S$29, P$25))(obs, { count: count, flushOnEnd: flushOnEnd });
	}

	var mixin$23 = {
	  _init: function (_ref) {
	    var _this = this;

	    var wait = _ref.wait;
	    var count = _ref.count;
	    var flushOnEnd = _ref.flushOnEnd;

	    this._wait = wait;
	    this._count = count;
	    this._flushOnEnd = flushOnEnd;
	    this._intervalId = null;
	    this._$onTick = function () {
	      return _this._flush();
	    };
	    this._buff = [];
	  },
	  _free: function () {
	    this._$onTick = null;
	    this._buff = null;
	  },
	  _flush: function () {
	    if (this._buff !== null) {
	      this._emitValue(this._buff);
	      this._buff = [];
	    }
	  },
	  _handleValue: function (x) {
	    this._buff.push(x);
	    if (this._buff.length >= this._count) {
	      clearInterval(this._intervalId);
	      this._flush();
	      this._intervalId = setInterval(this._$onTick, this._wait);
	    }
	  },
	  _handleEnd: function () {
	    if (this._flushOnEnd && this._buff.length !== 0) {
	      this._flush();
	    }
	    this._emitEnd();
	  },
	  _onActivation: function () {
	    this._intervalId = setInterval(this._$onTick, this._wait);
	    this._source.onAny(this._$handleAny); // copied from patterns/one-source
	  },
	  _onDeactivation: function () {
	    if (this._intervalId !== null) {
	      clearInterval(this._intervalId);
	      this._intervalId = null;
	    }
	    this._source.offAny(this._$handleAny); // copied from patterns/one-source
	  }
	};

	var S$30 = createStream('bufferWithTimeOrCount', mixin$23);
	var P$26 = createProperty('bufferWithTimeOrCount', mixin$23);

	function bufferWithTimeOrCount(obs, wait, count) {
	  var _ref2 = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];

	  var _ref2$flushOnEnd = _ref2.flushOnEnd;
	  var flushOnEnd = _ref2$flushOnEnd === undefined ? true : _ref2$flushOnEnd;

	  return new (obs._ofSameType(S$30, P$26))(obs, { wait: wait, count: count, flushOnEnd: flushOnEnd });
	}

	function xformForObs(obs) {
	  return {
	    '@@transducer/step': function (res, input) {
	      obs._emitValue(input);
	      return null;
	    },
	    '@@transducer/result': function () {
	      obs._emitEnd();
	      return null;
	    }
	  };
	}

	var mixin$24 = {
	  _init: function (_ref) {
	    var transducer = _ref.transducer;

	    this._xform = transducer(xformForObs(this));
	  },
	  _free: function () {
	    this._xform = null;
	  },
	  _handleValue: function (x) {
	    if (this._xform['@@transducer/step'](null, x) !== null) {
	      this._xform['@@transducer/result'](null);
	    }
	  },
	  _handleEnd: function () {
	    this._xform['@@transducer/result'](null);
	  }
	};

	var S$31 = createStream('transduce', mixin$24);
	var P$27 = createProperty('transduce', mixin$24);

	function transduce(obs, transducer) {
	  return new (obs._ofSameType(S$31, P$27))(obs, { transducer: transducer });
	}

	var mixin$25 = {
	  _init: function (_ref) {
	    var fn = _ref.fn;

	    this._handler = fn;
	    this._emitter = emitter(this);
	  },
	  _free: function () {
	    this._handler = null;
	    this._emitter = null;
	  },
	  _handleAny: function (event) {
	    this._handler(this._emitter, event);
	  }
	};

	var S$32 = createStream('withHandler', mixin$25);
	var P$28 = createProperty('withHandler', mixin$25);

	function withHandler(obs, fn) {
	  return new (obs._ofSameType(S$32, P$28))(obs, { fn: fn });
	}

	var isArray = Array.isArray || function (xs) {
	  return Object.prototype.toString.call(xs) === '[object Array]';
	};

	function Zip(sources, combinator) {
	  var _this = this;

	  Stream.call(this);

	  this._buffers = map(sources, function (source) {
	    return isArray(source) ? cloneArray(source) : [];
	  });
	  this._sources = map(sources, function (source) {
	    return isArray(source) ? never() : source;
	  });

	  this._combinator = combinator ? spread(combinator, this._sources.length) : function (x) {
	    return x;
	  };
	  this._aliveCount = 0;

	  this._$handlers = [];

	  var _loop = function (i) {
	    _this._$handlers.push(function (event) {
	      return _this._handleAny(i, event);
	    });
	  };

	  for (var i = 0; i < this._sources.length; i++) {
	    _loop(i);
	  }
	}

	inherit(Zip, Stream, {

	  _name: 'zip',

	  _onActivation: function () {

	    // if all sources are arrays
	    while (this._isFull()) {
	      this._emit();
	    }

	    var length = this._sources.length;
	    this._aliveCount = length;
	    for (var i = 0; i < length && this._active; i++) {
	      this._sources[i].onAny(this._$handlers[i]);
	    }
	  },
	  _onDeactivation: function () {
	    for (var i = 0; i < this._sources.length; i++) {
	      this._sources[i].offAny(this._$handlers[i]);
	    }
	  },
	  _emit: function () {
	    var values = new Array(this._buffers.length);
	    for (var i = 0; i < this._buffers.length; i++) {
	      values[i] = this._buffers[i].shift();
	    }
	    var combinator = this._combinator;
	    this._emitValue(combinator(values));
	  },
	  _isFull: function () {
	    for (var i = 0; i < this._buffers.length; i++) {
	      if (this._buffers[i].length === 0) {
	        return false;
	      }
	    }
	    return true;
	  },
	  _handleAny: function (i, event) {
	    if (event.type === VALUE) {
	      this._buffers[i].push(event.value);
	      if (this._isFull()) {
	        this._emit();
	      }
	    }
	    if (event.type === ERROR) {
	      this._emitError(event.value);
	    }
	    if (event.type === END) {
	      this._aliveCount--;
	      if (this._aliveCount === 0) {
	        this._emitEnd();
	      }
	    }
	  },
	  _clear: function () {
	    Stream.prototype._clear.call(this);
	    this._sources = null;
	    this._buffers = null;
	    this._combinator = null;
	    this._$handlers = null;
	  }
	});

	function zip(observables, combinator /* Function | falsey */) {
	  return observables.length === 0 ? never() : new Zip(observables, combinator);
	}

	var id$8 = function (x) {
	  return x;
	};

	function AbstractPool() {
	  var _this = this;

	  var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	  var _ref$queueLim = _ref.queueLim;
	  var queueLim = _ref$queueLim === undefined ? 0 : _ref$queueLim;
	  var _ref$concurLim = _ref.concurLim;
	  var concurLim = _ref$concurLim === undefined ? -1 : _ref$concurLim;
	  var _ref$drop = _ref.drop;
	  var drop = _ref$drop === undefined ? 'new' : _ref$drop;

	  Stream.call(this);

	  this._queueLim = queueLim < 0 ? -1 : queueLim;
	  this._concurLim = concurLim < 0 ? -1 : concurLim;
	  this._drop = drop;
	  this._queue = [];
	  this._curSources = [];
	  this._$handleSubAny = function (event) {
	    return _this._handleSubAny(event);
	  };
	  this._$endHandlers = [];
	  this._currentlyAdding = null;

	  if (this._concurLim === 0) {
	    this._emitEnd();
	  }
	}

	inherit(AbstractPool, Stream, {

	  _name: 'abstractPool',

	  _add: function (obj, toObs /* Function | falsey */) {
	    toObs = toObs || id$8;
	    if (this._concurLim === -1 || this._curSources.length < this._concurLim) {
	      this._addToCur(toObs(obj));
	    } else {
	      if (this._queueLim === -1 || this._queue.length < this._queueLim) {
	        this._addToQueue(toObs(obj));
	      } else if (this._drop === 'old') {
	        this._removeOldest();
	        this._add(obj, toObs);
	      }
	    }
	  },
	  _addAll: function (obss) {
	    var _this2 = this;

	    forEach(obss, function (obs) {
	      return _this2._add(obs);
	    });
	  },
	  _remove: function (obs) {
	    if (this._removeCur(obs) === -1) {
	      this._removeQueue(obs);
	    }
	  },
	  _addToQueue: function (obs) {
	    this._queue = concat(this._queue, [obs]);
	  },
	  _addToCur: function (obs) {
	    if (this._active) {

	      // HACK:
	      //
	      // We have two optimizations for cases when `obs` is ended. We don't want
	      // to add such observable to the list, but only want to emit events
	      // from it (if it has some).
	      //
	      // Instead of this hacks, we could just did following,
	      // but it would be 5-8 times slower:
	      //
	      //     this._curSources = concat(this._curSources, [obs]);
	      //     this._subscribe(obs);
	      //

	      // #1
	      // This one for cases when `obs` already ended
	      // e.g., Kefir.constant() or Kefir.never()
	      if (!obs._alive) {
	        if (obs._currentEvent) {
	          this._emit(obs._currentEvent.type, obs._currentEvent.value);
	        }
	        return;
	      }

	      // #2
	      // This one is for cases when `obs` going to end synchronously on
	      // first subscriber e.g., Kefir.stream(em => {em.emit(1); em.end()})
	      this._currentlyAdding = obs;
	      obs.onAny(this._$handleSubAny);
	      this._currentlyAdding = null;
	      if (obs._alive) {
	        this._curSources = concat(this._curSources, [obs]);
	        if (this._active) {
	          this._subToEnd(obs);
	        }
	      }
	    } else {
	      this._curSources = concat(this._curSources, [obs]);
	    }
	  },
	  _subToEnd: function (obs) {
	    var _this3 = this;

	    var onEnd = function () {
	      return _this3._removeCur(obs);
	    };
	    this._$endHandlers.push({ obs: obs, handler: onEnd });
	    obs.onEnd(onEnd);
	  },
	  _subscribe: function (obs) {
	    obs.onAny(this._$handleSubAny);

	    // it can become inactive in responce of subscribing to `obs.onAny` above
	    if (this._active) {
	      this._subToEnd(obs);
	    }
	  },
	  _unsubscribe: function (obs) {
	    obs.offAny(this._$handleSubAny);

	    var onEndI = findByPred(this._$endHandlers, function (obj) {
	      return obj.obs === obs;
	    });
	    if (onEndI !== -1) {
	      obs.offEnd(this._$endHandlers[onEndI].handler);
	      this._$endHandlers.splice(onEndI, 1);
	    }
	  },
	  _handleSubAny: function (event) {
	    if (event.type === VALUE) {
	      this._emitValue(event.value);
	    } else if (event.type === ERROR) {
	      this._emitError(event.value);
	    }
	  },
	  _removeQueue: function (obs) {
	    var index = find(this._queue, obs);
	    this._queue = remove(this._queue, index);
	    return index;
	  },
	  _removeCur: function (obs) {
	    if (this._active) {
	      this._unsubscribe(obs);
	    }
	    var index = find(this._curSources, obs);
	    this._curSources = remove(this._curSources, index);
	    if (index !== -1) {
	      if (this._queue.length !== 0) {
	        this._pullQueue();
	      } else if (this._curSources.length === 0) {
	        this._onEmpty();
	      }
	    }
	    return index;
	  },
	  _removeOldest: function () {
	    this._removeCur(this._curSources[0]);
	  },
	  _pullQueue: function () {
	    if (this._queue.length !== 0) {
	      this._queue = cloneArray(this._queue);
	      this._addToCur(this._queue.shift());
	    }
	  },
	  _onActivation: function () {
	    for (var i = 0, sources = this._curSources; i < sources.length && this._active; i++) {
	      this._subscribe(sources[i]);
	    }
	  },
	  _onDeactivation: function () {
	    for (var i = 0, sources = this._curSources; i < sources.length; i++) {
	      this._unsubscribe(sources[i]);
	    }
	    if (this._currentlyAdding !== null) {
	      this._unsubscribe(this._currentlyAdding);
	    }
	  },
	  _isEmpty: function () {
	    return this._curSources.length === 0;
	  },
	  _onEmpty: function () {},
	  _clear: function () {
	    Stream.prototype._clear.call(this);
	    this._queue = null;
	    this._curSources = null;
	    this._$handleSubAny = null;
	    this._$endHandlers = null;
	  }
	});

	function Merge(sources) {
	  AbstractPool.call(this);
	  this._addAll(sources);
	  this._initialised = true;
	}

	inherit(Merge, AbstractPool, {

	  _name: 'merge',

	  _onEmpty: function () {
	    if (this._initialised) {
	      this._emitEnd();
	    }
	  }
	});

	function merge(observables) {
	  return observables.length === 0 ? never() : new Merge(observables);
	}

	function S$33(generator) {
	  var _this = this;

	  Stream.call(this);
	  this._generator = generator;
	  this._source = null;
	  this._inLoop = false;
	  this._iteration = 0;
	  this._$handleAny = function (event) {
	    return _this._handleAny(event);
	  };
	}

	inherit(S$33, Stream, {

	  _name: 'repeat',

	  _handleAny: function (event) {
	    if (event.type === END) {
	      this._source = null;
	      this._getSource();
	    } else {
	      this._emit(event.type, event.value);
	    }
	  },
	  _getSource: function () {
	    if (!this._inLoop) {
	      this._inLoop = true;
	      var generator = this._generator;
	      while (this._source === null && this._alive && this._active) {
	        this._source = generator(this._iteration++);
	        if (this._source) {
	          this._source.onAny(this._$handleAny);
	        } else {
	          this._emitEnd();
	        }
	      }
	      this._inLoop = false;
	    }
	  },
	  _onActivation: function () {
	    if (this._source) {
	      this._source.onAny(this._$handleAny);
	    } else {
	      this._getSource();
	    }
	  },
	  _onDeactivation: function () {
	    if (this._source) {
	      this._source.offAny(this._$handleAny);
	    }
	  },
	  _clear: function () {
	    Stream.prototype._clear.call(this);
	    this._generator = null;
	    this._source = null;
	    this._$handleAny = null;
	  }
	});

	function repeat (generator) {
	  return new S$33(generator);
	}

	function concat$1(observables) {
	  return repeat(function (index) {
	    return observables.length > index ? observables[index] : false;
	  }).setName('concat');
	}

	function Pool() {
	  AbstractPool.call(this);
	}

	inherit(Pool, AbstractPool, {

	  _name: 'pool',

	  plug: function (obs) {
	    this._add(obs);
	    return this;
	  },
	  unplug: function (obs) {
	    this._remove(obs);
	    return this;
	  }
	});

	function FlatMap(source, fn, options) {
	  var _this = this;

	  AbstractPool.call(this, options);
	  this._source = source;
	  this._fn = fn;
	  this._mainEnded = false;
	  this._lastCurrent = null;
	  this._$handleMain = function (event) {
	    return _this._handleMain(event);
	  };
	}

	inherit(FlatMap, AbstractPool, {
	  _onActivation: function () {
	    AbstractPool.prototype._onActivation.call(this);
	    if (this._active) {
	      this._source.onAny(this._$handleMain);
	    }
	  },
	  _onDeactivation: function () {
	    AbstractPool.prototype._onDeactivation.call(this);
	    this._source.offAny(this._$handleMain);
	    this._hadNoEvSinceDeact = true;
	  },
	  _handleMain: function (event) {

	    if (event.type === VALUE) {
	      // Is latest value before deactivation survived, and now is 'current' on this activation?
	      // We don't want to handle such values, to prevent to constantly add
	      // same observale on each activation/deactivation when our main source
	      // is a `Kefir.conatant()` for example.
	      var sameCurr = this._activating && this._hadNoEvSinceDeact && this._lastCurrent === event.value;
	      if (!sameCurr) {
	        this._add(event.value, this._fn);
	      }
	      this._lastCurrent = event.value;
	      this._hadNoEvSinceDeact = false;
	    }

	    if (event.type === ERROR) {
	      this._emitError(event.value);
	    }

	    if (event.type === END) {
	      if (this._isEmpty()) {
	        this._emitEnd();
	      } else {
	        this._mainEnded = true;
	      }
	    }
	  },
	  _onEmpty: function () {
	    if (this._mainEnded) {
	      this._emitEnd();
	    }
	  },
	  _clear: function () {
	    AbstractPool.prototype._clear.call(this);
	    this._source = null;
	    this._lastCurrent = null;
	    this._$handleMain = null;
	  }
	});

	function FlatMapErrors(source, fn) {
	  FlatMap.call(this, source, fn);
	}

	inherit(FlatMapErrors, FlatMap, {

	  // Same as in FlatMap, only VALUE/ERROR flipped
	  _handleMain: function (event) {

	    if (event.type === ERROR) {
	      var sameCurr = this._activating && this._hadNoEvSinceDeact && this._lastCurrent === event.value;
	      if (!sameCurr) {
	        this._add(event.value, this._fn);
	      }
	      this._lastCurrent = event.value;
	      this._hadNoEvSinceDeact = false;
	    }

	    if (event.type === VALUE) {
	      this._emitValue(event.value);
	    }

	    if (event.type === END) {
	      if (this._isEmpty()) {
	        this._emitEnd();
	      } else {
	        this._mainEnded = true;
	      }
	    }
	  }
	});

	function createConstructor$1(BaseClass, name) {
	  return function AnonymousObservable(primary, secondary, options) {
	    var _this = this;

	    BaseClass.call(this);
	    this._primary = primary;
	    this._secondary = secondary;
	    this._name = primary._name + '.' + name;
	    this._lastSecondary = NOTHING;
	    this._$handleSecondaryAny = function (event) {
	      return _this._handleSecondaryAny(event);
	    };
	    this._$handlePrimaryAny = function (event) {
	      return _this._handlePrimaryAny(event);
	    };
	    this._init(options);
	  };
	}

	function createClassMethods$1(BaseClass) {
	  return {
	    _init: function () {},
	    _free: function () {},
	    _handlePrimaryValue: function (x) {
	      this._emitValue(x);
	    },
	    _handlePrimaryError: function (x) {
	      this._emitError(x);
	    },
	    _handlePrimaryEnd: function () {
	      this._emitEnd();
	    },
	    _handleSecondaryValue: function (x) {
	      this._lastSecondary = x;
	    },
	    _handleSecondaryError: function (x) {
	      this._emitError(x);
	    },
	    _handleSecondaryEnd: function () {},
	    _handlePrimaryAny: function (event) {
	      switch (event.type) {
	        case VALUE:
	          return this._handlePrimaryValue(event.value);
	        case ERROR:
	          return this._handlePrimaryError(event.value);
	        case END:
	          return this._handlePrimaryEnd(event.value);
	      }
	    },
	    _handleSecondaryAny: function (event) {
	      switch (event.type) {
	        case VALUE:
	          return this._handleSecondaryValue(event.value);
	        case ERROR:
	          return this._handleSecondaryError(event.value);
	        case END:
	          this._handleSecondaryEnd(event.value);
	          this._removeSecondary();
	      }
	    },
	    _removeSecondary: function () {
	      if (this._secondary !== null) {
	        this._secondary.offAny(this._$handleSecondaryAny);
	        this._$handleSecondaryAny = null;
	        this._secondary = null;
	      }
	    },
	    _onActivation: function () {
	      if (this._secondary !== null) {
	        this._secondary.onAny(this._$handleSecondaryAny);
	      }
	      if (this._active) {
	        this._primary.onAny(this._$handlePrimaryAny);
	      }
	    },
	    _onDeactivation: function () {
	      if (this._secondary !== null) {
	        this._secondary.offAny(this._$handleSecondaryAny);
	      }
	      this._primary.offAny(this._$handlePrimaryAny);
	    },
	    _clear: function () {
	      BaseClass.prototype._clear.call(this);
	      this._primary = null;
	      this._secondary = null;
	      this._lastSecondary = null;
	      this._$handleSecondaryAny = null;
	      this._$handlePrimaryAny = null;
	      this._free();
	    }
	  };
	}

	function createStream$1(name, mixin) {
	  var S = createConstructor$1(Stream, name);
	  inherit(S, Stream, createClassMethods$1(Stream), mixin);
	  return S;
	}

	function createProperty$1(name, mixin) {
	  var P = createConstructor$1(Property, name);
	  inherit(P, Property, createClassMethods$1(Property), mixin);
	  return P;
	}

	var mixin$26 = {
	  _handlePrimaryValue: function (x) {
	    if (this._lastSecondary !== NOTHING && this._lastSecondary) {
	      this._emitValue(x);
	    }
	  },
	  _handleSecondaryEnd: function () {
	    if (this._lastSecondary === NOTHING || !this._lastSecondary) {
	      this._emitEnd();
	    }
	  }
	};

	var S$34 = createStream$1('filterBy', mixin$26);
	var P$29 = createProperty$1('filterBy', mixin$26);

	function filterBy(primary, secondary) {
	  return new (primary._ofSameType(S$34, P$29))(primary, secondary);
	}

	var id2 = function (_, x) {
	  return x;
	};

	function sampledBy(passive, active, combinator) {
	  var _combinator = combinator ? function (a, b) {
	    return combinator(b, a);
	  } : id2;
	  return combine([active], [passive], _combinator).setName(passive, 'sampledBy');
	}

	var mixin$27 = {
	  _handlePrimaryValue: function (x) {
	    if (this._lastSecondary !== NOTHING) {
	      this._emitValue(x);
	    }
	  },
	  _handleSecondaryEnd: function () {
	    if (this._lastSecondary === NOTHING) {
	      this._emitEnd();
	    }
	  }
	};

	var S$35 = createStream$1('skipUntilBy', mixin$27);
	var P$30 = createProperty$1('skipUntilBy', mixin$27);

	function skipUntilBy(primary, secondary) {
	  return new (primary._ofSameType(S$35, P$30))(primary, secondary);
	}

	var mixin$28 = {
	  _handleSecondaryValue: function () {
	    this._emitEnd();
	  }
	};

	var S$36 = createStream$1('takeUntilBy', mixin$28);
	var P$31 = createProperty$1('takeUntilBy', mixin$28);

	function takeUntilBy(primary, secondary) {
	  return new (primary._ofSameType(S$36, P$31))(primary, secondary);
	}

	var mixin$29 = {
	  _init: function () {
	    var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	    var _ref$flushOnEnd = _ref.flushOnEnd;
	    var flushOnEnd = _ref$flushOnEnd === undefined ? true : _ref$flushOnEnd;

	    this._buff = [];
	    this._flushOnEnd = flushOnEnd;
	  },
	  _free: function () {
	    this._buff = null;
	  },
	  _flush: function () {
	    if (this._buff !== null) {
	      this._emitValue(this._buff);
	      this._buff = [];
	    }
	  },
	  _handlePrimaryEnd: function () {
	    if (this._flushOnEnd) {
	      this._flush();
	    }
	    this._emitEnd();
	  },
	  _onActivation: function () {
	    this._primary.onAny(this._$handlePrimaryAny);
	    if (this._alive && this._secondary !== null) {
	      this._secondary.onAny(this._$handleSecondaryAny);
	    }
	  },
	  _handlePrimaryValue: function (x) {
	    this._buff.push(x);
	  },
	  _handleSecondaryValue: function () {
	    this._flush();
	  },
	  _handleSecondaryEnd: function () {
	    if (!this._flushOnEnd) {
	      this._emitEnd();
	    }
	  }
	};

	var S$37 = createStream$1('bufferBy', mixin$29);
	var P$32 = createProperty$1('bufferBy', mixin$29);

	function bufferBy(primary, secondary, options /* optional */) {
	  return new (primary._ofSameType(S$37, P$32))(primary, secondary, options);
	}

	var mixin$30 = {
	  _init: function () {
	    var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	    var _ref$flushOnEnd = _ref.flushOnEnd;
	    var flushOnEnd = _ref$flushOnEnd === undefined ? true : _ref$flushOnEnd;
	    var _ref$flushOnChange = _ref.flushOnChange;
	    var flushOnChange = _ref$flushOnChange === undefined ? false : _ref$flushOnChange;

	    this._buff = [];
	    this._flushOnEnd = flushOnEnd;
	    this._flushOnChange = flushOnChange;
	  },
	  _free: function () {
	    this._buff = null;
	  },
	  _flush: function () {
	    if (this._buff !== null) {
	      this._emitValue(this._buff);
	      this._buff = [];
	    }
	  },
	  _handlePrimaryEnd: function () {
	    if (this._flushOnEnd) {
	      this._flush();
	    }
	    this._emitEnd();
	  },
	  _handlePrimaryValue: function (x) {
	    this._buff.push(x);
	    if (this._lastSecondary !== NOTHING && !this._lastSecondary) {
	      this._flush();
	    }
	  },
	  _handleSecondaryEnd: function () {
	    if (!this._flushOnEnd && (this._lastSecondary === NOTHING || this._lastSecondary)) {
	      this._emitEnd();
	    }
	  },
	  _handleSecondaryValue: function (x) {
	    if (this._flushOnChange && !x) {
	      this._flush();
	    }

	    // from default _handleSecondaryValue
	    this._lastSecondary = x;
	  }
	};

	var S$38 = createStream$1('bufferWhileBy', mixin$30);
	var P$33 = createProperty$1('bufferWhileBy', mixin$30);

	function bufferWhileBy(primary, secondary, options /* optional */) {
	  return new (primary._ofSameType(S$38, P$33))(primary, secondary, options);
	}

	var f = function () {
	  return false;
	};
	var t = function () {
	  return true;
	};

	function awaiting(a, b) {
	  var result = merge([map$1(a, t), map$1(b, f)]);
	  result = skipDuplicates(result);
	  result = toProperty(result, f);
	  return result.setName(a, 'awaiting');
	}

	var mixin$31 = {
	  _init: function (_ref) {
	    var fn = _ref.fn;

	    this._fn = fn;
	  },
	  _free: function () {
	    this._fn = null;
	  },
	  _handleValue: function (x) {
	    var fn = this._fn;
	    var result = fn(x);
	    if (result.convert) {
	      this._emitError(result.error);
	    } else {
	      this._emitValue(x);
	    }
	  }
	};

	var S$39 = createStream('valuesToErrors', mixin$31);
	var P$34 = createProperty('valuesToErrors', mixin$31);

	var defFn = function (x) {
	  return { convert: true, error: x };
	};

	function valuesToErrors(obs) {
	  var fn = arguments.length <= 1 || arguments[1] === undefined ? defFn : arguments[1];

	  return new (obs._ofSameType(S$39, P$34))(obs, { fn: fn });
	}

	var mixin$32 = {
	  _init: function (_ref) {
	    var fn = _ref.fn;

	    this._fn = fn;
	  },
	  _free: function () {
	    this._fn = null;
	  },
	  _handleError: function (x) {
	    var fn = this._fn;
	    var result = fn(x);
	    if (result.convert) {
	      this._emitValue(result.value);
	    } else {
	      this._emitError(x);
	    }
	  }
	};

	var S$40 = createStream('errorsToValues', mixin$32);
	var P$35 = createProperty('errorsToValues', mixin$32);

	var defFn$1 = function (x) {
	  return { convert: true, value: x };
	};

	function errorsToValues(obs) {
	  var fn = arguments.length <= 1 || arguments[1] === undefined ? defFn$1 : arguments[1];

	  return new (obs._ofSameType(S$40, P$35))(obs, { fn: fn });
	}

	var mixin$33 = {
	  _handleError: function (x) {
	    this._emitError(x);
	    this._emitEnd();
	  }
	};

	var S$41 = createStream('endOnError', mixin$33);
	var P$36 = createProperty('endOnError', mixin$33);

	function endOnError(obs) {
	  return new (obs._ofSameType(S$41, P$36))(obs);
	}

	Observable.prototype.toProperty = function (fn) {
	  return toProperty(this, fn);
	};

	Observable.prototype.changes = function () {
	  return changes(this);
	};

	Observable.prototype.toPromise = function (Promise) {
	  return toPromise(this, Promise);
	};

	Observable.prototype.toESObservable = toESObservable;
	Observable.prototype[$$observable] = toESObservable;

	Observable.prototype.map = function (fn) {
	  return map$1(this, fn);
	};

	Observable.prototype.filter = function (fn) {
	  return filter(this, fn);
	};

	Observable.prototype.take = function (n) {
	  return take(this, n);
	};

	Observable.prototype.takeErrors = function (n) {
	  return takeErrors(this, n);
	};

	Observable.prototype.takeWhile = function (fn) {
	  return takeWhile(this, fn);
	};

	Observable.prototype.last = function () {
	  return last(this);
	};

	Observable.prototype.skip = function (n) {
	  return skip(this, n);
	};

	Observable.prototype.skipWhile = function (fn) {
	  return skipWhile(this, fn);
	};

	Observable.prototype.skipDuplicates = function (fn) {
	  return skipDuplicates(this, fn);
	};

	Observable.prototype.diff = function (fn, seed) {
	  return diff(this, fn, seed);
	};

	Observable.prototype.scan = function (fn, seed) {
	  return scan(this, fn, seed);
	};

	Observable.prototype.flatten = function (fn) {
	  return flatten(this, fn);
	};

	Observable.prototype.delay = function (wait) {
	  return delay(this, wait);
	};

	Observable.prototype.throttle = function (wait, options) {
	  return throttle(this, wait, options);
	};

	Observable.prototype.debounce = function (wait, options) {
	  return debounce(this, wait, options);
	};

	Observable.prototype.mapErrors = function (fn) {
	  return mapErrors(this, fn);
	};

	Observable.prototype.filterErrors = function (fn) {
	  return filterErrors(this, fn);
	};

	Observable.prototype.ignoreValues = function () {
	  return ignoreValues(this);
	};

	Observable.prototype.ignoreErrors = function () {
	  return ignoreErrors(this);
	};

	Observable.prototype.ignoreEnd = function () {
	  return ignoreEnd(this);
	};

	Observable.prototype.beforeEnd = function (fn) {
	  return beforeEnd(this, fn);
	};

	Observable.prototype.slidingWindow = function (max, min) {
	  return slidingWindow(this, max, min);
	};

	Observable.prototype.bufferWhile = function (fn, options) {
	  return bufferWhile(this, fn, options);
	};

	Observable.prototype.bufferWithCount = function (count, options) {
	  return bufferWhile$1(this, count, options);
	};

	Observable.prototype.bufferWithTimeOrCount = function (wait, count, options) {
	  return bufferWithTimeOrCount(this, wait, count, options);
	};

	Observable.prototype.transduce = function (transducer) {
	  return transduce(this, transducer);
	};

	Observable.prototype.withHandler = function (fn) {
	  return withHandler(this, fn);
	};

	Observable.prototype.combine = function (other, combinator) {
	  return combine([this, other], combinator);
	};

	Observable.prototype.zip = function (other, combinator) {
	  return zip([this, other], combinator);
	};

	Observable.prototype.merge = function (other) {
	  return merge([this, other]);
	};

	Observable.prototype.concat = function (other) {
	  return concat$1([this, other]);
	};

	var pool = function () {
	  return new Pool();
	};

	Observable.prototype.flatMap = function (fn) {
	  return new FlatMap(this, fn).setName(this, 'flatMap');
	};
	Observable.prototype.flatMapLatest = function (fn) {
	  return new FlatMap(this, fn, { concurLim: 1, drop: 'old' }).setName(this, 'flatMapLatest');
	};
	Observable.prototype.flatMapFirst = function (fn) {
	  return new FlatMap(this, fn, { concurLim: 1 }).setName(this, 'flatMapFirst');
	};
	Observable.prototype.flatMapConcat = function (fn) {
	  return new FlatMap(this, fn, { queueLim: -1, concurLim: 1 }).setName(this, 'flatMapConcat');
	};
	Observable.prototype.flatMapConcurLimit = function (fn, limit) {
	  return new FlatMap(this, fn, { queueLim: -1, concurLim: limit }).setName(this, 'flatMapConcurLimit');
	};

	Observable.prototype.flatMapErrors = function (fn) {
	  return new FlatMapErrors(this, fn).setName(this, 'flatMapErrors');
	};

	Observable.prototype.filterBy = function (other) {
	  return filterBy(this, other);
	};

	Observable.prototype.sampledBy = function (other, combinator) {
	  return sampledBy(this, other, combinator);
	};

	Observable.prototype.skipUntilBy = function (other) {
	  return skipUntilBy(this, other);
	};

	Observable.prototype.takeUntilBy = function (other) {
	  return takeUntilBy(this, other);
	};

	Observable.prototype.bufferBy = function (other, options) {
	  return bufferBy(this, other, options);
	};

	Observable.prototype.bufferWhileBy = function (other, options) {
	  return bufferWhileBy(this, other, options);
	};

	// Deprecated
	// -----------------------------------------------------------------------------

	var DEPRECATION_WARNINGS = true;
	function dissableDeprecationWarnings() {
	  DEPRECATION_WARNINGS = false;
	}

	function warn(msg) {
	  if (DEPRECATION_WARNINGS && console && typeof console.warn === 'function') {
	    var msg2 = '\nHere is an Error object for you containing the call stack:';
	    console.warn(msg, msg2, new Error());
	  }
	}

	Observable.prototype.awaiting = function (other) {
	  warn('You are using deprecated .awaiting() method, see https://github.com/rpominov/kefir/issues/145');
	  return awaiting(this, other);
	};

	Observable.prototype.valuesToErrors = function (fn) {
	  warn('You are using deprecated .valuesToErrors() method, see https://github.com/rpominov/kefir/issues/149');
	  return valuesToErrors(this, fn);
	};

	Observable.prototype.errorsToValues = function (fn) {
	  warn('You are using deprecated .errorsToValues() method, see https://github.com/rpominov/kefir/issues/149');
	  return errorsToValues(this, fn);
	};

	Observable.prototype.endOnError = function () {
	  warn('You are using deprecated .endOnError() method, see https://github.com/rpominov/kefir/issues/150');
	  return endOnError(this);
	};

	// Exports
	// --------------------------------------------------------------------------

	var Kefir = { Observable: Observable, Stream: Stream, Property: Property, never: never, later: later, interval: interval, sequentially: sequentially,
	  fromPoll: fromPoll, withInterval: withInterval, fromCallback: fromCallback, fromNodeCallback: fromNodeCallback, fromEvents: fromEvents, stream: stream,
	  constant: constant, constantError: constantError, fromPromise: fromPromise, fromESObservable: fromESObservable, combine: combine, zip: zip, merge: merge,
	  concat: concat$1, Pool: Pool, pool: pool, repeat: repeat, staticLand: staticLand };

	Kefir.Kefir = Kefir;

	exports.dissableDeprecationWarnings = dissableDeprecationWarnings;
	exports.Kefir = Kefir;
	exports.Observable = Observable;
	exports.Stream = Stream;
	exports.Property = Property;
	exports.never = never;
	exports.later = later;
	exports.interval = interval;
	exports.sequentially = sequentially;
	exports.fromPoll = fromPoll;
	exports.withInterval = withInterval;
	exports.fromCallback = fromCallback;
	exports.fromNodeCallback = fromNodeCallback;
	exports.fromEvents = fromEvents;
	exports.stream = stream;
	exports.constant = constant;
	exports.constantError = constantError;
	exports.fromPromise = fromPromise;
	exports.fromESObservable = fromESObservable;
	exports.combine = combine;
	exports.zip = zip;
	exports.merge = merge;
	exports.concat = concat$1;
	exports.Pool = Pool;
	exports.pool = pool;
	exports.repeat = repeat;
	exports.staticLand = staticLand;
	exports['default'] = Kefir;

	Object.defineProperty(exports, '__esModule', { value: true });

}));
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],2:[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _Subscriber2 = require('./Subscriber');

var _Subscriber3 = _interopRequireDefault(_Subscriber2);

var InnerSubscriber = (function (_Subscriber) {
    _inherits(InnerSubscriber, _Subscriber);

    function InnerSubscriber(parent, outerValue, outerIndex) {
        _classCallCheck(this, InnerSubscriber);

        _Subscriber.call(this);
        this.parent = parent;
        this.outerValue = outerValue;
        this.outerIndex = outerIndex;
        this.index = 0;
    }

    InnerSubscriber.prototype._next = function _next(value) {
        var index = this.index++;
        this.parent.notifyNext(value, this.outerValue, index, this.outerIndex);
    };

    InnerSubscriber.prototype._error = function _error(error) {
        this.parent.notifyError(error, this);
    };

    InnerSubscriber.prototype._complete = function _complete() {
        this.parent.notifyComplete(this);
    };

    return InnerSubscriber;
})(_Subscriber3['default']);

exports['default'] = InnerSubscriber;
module.exports = exports['default'];
},{"./Subscriber":8}],3:[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _Observable = require('./Observable');

var _Observable2 = _interopRequireDefault(_Observable);

var Notification = (function () {
    function Notification(kind, value, exception) {
        _classCallCheck(this, Notification);

        this.kind = kind;
        this.value = value;
        this.exception = exception;
        this.hasValue = kind === 'N';
    }

    Notification.prototype.observe = function observe(observer) {
        switch (this.kind) {
            case 'N':
                return observer.next(this.value);
            case 'E':
                return observer.error(this.exception);
            case 'C':
                return observer.complete();
        }
    };

    Notification.prototype['do'] = function _do(next, error, complete) {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return next(this.value);
            case 'E':
                return error(this.exception);
            case 'C':
                return complete();
        }
    };

    Notification.prototype.accept = function accept(nextOrObserver, error, complete) {
        if (nextOrObserver && typeof nextOrObserver.next === 'function') {
            return this.observe(nextOrObserver);
        } else {
            return this['do'](nextOrObserver, error, complete);
        }
    };

    Notification.prototype.toObservable = function toObservable() {
        var kind = this.kind;
        var value = this.value;
        switch (kind) {
            case 'N':
                return _Observable2['default'].of(value);
            case 'E':
                return _Observable2['default']['throw'](value);
            case 'C':
                return _Observable2['default'].empty();
        }
    };

    Notification.createNext = function createNext(value) {
        if (typeof value !== 'undefined') {
            return new Notification('N', value);
        }
        return this.undefinedValueNotification;
    };

    Notification.createError = function createError(err) {
        return new Notification('E', undefined, err);
    };

    Notification.createComplete = function createComplete() {
        return this.completeNotification;
    };

    return Notification;
})();

exports['default'] = Notification;

Notification.completeNotification = new Notification('C');
Notification.undefinedValueNotification = new Notification('N', undefined);
module.exports = exports['default'];
},{"./Observable":4}],4:[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _Subscriber = require('./Subscriber');

var _Subscriber2 = _interopRequireDefault(_Subscriber);

var _utilRoot = require('./util/root');

var _utilSymbol_observable = require('./util/Symbol_observable');

var _utilSymbol_observable2 = _interopRequireDefault(_utilSymbol_observable);

/**
 * A representation of any set of values over any amount of time. This the most basic building block
 * of RxJS.
 *
 * @class Observable<T>
 */

var Observable = (function () {
    /**
     * @constructor
     * @param {Function} subscribe the function that is
     * called when the Observable is initially subscribed to. This function is given a Subscriber, to which new values
     * can be `next`ed, or an `error` method can be called to raise an error, or `complete` can be called to notify
     * of a successful completion.
     */

    function Observable(subscribe) {
        _classCallCheck(this, Observable);

        this._isScalar = false;
        if (subscribe) {
            this._subscribe = subscribe;
        }
    }

    // HACK: Since TypeScript inherits static properties too, we have to
    // fight against TypeScript here so Subject can have a different static create signature.
    /**
     * @static
     * @method create
     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
     * @returns {Observable} a new cold observable
     * @description creates a new cold Observable by calling the Observable constructor
     */

    /**
     * @method lift
     * @param {Operator} operator the operator defining the operation to take on the observable
     * @returns {Observable} a new observable with the Operator applied
     * @description creates a new Observable, with this Observable as the source, and the passed
     * operator defined as the new observable's operator.
     */

    Observable.prototype.lift = function lift(operator) {
        var observable = new Observable();
        observable.source = this;
        observable.operator = operator;
        return observable;
    };

    /**
     * @method Symbol.observable
     * @returns {Observable} this instance of the observable
     * @description an interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable
     */

    Observable.prototype[_utilSymbol_observable2['default']] = function () {
        return this;
    };

    /**
     * @method subscribe
     * @param {Observer|Function} observerOrNext (optional) either an observer defining all functions to be called,
     *  or the first of three possible handlers, which is the handler for each value emitted from the observable.
     * @param {Function} error (optional) a handler for a terminal event resulting from an error. If no error handler is provided,
     *  the error will be thrown as unhandled
     * @param {Function} complete (optional) a handler for a terminal event resulting from successful completion.
     * @returns {Subscription} a subscription reference to the registered handlers
     * @description registers handlers for handling emitted values, error and completions from the observable, and
     *  executes the observable's subscriber function, which will take action to set up the underlying data stream
     */

    Observable.prototype.subscribe = function subscribe(observerOrNext, error, complete) {
        var subscriber = undefined;
        if (observerOrNext && typeof observerOrNext === "object") {
            if (observerOrNext instanceof _Subscriber2['default']) {
                subscriber = observerOrNext;
            } else {
                subscriber = new _Subscriber2['default'](observerOrNext);
            }
        } else {
            var next = observerOrNext;
            subscriber = _Subscriber2['default'].create(next, error, complete);
        }
        subscriber.add(this._subscribe(subscriber));
        return subscriber;
    };

    /**
     * @method forEach
     * @param {Function} next a handler for each value emitted by the observable
     * @param {PromiseConstructor} PromiseCtor? a constructor function used to instantiate the Promise
     * @returns {Promise} a promise that either resolves on observable completion or
     *  rejects with the handled error
     */

    Observable.prototype.forEach = function forEach(next, PromiseCtor) {
        var _this = this;

        if (!PromiseCtor) {
            if (_utilRoot.root.Rx && _utilRoot.root.Rx.config && _utilRoot.root.Rx.config.Promise) {
                PromiseCtor = _utilRoot.root.Rx.config.Promise;
            } else if (_utilRoot.root.Promise) {
                PromiseCtor = _utilRoot.root.Promise;
            }
        }
        if (!PromiseCtor) {
            throw new Error('no Promise impl found');
        }
        return new PromiseCtor(function (resolve, reject) {
            _this.subscribe(next, reject, resolve);
        });
    };

    Observable.prototype._subscribe = function _subscribe(subscriber) {
        return this.source._subscribe(this.operator.call(subscriber));
    };

    return Observable;
})();

exports['default'] = Observable;
Observable.create = function (subscribe) {
    return new Observable(subscribe);
};
module.exports = exports['default'];
},{"./Subscriber":8,"./util/Symbol_observable":126,"./util/root":133}],5:[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _Subscriber2 = require('./Subscriber');

var _Subscriber3 = _interopRequireDefault(_Subscriber2);

var OuterSubscriber = (function (_Subscriber) {
    _inherits(OuterSubscriber, _Subscriber);

    function OuterSubscriber() {
        _classCallCheck(this, OuterSubscriber);

        _Subscriber.apply(this, arguments);
    }

    OuterSubscriber.prototype.notifyComplete = function notifyComplete(inner) {
        this.destination.complete();
    };

    OuterSubscriber.prototype.notifyNext = function notifyNext(innerValue, outerValue, innerIndex, outerIndex) {
        this.destination.next(innerValue);
    };

    OuterSubscriber.prototype.notifyError = function notifyError(error, inner) {
        this.destination.error(error);
    };

    return OuterSubscriber;
})(_Subscriber3['default']);

exports['default'] = OuterSubscriber;
module.exports = exports['default'];
},{"./Subscriber":8}],6:[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _Subject = require('./Subject');

var _Subject2 = _interopRequireDefault(_Subject);

var _schedulersVirtualTimeScheduler = require('./schedulers/VirtualTimeScheduler');

var _schedulersVirtualTimeScheduler2 = _interopRequireDefault(_schedulersVirtualTimeScheduler);

var _schedulersTestScheduler = require('./schedulers/TestScheduler');

var _schedulersTestScheduler2 = _interopRequireDefault(_schedulersTestScheduler);

var _schedulersImmediate = require('./schedulers/immediate');

var _schedulersImmediate2 = _interopRequireDefault(_schedulersImmediate);

var _schedulersNextTick = require('./schedulers/nextTick');

var _schedulersNextTick2 = _interopRequireDefault(_schedulersNextTick);

var _Observable = require('./Observable');

var _Observable2 = _interopRequireDefault(_Observable);

var _Subscriber = require('./Subscriber');

var _Subscriber2 = _interopRequireDefault(_Subscriber);

var _Subscription = require('./Subscription');

var _Subscription2 = _interopRequireDefault(_Subscription);

var _Notification = require('./Notification');

var _Notification2 = _interopRequireDefault(_Notification);

var _utilEmptyError = require('./util/EmptyError');

var _utilEmptyError2 = _interopRequireDefault(_utilEmptyError);

var _utilArgumentOutOfRangeError = require('./util/ArgumentOutOfRangeError');

var _utilArgumentOutOfRangeError2 = _interopRequireDefault(_utilArgumentOutOfRangeError);

var _subjectsReplaySubject = require('./subjects/ReplaySubject');

var _subjectsReplaySubject2 = _interopRequireDefault(_subjectsReplaySubject);

var _subjectsBehaviorSubject = require('./subjects/BehaviorSubject');

var _subjectsBehaviorSubject2 = _interopRequireDefault(_subjectsBehaviorSubject);

var _observablesConnectableObservable = require('./observables/ConnectableObservable');

var _observablesConnectableObservable2 = _interopRequireDefault(_observablesConnectableObservable);

var _observablesArrayObservable = require('./observables/ArrayObservable');

var _observablesArrayObservable2 = _interopRequireDefault(_observablesArrayObservable);

var _observablesDeferObservable = require('./observables/DeferObservable');

var _observablesDeferObservable2 = _interopRequireDefault(_observablesDeferObservable);

var _observablesEmptyObservable = require('./observables/EmptyObservable');

var _observablesEmptyObservable2 = _interopRequireDefault(_observablesEmptyObservable);

var _observablesErrorObservable = require('./observables/ErrorObservable');

var _observablesErrorObservable2 = _interopRequireDefault(_observablesErrorObservable);

var _observablesInfiniteObservable = require('./observables/InfiniteObservable');

var _observablesInfiniteObservable2 = _interopRequireDefault(_observablesInfiniteObservable);

var _observablesIntervalObservable = require('./observables/IntervalObservable');

var _observablesIntervalObservable2 = _interopRequireDefault(_observablesIntervalObservable);

var _observablesPromiseObservable = require('./observables/PromiseObservable');

var _observablesPromiseObservable2 = _interopRequireDefault(_observablesPromiseObservable);

var _observablesRangeObservable = require('./observables/RangeObservable');

var _observablesRangeObservable2 = _interopRequireDefault(_observablesRangeObservable);

var _observablesTimerObservable = require('./observables/TimerObservable');

var _observablesTimerObservable2 = _interopRequireDefault(_observablesTimerObservable);

var _observablesFromEventPatternObservable = require('./observables/FromEventPatternObservable');

var _observablesFromEventPatternObservable2 = _interopRequireDefault(_observablesFromEventPatternObservable);

var _observablesFromEventObservable = require('./observables/FromEventObservable');

var _observablesFromEventObservable2 = _interopRequireDefault(_observablesFromEventObservable);

var _observablesForkJoinObservable = require('./observables/ForkJoinObservable');

var _observablesForkJoinObservable2 = _interopRequireDefault(_observablesForkJoinObservable);

var _observablesFromObservable = require('./observables/FromObservable');

var _observablesFromObservable2 = _interopRequireDefault(_observablesFromObservable);

var _operatorsConcatStatic = require('./operators/concat-static');

var _operatorsConcatStatic2 = _interopRequireDefault(_operatorsConcatStatic);

var _operatorsConcat = require('./operators/concat');

var _operatorsConcat2 = _interopRequireDefault(_operatorsConcat);

var _operatorsConcatAll = require('./operators/concatAll');

var _operatorsConcatAll2 = _interopRequireDefault(_operatorsConcatAll);

var _operatorsConcatMap = require('./operators/concatMap');

var _operatorsConcatMap2 = _interopRequireDefault(_operatorsConcatMap);

var _operatorsConcatMapTo = require('./operators/concatMapTo');

var _operatorsConcatMapTo2 = _interopRequireDefault(_operatorsConcatMapTo);

var _operatorsMerge = require('./operators/merge');

var _operatorsMerge2 = _interopRequireDefault(_operatorsMerge);

var _operatorsMergeStatic = require('./operators/merge-static');

var _operatorsMergeStatic2 = _interopRequireDefault(_operatorsMergeStatic);

var _operatorsMergeAll = require('./operators/mergeAll');

var _operatorsMergeAll2 = _interopRequireDefault(_operatorsMergeAll);

var _operatorsMergeMap = require('./operators/mergeMap');

var _operatorsMergeMap2 = _interopRequireDefault(_operatorsMergeMap);

var _operatorsMergeMapTo = require('./operators/mergeMapTo');

var _operatorsMergeMapTo2 = _interopRequireDefault(_operatorsMergeMapTo);

var _operatorsSwitch = require('./operators/switch');

var _operatorsSwitch2 = _interopRequireDefault(_operatorsSwitch);

var _operatorsSwitchMap = require('./operators/switchMap');

var _operatorsSwitchMap2 = _interopRequireDefault(_operatorsSwitchMap);

var _operatorsSwitchMapTo = require('./operators/switchMapTo');

var _operatorsSwitchMapTo2 = _interopRequireDefault(_operatorsSwitchMapTo);

var _operatorsExpand = require('./operators/expand');

var _operatorsExpand2 = _interopRequireDefault(_operatorsExpand);

var _operatorsDo = require('./operators/do');

var _operatorsDo2 = _interopRequireDefault(_operatorsDo);

var _operatorsMap = require('./operators/map');

var _operatorsMap2 = _interopRequireDefault(_operatorsMap);

var _operatorsMapTo = require('./operators/mapTo');

var _operatorsMapTo2 = _interopRequireDefault(_operatorsMapTo);

var _operatorsToArray = require('./operators/toArray');

var _operatorsToArray2 = _interopRequireDefault(_operatorsToArray);

var _operatorsCount = require('./operators/count');

var _operatorsCount2 = _interopRequireDefault(_operatorsCount);

var _operatorsScan = require('./operators/scan');

var _operatorsScan2 = _interopRequireDefault(_operatorsScan);

var _operatorsReduce = require('./operators/reduce');

var _operatorsReduce2 = _interopRequireDefault(_operatorsReduce);

var _operatorsStartWith = require('./operators/startWith');

var _operatorsStartWith2 = _interopRequireDefault(_operatorsStartWith);

var _operatorsTake = require('./operators/take');

var _operatorsTake2 = _interopRequireDefault(_operatorsTake);

var _operatorsSkip = require('./operators/skip');

var _operatorsSkip2 = _interopRequireDefault(_operatorsSkip);

var _operatorsSkipUntil = require('./operators/skipUntil');

var _operatorsSkipUntil2 = _interopRequireDefault(_operatorsSkipUntil);

var _operatorsTakeUntil = require('./operators/takeUntil');

var _operatorsTakeUntil2 = _interopRequireDefault(_operatorsTakeUntil);

var _operatorsElementAt = require('./operators/elementAt');

var _operatorsElementAt2 = _interopRequireDefault(_operatorsElementAt);

var _operatorsFilter = require('./operators/filter');

var _operatorsFilter2 = _interopRequireDefault(_operatorsFilter);

var _operatorsDistinctUntilChanged = require('./operators/distinctUntilChanged');

var _operatorsDistinctUntilChanged2 = _interopRequireDefault(_operatorsDistinctUntilChanged);

var _operatorsDistinctUntilKeyChanged = require('./operators/distinctUntilKeyChanged');

var _operatorsDistinctUntilKeyChanged2 = _interopRequireDefault(_operatorsDistinctUntilKeyChanged);

var _operatorsCombineLatest = require('./operators/combineLatest');

var _operatorsCombineLatest2 = _interopRequireDefault(_operatorsCombineLatest);

var _operatorsCombineLatestStatic = require('./operators/combineLatest-static');

var _operatorsCombineLatestStatic2 = _interopRequireDefault(_operatorsCombineLatestStatic);

var _operatorsCombineAll = require('./operators/combineAll');

var _operatorsCombineAll2 = _interopRequireDefault(_operatorsCombineAll);

var _operatorsWithLatestFrom = require('./operators/withLatestFrom');

var _operatorsWithLatestFrom2 = _interopRequireDefault(_operatorsWithLatestFrom);

var _operatorsZip = require('./operators/zip');

var _operatorsZip2 = _interopRequireDefault(_operatorsZip);

var _operatorsZipStatic = require('./operators/zip-static');

var _operatorsZipStatic2 = _interopRequireDefault(_operatorsZipStatic);

var _operatorsZipAll = require('./operators/zipAll');

var _operatorsZipAll2 = _interopRequireDefault(_operatorsZipAll);

var _operatorsPublish = require('./operators/publish');

var _operatorsPublish2 = _interopRequireDefault(_operatorsPublish);

var _operatorsPublishBehavior = require('./operators/publishBehavior');

var _operatorsPublishBehavior2 = _interopRequireDefault(_operatorsPublishBehavior);

var _operatorsPublishReplay = require('./operators/publishReplay');

var _operatorsPublishReplay2 = _interopRequireDefault(_operatorsPublishReplay);

var _operatorsMulticast = require('./operators/multicast');

var _operatorsMulticast2 = _interopRequireDefault(_operatorsMulticast);

var _operatorsObserveOn = require('./operators/observeOn');

var _operatorsObserveOn2 = _interopRequireDefault(_operatorsObserveOn);

var _operatorsSubscribeOn = require('./operators/subscribeOn');

var _operatorsSubscribeOn2 = _interopRequireDefault(_operatorsSubscribeOn);

var _operatorsPartition = require('./operators/partition');

var _operatorsPartition2 = _interopRequireDefault(_operatorsPartition);

var _operatorsToPromise = require('./operators/toPromise');

var _operatorsToPromise2 = _interopRequireDefault(_operatorsToPromise);

var _operatorsDefaultIfEmpty = require('./operators/defaultIfEmpty');

var _operatorsDefaultIfEmpty2 = _interopRequireDefault(_operatorsDefaultIfEmpty);

var _operatorsMaterialize = require('./operators/materialize');

var _operatorsMaterialize2 = _interopRequireDefault(_operatorsMaterialize);

var _operatorsCatch = require('./operators/catch');

var _operatorsCatch2 = _interopRequireDefault(_operatorsCatch);

var _operatorsRetry = require('./operators/retry');

var _operatorsRetry2 = _interopRequireDefault(_operatorsRetry);

var _operatorsRetryWhen = require('./operators/retryWhen');

var _operatorsRetryWhen2 = _interopRequireDefault(_operatorsRetryWhen);

var _operatorsRepeat = require('./operators/repeat');

var _operatorsRepeat2 = _interopRequireDefault(_operatorsRepeat);

var _operatorsFinally = require('./operators/finally');

var _operatorsFinally2 = _interopRequireDefault(_operatorsFinally);

var _operatorsTimeout = require('./operators/timeout');

var _operatorsTimeout2 = _interopRequireDefault(_operatorsTimeout);

var _operatorsTimeoutWith = require('./operators/timeoutWith');

var _operatorsTimeoutWith2 = _interopRequireDefault(_operatorsTimeoutWith);

var _operatorsGroupBy = require('./operators/groupBy');

var _operatorsGroupBy2 = _interopRequireDefault(_operatorsGroupBy);

var _operatorsWindow = require('./operators/window');

var _operatorsWindow2 = _interopRequireDefault(_operatorsWindow);

var _operatorsWindowWhen = require('./operators/windowWhen');

var _operatorsWindowWhen2 = _interopRequireDefault(_operatorsWindowWhen);

var _operatorsWindowToggle = require('./operators/windowToggle');

var _operatorsWindowToggle2 = _interopRequireDefault(_operatorsWindowToggle);

var _operatorsWindowTime = require('./operators/windowTime');

var _operatorsWindowTime2 = _interopRequireDefault(_operatorsWindowTime);

var _operatorsWindowCount = require('./operators/windowCount');

var _operatorsWindowCount2 = _interopRequireDefault(_operatorsWindowCount);

var _operatorsDelay = require('./operators/delay');

var _operatorsDelay2 = _interopRequireDefault(_operatorsDelay);

var _operatorsThrottle = require('./operators/throttle');

var _operatorsThrottle2 = _interopRequireDefault(_operatorsThrottle);

var _operatorsDebounce = require('./operators/debounce');

var _operatorsDebounce2 = _interopRequireDefault(_operatorsDebounce);

var _operatorsBuffer = require('./operators/buffer');

var _operatorsBuffer2 = _interopRequireDefault(_operatorsBuffer);

var _operatorsBufferCount = require('./operators/bufferCount');

var _operatorsBufferCount2 = _interopRequireDefault(_operatorsBufferCount);

var _operatorsBufferTime = require('./operators/bufferTime');

var _operatorsBufferTime2 = _interopRequireDefault(_operatorsBufferTime);

var _operatorsBufferToggle = require('./operators/bufferToggle');

var _operatorsBufferToggle2 = _interopRequireDefault(_operatorsBufferToggle);

var _operatorsBufferWhen = require('./operators/bufferWhen');

var _operatorsBufferWhen2 = _interopRequireDefault(_operatorsBufferWhen);

var _operatorsSample = require('./operators/sample');

var _operatorsSample2 = _interopRequireDefault(_operatorsSample);

var _operatorsSampleTime = require('./operators/sampleTime');

var _operatorsSampleTime2 = _interopRequireDefault(_operatorsSampleTime);

var _operatorsIsEmpty = require('./operators/isEmpty');

var _operatorsIsEmpty2 = _interopRequireDefault(_operatorsIsEmpty);

var _operatorsLast = require('./operators/last');

var _operatorsLast2 = _interopRequireDefault(_operatorsLast);

var _operatorsSingle = require('./operators/single');

var _operatorsSingle2 = _interopRequireDefault(_operatorsSingle);

_Observable2['default'].defer = _observablesDeferObservable2['default'].create;
_Observable2['default'].from = _observablesFromObservable2['default'].create;
_Observable2['default'].fromArray = _observablesArrayObservable2['default'].create;
_Observable2['default'].fromPromise = _observablesPromiseObservable2['default'].create;
_Observable2['default'].of = _observablesArrayObservable2['default'].of;
_Observable2['default'].range = _observablesRangeObservable2['default'].create;
_Observable2['default'].fromEventPattern = _observablesFromEventPatternObservable2['default'].create;
_Observable2['default'].forkJoin = _observablesForkJoinObservable2['default'].create;
_Observable2['default']['throw'] = _observablesErrorObservable2['default'].create;
_Observable2['default'].empty = _observablesEmptyObservable2['default'].create;
_Observable2['default'].never = _observablesInfiniteObservable2['default'].create;
_Observable2['default'].timer = _observablesTimerObservable2['default'].create;
_Observable2['default'].interval = _observablesIntervalObservable2['default'].create;
_Observable2['default'].fromEvent = _observablesFromEventObservable2['default'].create;
var observableProto = _Observable2['default'].prototype;

_Observable2['default'].concat = _operatorsConcatStatic2['default'];
observableProto.concat = _operatorsConcat2['default'];
observableProto.concatAll = _operatorsConcatAll2['default'];
observableProto.concatMap = _operatorsConcatMap2['default'];
observableProto.concatMapTo = _operatorsConcatMapTo2['default'];

_Observable2['default'].merge = _operatorsMergeStatic2['default'];
observableProto.merge = _operatorsMerge2['default'];
observableProto.mergeAll = _operatorsMergeAll2['default'];
observableProto.flatMap = _operatorsMergeMap2['default'];
observableProto.flatMapTo = _operatorsMergeMapTo2['default'];
observableProto.mergeMap = _operatorsMergeMap2['default'];
observableProto.mergeMapTo = _operatorsMergeMapTo2['default'];
observableProto['switch'] = _operatorsSwitch2['default'];
observableProto.switchMap = _operatorsSwitchMap2['default'];
observableProto.switchMapTo = _operatorsSwitchMapTo2['default'];
observableProto.expand = _operatorsExpand2['default'];

observableProto['do'] = _operatorsDo2['default'];
observableProto.map = _operatorsMap2['default'];
observableProto.mapTo = _operatorsMapTo2['default'];
observableProto.toArray = _operatorsToArray2['default'];
observableProto.count = _operatorsCount2['default'];
observableProto.scan = _operatorsScan2['default'];
observableProto.reduce = _operatorsReduce2['default'];
observableProto.startWith = _operatorsStartWith2['default'];

observableProto.take = _operatorsTake2['default'];
observableProto.skip = _operatorsSkip2['default'];
observableProto.takeUntil = _operatorsTakeUntil2['default'];
observableProto.skipUntil = _operatorsSkipUntil2['default'];
observableProto.elementAt = _operatorsElementAt2['default'];
observableProto.filter = _operatorsFilter2['default'];
observableProto.distinctUntilChanged = _operatorsDistinctUntilChanged2['default'];
observableProto.distinctUntilKeyChanged = _operatorsDistinctUntilKeyChanged2['default'];

_Observable2['default'].combineLatest = _operatorsCombineLatestStatic2['default'];
observableProto.combineLatest = _operatorsCombineLatest2['default'];
observableProto.combineAll = _operatorsCombineAll2['default'];
observableProto.withLatestFrom = _operatorsWithLatestFrom2['default'];

_Observable2['default'].zip = _operatorsZipStatic2['default'];
observableProto.zip = _operatorsZip2['default'];
observableProto.zipAll = _operatorsZipAll2['default'];

observableProto.publish = _operatorsPublish2['default'];
observableProto.publishBehavior = _operatorsPublishBehavior2['default'];
observableProto.publishReplay = _operatorsPublishReplay2['default'];
observableProto.multicast = _operatorsMulticast2['default'];

observableProto.observeOn = _operatorsObserveOn2['default'];
observableProto.subscribeOn = _operatorsSubscribeOn2['default'];

observableProto.partition = _operatorsPartition2['default'];
observableProto.toPromise = _operatorsToPromise2['default'];
observableProto.defaultIfEmpty = _operatorsDefaultIfEmpty2['default'];
observableProto.materialize = _operatorsMaterialize2['default'];

observableProto['catch'] = _operatorsCatch2['default'];
observableProto.retry = _operatorsRetry2['default'];
observableProto.retryWhen = _operatorsRetryWhen2['default'];
observableProto.repeat = _operatorsRepeat2['default'];

observableProto['finally'] = _operatorsFinally2['default'];
observableProto.timeout = _operatorsTimeout2['default'];
observableProto.timeoutWith = _operatorsTimeoutWith2['default'];

observableProto.groupBy = _operatorsGroupBy2['default'];
observableProto.window = _operatorsWindow2['default'];
observableProto.windowWhen = _operatorsWindowWhen2['default'];
observableProto.windowToggle = _operatorsWindowToggle2['default'];
observableProto.windowTime = _operatorsWindowTime2['default'];
observableProto.windowCount = _operatorsWindowCount2['default'];

observableProto.delay = _operatorsDelay2['default'];
observableProto.throttle = _operatorsThrottle2['default'];
observableProto.debounce = _operatorsDebounce2['default'];

observableProto.buffer = _operatorsBuffer2['default'];
observableProto.bufferCount = _operatorsBufferCount2['default'];
observableProto.bufferTime = _operatorsBufferTime2['default'];
observableProto.bufferToggle = _operatorsBufferToggle2['default'];
observableProto.bufferWhen = _operatorsBufferWhen2['default'];

observableProto.sample = _operatorsSample2['default'];
observableProto.sampleTime = _operatorsSampleTime2['default'];

observableProto.isEmpty = _operatorsIsEmpty2['default'];
observableProto.last = _operatorsLast2['default'];
observableProto.single = _operatorsSingle2['default'];
var Scheduler = {
    nextTick: _schedulersNextTick2['default'],
    immediate: _schedulersImmediate2['default']
};
exports.Subject = _Subject2['default'];
exports.Scheduler = Scheduler;
exports.Observable = _Observable2['default'];
exports.Subscriber = _Subscriber2['default'];
exports.Subscription = _Subscription2['default'];
exports.ReplaySubject = _subjectsReplaySubject2['default'];
exports.BehaviorSubject = _subjectsBehaviorSubject2['default'];
exports.ConnectableObservable = _observablesConnectableObservable2['default'];
exports.Notification = _Notification2['default'];
exports.VirtualTimeScheduler = _schedulersVirtualTimeScheduler2['default'];
exports.TestScheduler = _schedulersTestScheduler2['default'];
exports.EmptyError = _utilEmptyError2['default'];
exports.ArgumentOutOfRangeError = _utilArgumentOutOfRangeError2['default'];
},{"./Notification":3,"./Observable":4,"./Subject":7,"./Subscriber":8,"./Subscription":9,"./observables/ArrayObservable":10,"./observables/ConnectableObservable":11,"./observables/DeferObservable":12,"./observables/EmptyObservable":13,"./observables/ErrorObservable":14,"./observables/ForkJoinObservable":15,"./observables/FromEventObservable":16,"./observables/FromEventPatternObservable":17,"./observables/FromObservable":18,"./observables/InfiniteObservable":19,"./observables/IntervalObservable":20,"./observables/PromiseObservable":22,"./observables/RangeObservable":23,"./observables/TimerObservable":26,"./operators/buffer":27,"./operators/bufferCount":28,"./operators/bufferTime":29,"./operators/bufferToggle":30,"./operators/bufferWhen":31,"./operators/catch":32,"./operators/combineAll":33,"./operators/combineLatest":36,"./operators/combineLatest-static":34,"./operators/concat":38,"./operators/concat-static":37,"./operators/concatAll":39,"./operators/concatMap":40,"./operators/concatMapTo":41,"./operators/count":42,"./operators/debounce":43,"./operators/defaultIfEmpty":44,"./operators/delay":45,"./operators/distinctUntilChanged":46,"./operators/distinctUntilKeyChanged":47,"./operators/do":48,"./operators/elementAt":49,"./operators/expand":51,"./operators/filter":52,"./operators/finally":53,"./operators/groupBy":54,"./operators/isEmpty":55,"./operators/last":56,"./operators/map":57,"./operators/mapTo":58,"./operators/materialize":59,"./operators/merge":61,"./operators/merge-static":60,"./operators/mergeAll":63,"./operators/mergeMap":65,"./operators/mergeMapTo":67,"./operators/multicast":68,"./operators/observeOn":70,"./operators/partition":71,"./operators/publish":72,"./operators/publishBehavior":73,"./operators/publishReplay":74,"./operators/reduce":75,"./operators/repeat":76,"./operators/retry":77,"./operators/retryWhen":78,"./operators/sample":79,"./operators/sampleTime":80,"./operators/scan":81,"./operators/single":82,"./operators/skip":83,"./operators/skipUntil":84,"./operators/startWith":85,"./operators/subscribeOn":86,"./operators/switch":87,"./operators/switchMap":88,"./operators/switchMapTo":89,"./operators/take":90,"./operators/takeUntil":91,"./operators/throttle":92,"./operators/timeout":93,"./operators/timeoutWith":94,"./operators/toArray":95,"./operators/toPromise":96,"./operators/window":97,"./operators/windowCount":98,"./operators/windowTime":99,"./operators/windowToggle":100,"./operators/windowWhen":101,"./operators/withLatestFrom":102,"./operators/zip":105,"./operators/zip-static":103,"./operators/zipAll":106,"./schedulers/TestScheduler":112,"./schedulers/VirtualTimeScheduler":113,"./schedulers/immediate":114,"./schedulers/nextTick":115,"./subjects/BehaviorSubject":116,"./subjects/ReplaySubject":118,"./util/ArgumentOutOfRangeError":120,"./util/EmptyError":121}],7:[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _Observable2 = require('./Observable');

var _Observable3 = _interopRequireDefault(_Observable2);

var _Subscriber = require('./Subscriber');

var _Subscriber2 = _interopRequireDefault(_Subscriber);

var _Subscription = require('./Subscription');

var _Subscription2 = _interopRequireDefault(_Subscription);

var _subjectsSubjectSubscription = require('./subjects/SubjectSubscription');

var _subjectsSubjectSubscription2 = _interopRequireDefault(_subjectsSubjectSubscription);

var subscriptionAdd = _Subscription2['default'].prototype.add;
var subscriptionRemove = _Subscription2['default'].prototype.remove;
var subscriptionUnsubscribe = _Subscription2['default'].prototype.unsubscribe;
var subscriberNext = _Subscriber2['default'].prototype.next;
var subscriberError = _Subscriber2['default'].prototype.error;
var subscriberComplete = _Subscriber2['default'].prototype.complete;
var _subscriberNext = _Subscriber2['default'].prototype._next;
var _subscriberError = _Subscriber2['default'].prototype._error;
var _subscriberComplete = _Subscriber2['default'].prototype._complete;
var _observableSubscribe = _Observable3['default'].prototype._subscribe;

var Subject = (function (_Observable) {
    _inherits(Subject, _Observable);

    function Subject() {
        _classCallCheck(this, Subject);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        _Observable.call.apply(_Observable, [this].concat(args));
        this.observers = [];
        this.isUnsubscribed = false;
        this.dispatching = false;
        this.errorSignal = false;
        this.completeSignal = false;
    }

    Subject.create = function create(source, destination) {
        return new BidirectionalSubject(source, destination);
    };

    Subject.prototype.lift = function lift(operator) {
        var subject = new BidirectionalSubject(this, this.destination || this);
        subject.operator = operator;
        return subject;
    };

    Subject.prototype._subscribe = function _subscribe(subscriber) {
        if (subscriber.isUnsubscribed) {
            return;
        } else if (this.errorSignal) {
            subscriber.error(this.errorInstance);
            return;
        } else if (this.completeSignal) {
            subscriber.complete();
            return;
        } else if (this.isUnsubscribed) {
            throw new Error("Cannot subscribe to a disposed Subject.");
        }
        this.observers.push(subscriber);
        return new _subjectsSubjectSubscription2['default'](this, subscriber);
    };

    Subject.prototype.add = function add(subscription) {
        subscriptionAdd.call(this, subscription);
    };

    Subject.prototype.remove = function remove(subscription) {
        subscriptionRemove.call(this, subscription);
    };

    Subject.prototype.unsubscribe = function unsubscribe() {
        this.observers = void 0;
        subscriptionUnsubscribe.call(this);
    };

    Subject.prototype.next = function next(value) {
        if (this.isUnsubscribed) {
            return;
        }
        this.dispatching = true;
        this._next(value);
        this.dispatching = false;
        if (this.errorSignal) {
            this.error(this.errorInstance);
        } else if (this.completeSignal) {
            this.complete();
        }
    };

    Subject.prototype.error = function error(_error) {
        if (this.isUnsubscribed || this.completeSignal) {
            return;
        }
        this.errorSignal = true;
        this.errorInstance = _error;
        if (this.dispatching) {
            return;
        }
        this._error(_error);
        this.unsubscribe();
    };

    Subject.prototype.complete = function complete() {
        if (this.isUnsubscribed || this.errorSignal) {
            return;
        }
        this.completeSignal = true;
        if (this.dispatching) {
            return;
        }
        this._complete();
        this.unsubscribe();
    };

    Subject.prototype._next = function _next(value) {
        var index = -1;
        var observers = this.observers.slice(0);
        var len = observers.length;
        while (++index < len) {
            observers[index].next(value);
        }
    };

    Subject.prototype._error = function _error(error) {
        var index = -1;
        var observers = this.observers;
        var len = observers.length;
        // optimization -- block next, complete, and unsubscribe while dispatching
        this.observers = void 0;
        this.isUnsubscribed = true;
        while (++index < len) {
            observers[index].error(error);
        }
        this.isUnsubscribed = false;
    };

    Subject.prototype._complete = function _complete() {
        var index = -1;
        var observers = this.observers;
        var len = observers.length;
        // optimization -- block next, complete, and unsubscribe while dispatching
        this.observers = void 0; // optimization
        this.isUnsubscribed = true;
        while (++index < len) {
            observers[index].complete();
        }
        this.isUnsubscribed = false;
    };

    return Subject;
})(_Observable3['default']);

exports['default'] = Subject;

var BidirectionalSubject = (function (_Subject) {
    _inherits(BidirectionalSubject, _Subject);

    function BidirectionalSubject(source, destination) {
        _classCallCheck(this, BidirectionalSubject);

        _Subject.call(this);
        this.source = source;
        this.destination = destination;
    }

    BidirectionalSubject.prototype._subscribe = function _subscribe(subscriber) {
        return _observableSubscribe.call(this, subscriber);
    };

    BidirectionalSubject.prototype.next = function next(x) {
        subscriberNext.call(this, x);
    };

    BidirectionalSubject.prototype.error = function error(e) {
        subscriberError.call(this, e);
    };

    BidirectionalSubject.prototype.complete = function complete() {
        subscriberComplete.call(this);
    };

    BidirectionalSubject.prototype._next = function _next(x) {
        _subscriberNext.call(this, x);
    };

    BidirectionalSubject.prototype._error = function _error(e) {
        _subscriberError.call(this, e);
    };

    BidirectionalSubject.prototype._complete = function _complete() {
        _subscriberComplete.call(this);
    };

    return BidirectionalSubject;
})(Subject);

module.exports = exports['default'];
},{"./Observable":4,"./Subscriber":8,"./Subscription":9,"./subjects/SubjectSubscription":119}],8:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _utilNoop = require('./util/noop');

var _utilNoop2 = _interopRequireDefault(_utilNoop);

var _utilThrowError = require('./util/throwError');

var _utilThrowError2 = _interopRequireDefault(_utilThrowError);

var _utilTryOrOnError = require('./util/tryOrOnError');

var _utilTryOrOnError2 = _interopRequireDefault(_utilTryOrOnError);

var _Subscription2 = require('./Subscription');

var _Subscription3 = _interopRequireDefault(_Subscription2);

var Subscriber = (function (_Subscription) {
    _inherits(Subscriber, _Subscription);

    function Subscriber(destination) {
        _classCallCheck(this, Subscriber);

        _Subscription.call(this);
        this._isUnsubscribed = false;
        this.destination = destination;
        if (!destination) {
            return;
        }
        var subscription = destination._subscription;
        if (subscription) {
            this._subscription = subscription;
        } else if (destination instanceof Subscriber) {
            this._subscription = destination;
        }
    }

    Subscriber.create = function create(next, error, complete) {
        var subscriber = new Subscriber();
        subscriber._next = typeof next === "function" && _utilTryOrOnError2['default'](next) || _utilNoop2['default'];
        subscriber._error = typeof error === "function" && error || _utilThrowError2['default'];
        subscriber._complete = typeof complete === "function" && complete || _utilNoop2['default'];
        return subscriber;
    };

    Subscriber.prototype._next = function _next(value) {
        this.destination.next(value);
    };

    Subscriber.prototype._error = function _error(err) {
        this.destination.error(err);
    };

    Subscriber.prototype._complete = function _complete() {
        this.destination.complete();
    };

    Subscriber.prototype.add = function add(sub) {
        // route add to the shared Subscription if it exists
        var _subscription = this._subscription;
        if (_subscription) {
            _subscription.add(sub);
        } else {
            _Subscription.prototype.add.call(this, sub);
        }
    };

    Subscriber.prototype.remove = function remove(sub) {
        // route remove to the shared Subscription if it exists
        if (this._subscription) {
            this._subscription.remove(sub);
        } else {
            _Subscription.prototype.remove.call(this, sub);
        }
    };

    Subscriber.prototype.unsubscribe = function unsubscribe() {
        if (this._isUnsubscribed) {
            return;
        } else if (this._subscription) {
            this._isUnsubscribed = true;
        } else {
            _Subscription.prototype.unsubscribe.call(this);
        }
    };

    Subscriber.prototype.next = function next(value) {
        if (!this.isUnsubscribed) {
            this._next(value);
        }
    };

    Subscriber.prototype.error = function error(_error2) {
        if (!this.isUnsubscribed) {
            this._error(_error2);
            this.unsubscribe();
        }
    };

    Subscriber.prototype.complete = function complete() {
        if (!this.isUnsubscribed) {
            this._complete();
            this.unsubscribe();
        }
    };

    _createClass(Subscriber, [{
        key: 'isUnsubscribed',
        get: function get() {
            var subscription = this._subscription;
            if (subscription) {
                // route to the shared Subscription if it exists
                return this._isUnsubscribed || subscription.isUnsubscribed;
            } else {
                return this._isUnsubscribed;
            }
        },
        set: function set(value) {
            var subscription = this._subscription;
            if (subscription) {
                // route to the shared Subscription if it exists
                subscription.isUnsubscribed = Boolean(value);
            } else {
                this._isUnsubscribed = Boolean(value);
            }
        }
    }]);

    return Subscriber;
})(_Subscription3['default']);

exports['default'] = Subscriber;
module.exports = exports['default'];
},{"./Subscription":9,"./util/noop":131,"./util/throwError":135,"./util/tryOrOnError":137}],9:[function(require,module,exports){
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Subscription = (function () {
    function Subscription(_unsubscribe) {
        _classCallCheck(this, Subscription);

        this.isUnsubscribed = false;
        if (_unsubscribe) {
            this._unsubscribe = _unsubscribe;
        }
    }

    Subscription.prototype._unsubscribe = function _unsubscribe() {};

    Subscription.prototype.unsubscribe = function unsubscribe() {
        if (this.isUnsubscribed) {
            return;
        }
        this.isUnsubscribed = true;
        var unsubscribe = this._unsubscribe;
        var subscriptions = this._subscriptions;
        this._subscriptions = void 0;
        if (unsubscribe) {
            unsubscribe.call(this);
        }
        if (subscriptions != null) {
            var index = -1;
            var len = subscriptions.length;
            while (++index < len) {
                subscriptions[index].unsubscribe();
            }
        }
    };

    Subscription.prototype.add = function add(subscription) {
        // return early if:
        //  1. the subscription is null
        //  2. we're attempting to add our this
        //  3. we're attempting to add the static `empty` Subscription
        if (!subscription || subscription === this || subscription === Subscription.EMPTY) {
            return;
        }
        var sub = subscription;
        switch (typeof subscription) {
            case "function":
                sub = new Subscription(subscription);
            case "object":
                if (sub.isUnsubscribed || typeof sub.unsubscribe !== "function") {
                    break;
                } else if (this.isUnsubscribed) {
                    sub.unsubscribe();
                } else {
                    var subscriptions = this._subscriptions || (this._subscriptions = []);
                    subscriptions.push(sub);
                }
                break;
            default:
                throw new Error('Unrecognized subscription ' + subscription + ' added to Subscription.');
        }
    };

    Subscription.prototype.remove = function remove(subscription) {
        // return early if:
        //  1. the subscription is null
        //  2. we're attempting to remove ourthis
        //  3. we're attempting to remove the static `empty` Subscription
        if (subscription == null || subscription === this || subscription === Subscription.EMPTY) {
            return;
        }
        var subscriptions = this._subscriptions;
        if (subscriptions) {
            var subscriptionIndex = subscriptions.indexOf(subscription);
            if (subscriptionIndex !== -1) {
                subscriptions.splice(subscriptionIndex, 1);
            }
        }
    };

    return Subscription;
})();

exports["default"] = Subscription;

Subscription.EMPTY = (function (empty) {
    empty.isUnsubscribed = true;
    return empty;
})(new Subscription());
module.exports = exports["default"];
},{}],10:[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _Observable2 = require('../Observable');

var _Observable3 = _interopRequireDefault(_Observable2);

var _ScalarObservable = require('./ScalarObservable');

var _ScalarObservable2 = _interopRequireDefault(_ScalarObservable);

var _EmptyObservable = require('./EmptyObservable');

var _EmptyObservable2 = _interopRequireDefault(_EmptyObservable);

var ArrayObservable = (function (_Observable) {
    _inherits(ArrayObservable, _Observable);

    function ArrayObservable(array, scheduler) {
        _classCallCheck(this, ArrayObservable);

        _Observable.call(this);
        this.array = array;
        this.scheduler = scheduler;
        if (!scheduler && array.length === 1) {
            this._isScalar = true;
            this.value = array[0];
        }
    }

    ArrayObservable.create = function create(array, scheduler) {
        return new ArrayObservable(array, scheduler);
    };

    ArrayObservable.of = function of() {
        for (var _len = arguments.length, array = Array(_len), _key = 0; _key < _len; _key++) {
            array[_key] = arguments[_key];
        }

        var scheduler = array[array.length - 1];
        if (scheduler && typeof scheduler.schedule === "function") {
            array.pop();
        } else {
            scheduler = void 0;
        }
        var len = array.length;
        if (len > 1) {
            return new ArrayObservable(array, scheduler);
        } else if (len === 1) {
            return new _ScalarObservable2['default'](array[0], scheduler);
        } else {
            return new _EmptyObservable2['default'](scheduler);
        }
    };

    ArrayObservable.dispatch = function dispatch(state) {
        var array = state.array;
        var index = state.index;
        var count = state.count;
        var subscriber = state.subscriber;

        if (index >= count) {
            subscriber.complete();
            return;
        }
        subscriber.next(array[index]);
        if (subscriber.isUnsubscribed) {
            return;
        }
        state.index = index + 1;
        this.schedule(state);
    };

    ArrayObservable.prototype._subscribe = function _subscribe(subscriber) {
        var index = 0;
        var array = this.array;
        var count = array.length;
        var scheduler = this.scheduler;
        if (scheduler) {
            subscriber.add(scheduler.schedule(ArrayObservable.dispatch, 0, {
                array: array, index: index, count: count, subscriber: subscriber
            }));
        } else {
            for (var i = 0; i < count && !subscriber.isUnsubscribed; i++) {
                subscriber.next(array[i]);
            }
            subscriber.complete();
        }
    };

    return ArrayObservable;
})(_Observable3['default']);

exports['default'] = ArrayObservable;
module.exports = exports['default'];
},{"../Observable":4,"./EmptyObservable":13,"./ScalarObservable":24}],11:[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _Observable3 = require('../Observable');

var _Observable4 = _interopRequireDefault(_Observable3);

var _Subscription3 = require('../Subscription');

var _Subscription4 = _interopRequireDefault(_Subscription3);

var ConnectableObservable = (function (_Observable) {
    _inherits(ConnectableObservable, _Observable);

    function ConnectableObservable(source, subjectFactory) {
        _classCallCheck(this, ConnectableObservable);

        _Observable.call(this);
        this.source = source;
        this.subjectFactory = subjectFactory;
    }

    ConnectableObservable.prototype._subscribe = function _subscribe(subscriber) {
        return this._getSubject().subscribe(subscriber);
    };

    ConnectableObservable.prototype._getSubject = function _getSubject() {
        var subject = this.subject;
        if (subject && !subject.isUnsubscribed) {
            return subject;
        }
        return this.subject = this.subjectFactory();
    };

    ConnectableObservable.prototype.connect = function connect() {
        var source = this.source;
        var subscription = this.subscription;
        if (subscription && !subscription.isUnsubscribed) {
            return subscription;
        }
        subscription = source.subscribe(this._getSubject());
        subscription.add(new ConnectableSubscription(this));
        return this.subscription = subscription;
    };

    ConnectableObservable.prototype.refCount = function refCount() {
        return new RefCountObservable(this);
    };

    return ConnectableObservable;
})(_Observable4['default']);

exports['default'] = ConnectableObservable;

var ConnectableSubscription = (function (_Subscription) {
    _inherits(ConnectableSubscription, _Subscription);

    function ConnectableSubscription(connectable) {
        _classCallCheck(this, ConnectableSubscription);

        _Subscription.call(this);
        this.connectable = connectable;
    }

    ConnectableSubscription.prototype._unsubscribe = function _unsubscribe() {
        var connectable = this.connectable;
        connectable.subject = void 0;
        connectable.subscription = void 0;
        this.connectable = void 0;
    };

    return ConnectableSubscription;
})(_Subscription4['default']);

var RefCountObservable = (function (_Observable2) {
    _inherits(RefCountObservable, _Observable2);

    function RefCountObservable(connectable) {
        var refCount = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

        _classCallCheck(this, RefCountObservable);

        _Observable2.call(this);
        this.connectable = connectable;
        this.refCount = refCount;
    }

    RefCountObservable.prototype._subscribe = function _subscribe(subscriber) {
        var connectable = this.connectable;
        var subscription = connectable.subscribe(subscriber);
        if (++this.refCount === 1) {
            this.connection = connectable.connect();
        }
        subscription.add(new RefCountSubscription(this));
        return subscription;
    };

    return RefCountObservable;
})(_Observable4['default']);

var RefCountSubscription = (function (_Subscription2) {
    _inherits(RefCountSubscription, _Subscription2);

    function RefCountSubscription(refCountObservable) {
        _classCallCheck(this, RefCountSubscription);

        _Subscription2.call(this);
        this.refCountObservable = refCountObservable;
    }

    RefCountSubscription.prototype._unsubscribe = function _unsubscribe() {
        var observable = this.refCountObservable;
        if (--observable.refCount === 0) {
            observable.connection.unsubscribe();
            observable.connection = void 0;
        }
    };

    return RefCountSubscription;
})(_Subscription4['default']);

module.exports = exports['default'];
},{"../Observable":4,"../Subscription":9}],12:[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _Observable2 = require('../Observable');

var _Observable3 = _interopRequireDefault(_Observable2);

var _utilTryCatch = require('../util/tryCatch');

var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

var _utilErrorObject = require('../util/errorObject');

var DeferObservable = (function (_Observable) {
    _inherits(DeferObservable, _Observable);

    function DeferObservable(observableFactory) {
        _classCallCheck(this, DeferObservable);

        _Observable.call(this);
        this.observableFactory = observableFactory;
    }

    DeferObservable.create = function create(observableFactory) {
        return new DeferObservable(observableFactory);
    };

    DeferObservable.prototype._subscribe = function _subscribe(subscriber) {
        var result = _utilTryCatch2['default'](this.observableFactory)();
        if (result === _utilErrorObject.errorObject) {
            subscriber.error(_utilErrorObject.errorObject.e);
        } else {
            result.subscribe(subscriber);
        }
    };

    return DeferObservable;
})(_Observable3['default']);

exports['default'] = DeferObservable;
module.exports = exports['default'];
},{"../Observable":4,"../util/errorObject":128,"../util/tryCatch":136}],13:[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _Observable2 = require('../Observable');

var _Observable3 = _interopRequireDefault(_Observable2);

var EmptyObservable = (function (_Observable) {
    _inherits(EmptyObservable, _Observable);

    function EmptyObservable(scheduler) {
        _classCallCheck(this, EmptyObservable);

        _Observable.call(this);
        this.scheduler = scheduler;
    }

    EmptyObservable.create = function create(scheduler) {
        return new EmptyObservable(scheduler);
    };

    EmptyObservable.dispatch = function dispatch(_ref) {
        var subscriber = _ref.subscriber;

        subscriber.complete();
    };

    EmptyObservable.prototype._subscribe = function _subscribe(subscriber) {
        var scheduler = this.scheduler;
        if (scheduler) {
            subscriber.add(scheduler.schedule(EmptyObservable.dispatch, 0, { subscriber: subscriber }));
        } else {
            subscriber.complete();
        }
    };

    return EmptyObservable;
})(_Observable3['default']);

exports['default'] = EmptyObservable;
module.exports = exports['default'];
},{"../Observable":4}],14:[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _Observable2 = require('../Observable');

var _Observable3 = _interopRequireDefault(_Observable2);

var ErrorObservable = (function (_Observable) {
    _inherits(ErrorObservable, _Observable);

    function ErrorObservable(error, scheduler) {
        _classCallCheck(this, ErrorObservable);

        _Observable.call(this);
        this.error = error;
        this.scheduler = scheduler;
    }

    ErrorObservable.create = function create(error, scheduler) {
        return new ErrorObservable(error, scheduler);
    };

    ErrorObservable.dispatch = function dispatch(_ref) {
        var error = _ref.error;
        var subscriber = _ref.subscriber;

        subscriber.error(error);
    };

    ErrorObservable.prototype._subscribe = function _subscribe(subscriber) {
        var error = this.error;
        var scheduler = this.scheduler;
        if (scheduler) {
            subscriber.add(scheduler.schedule(ErrorObservable.dispatch, 0, {
                error: error, subscriber: subscriber
            }));
        } else {
            subscriber.error(error);
        }
    };

    return ErrorObservable;
})(_Observable3['default']);

exports['default'] = ErrorObservable;
module.exports = exports['default'];
},{"../Observable":4}],15:[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _Observable2 = require('../Observable');

var _Observable3 = _interopRequireDefault(_Observable2);

var _Subscriber2 = require('../Subscriber');

var _Subscriber3 = _interopRequireDefault(_Subscriber2);

var ForkJoinObservable = (function (_Observable) {
    _inherits(ForkJoinObservable, _Observable);

    function ForkJoinObservable(observables) {
        _classCallCheck(this, ForkJoinObservable);

        _Observable.call(this);
        this.observables = observables;
    }

    ForkJoinObservable.create = function create() {
        for (var _len = arguments.length, observables = Array(_len), _key = 0; _key < _len; _key++) {
            observables[_key] = arguments[_key];
        }

        return new ForkJoinObservable(observables);
    };

    ForkJoinObservable.prototype._subscribe = function _subscribe(subscriber) {
        var observables = this.observables;
        var len = observables.length;
        var context = { complete: 0, total: len, values: emptyArray(len) };
        for (var i = 0; i < len; i++) {
            observables[i].subscribe(new AllSubscriber(subscriber, this, i, context));
        }
    };

    return ForkJoinObservable;
})(_Observable3['default']);

exports['default'] = ForkJoinObservable;

var AllSubscriber = (function (_Subscriber) {
    _inherits(AllSubscriber, _Subscriber);

    function AllSubscriber(destination, parent, index, context) {
        _classCallCheck(this, AllSubscriber);

        _Subscriber.call(this, destination);
        this.parent = parent;
        this.index = index;
        this.context = context;
    }

    AllSubscriber.prototype._next = function _next(value) {
        this._value = value;
    };

    AllSubscriber.prototype._complete = function _complete() {
        var context = this.context;
        context.values[this.index] = this._value;
        if (context.values.every(hasValue)) {
            this.destination.next(context.values);
            this.destination.complete();
        }
    };

    return AllSubscriber;
})(_Subscriber3['default']);

function hasValue(x) {
    return x !== null;
}
function emptyArray(len) {
    var arr = [];
    for (var i = 0; i < len; i++) {
        arr.push(null);
    }
    return arr;
}
module.exports = exports['default'];
},{"../Observable":4,"../Subscriber":8}],16:[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _Observable2 = require('../Observable');

var _Observable3 = _interopRequireDefault(_Observable2);

var _utilTryCatch = require('../util/tryCatch');

var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

var _utilErrorObject = require('../util/errorObject');

var _Subscription = require('../Subscription');

var _Subscription2 = _interopRequireDefault(_Subscription);

var FromEventObservable = (function (_Observable) {
    _inherits(FromEventObservable, _Observable);

    function FromEventObservable(sourceObj, eventName, selector) {
        _classCallCheck(this, FromEventObservable);

        _Observable.call(this);
        this.sourceObj = sourceObj;
        this.eventName = eventName;
        this.selector = selector;
    }

    FromEventObservable.create = function create(sourceObj, eventName, selector) {
        return new FromEventObservable(sourceObj, eventName, selector);
    };

    FromEventObservable.setupSubscription = function setupSubscription(sourceObj, eventName, handler, subscriber) {
        var unsubscribe = undefined;
        var tag = sourceObj.toString();
        if (tag === '[object NodeList]' || tag === '[object HTMLCollection]') {
            for (var i = 0, len = sourceObj.length; i < len; i++) {
                FromEventObservable.setupSubscription(sourceObj[i], eventName, handler, subscriber);
            }
        } else if (typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function') {
            sourceObj.addEventListener(eventName, handler);
            unsubscribe = function () {
                return sourceObj.removeEventListener(eventName, handler);
            };
        } else if (typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function') {
            sourceObj.on(eventName, handler);
            unsubscribe = function () {
                return sourceObj.off(eventName, handler);
            };
        } else if (typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function') {
            sourceObj.addListener(eventName, handler);
            unsubscribe = function () {
                return sourceObj.removeListener(eventName, handler);
            };
        }
        subscriber.add(new _Subscription2['default'](unsubscribe));
    };

    FromEventObservable.prototype._subscribe = function _subscribe(subscriber) {
        var sourceObj = this.sourceObj;
        var eventName = this.eventName;
        var selector = this.selector;
        var handler = selector ? function (e) {
            var result = _utilTryCatch2['default'](selector)(e);
            if (result === _utilErrorObject.errorObject) {
                subscriber.error(result.e);
            } else {
                subscriber.next(result);
            }
        } : function (e) {
            return subscriber.next(e);
        };
        FromEventObservable.setupSubscription(sourceObj, eventName, handler, subscriber);
    };

    return FromEventObservable;
})(_Observable3['default']);

exports['default'] = FromEventObservable;
module.exports = exports['default'];
},{"../Observable":4,"../Subscription":9,"../util/errorObject":128,"../util/tryCatch":136}],17:[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _Observable2 = require('../Observable');

var _Observable3 = _interopRequireDefault(_Observable2);

var _Subscription = require('../Subscription');

var _Subscription2 = _interopRequireDefault(_Subscription);

var _utilTryCatch = require('../util/tryCatch');

var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

var _utilErrorObject = require('../util/errorObject');

var FromEventPatternObservable = (function (_Observable) {
    _inherits(FromEventPatternObservable, _Observable);

    function FromEventPatternObservable(addHandler, removeHandler, selector) {
        _classCallCheck(this, FromEventPatternObservable);

        _Observable.call(this);
        this.addHandler = addHandler;
        this.removeHandler = removeHandler;
        this.selector = selector;
    }

    FromEventPatternObservable.create = function create(addHandler, removeHandler, selector) {
        return new FromEventPatternObservable(addHandler, removeHandler, selector);
        ;
    };

    FromEventPatternObservable.prototype._subscribe = function _subscribe(subscriber) {
        var addHandler = this.addHandler;
        var removeHandler = this.removeHandler;
        var selector = this.selector;
        var handler = selector ? function (e) {
            var result = _utilTryCatch2['default'](selector).apply(null, arguments);
            if (result === _utilErrorObject.errorObject) {
                subscriber.error(result.e);
            } else {
                subscriber.next(result);
            }
        } : function (e) {
            subscriber.next(e);
        };
        var result = _utilTryCatch2['default'](addHandler)(handler);
        if (result === _utilErrorObject.errorObject) {
            subscriber.error(result.e);
        }
        subscriber.add(new _Subscription2['default'](function () {
            //TODO: determine whether or not to forward to error handler
            removeHandler(handler);
        }));
    };

    return FromEventPatternObservable;
})(_Observable3['default']);

exports['default'] = FromEventPatternObservable;
module.exports = exports['default'];
},{"../Observable":4,"../Subscription":9,"../util/errorObject":128,"../util/tryCatch":136}],18:[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _PromiseObservable = require('./PromiseObservable');

var _PromiseObservable2 = _interopRequireDefault(_PromiseObservable);

var _IteratorObservable = require('./IteratorObservable');

var _IteratorObservable2 = _interopRequireDefault(_IteratorObservable);

var _ArrayObservable = require('./ArrayObservable');

var _ArrayObservable2 = _interopRequireDefault(_ArrayObservable);

var _utilSymbol_observable = require('../util/Symbol_observable');

var _utilSymbol_observable2 = _interopRequireDefault(_utilSymbol_observable);

var _utilSymbol_iterator = require('../util/Symbol_iterator');

var _utilSymbol_iterator2 = _interopRequireDefault(_utilSymbol_iterator);

var _Observable2 = require('../Observable');

var _Observable3 = _interopRequireDefault(_Observable2);

var _operatorsObserveOnSupport = require('../operators/observeOn-support');

var _schedulersImmediate = require('../schedulers/immediate');

var _schedulersImmediate2 = _interopRequireDefault(_schedulersImmediate);

var isArray = Array.isArray;

var FromObservable = (function (_Observable) {
    _inherits(FromObservable, _Observable);

    function FromObservable(ish, scheduler) {
        _classCallCheck(this, FromObservable);

        _Observable.call(this, null);
        this.ish = ish;
        this.scheduler = scheduler;
    }

    FromObservable.create = function create(ish) {
        var scheduler = arguments.length <= 1 || arguments[1] === undefined ? _schedulersImmediate2['default'] : arguments[1];

        if (ish) {
            if (isArray(ish)) {
                return new _ArrayObservable2['default'](ish, scheduler);
            } else if (typeof ish.then === 'function') {
                return new _PromiseObservable2['default'](ish, scheduler);
            } else if (typeof ish[_utilSymbol_observable2['default']] === 'function') {
                if (ish instanceof _Observable3['default']) {
                    return ish;
                }
                return new FromObservable(ish, scheduler);
            } else if (typeof ish[_utilSymbol_iterator2['default']] === 'function') {
                return new _IteratorObservable2['default'](ish, null, null, scheduler);
            }
        }
        throw new TypeError(typeof ish + ' is not observable');
    };

    FromObservable.prototype._subscribe = function _subscribe(subscriber) {
        var ish = this.ish;
        var scheduler = this.scheduler;
        if (scheduler === _schedulersImmediate2['default']) {
            return this.ish[_utilSymbol_observable2['default']]().subscribe(subscriber);
        } else {
            return this.ish[_utilSymbol_observable2['default']]().subscribe(new _operatorsObserveOnSupport.ObserveOnSubscriber(subscriber, scheduler, 0));
        }
    };

    return FromObservable;
})(_Observable3['default']);

exports['default'] = FromObservable;
module.exports = exports['default'];
},{"../Observable":4,"../operators/observeOn-support":69,"../schedulers/immediate":114,"../util/Symbol_iterator":125,"../util/Symbol_observable":126,"./ArrayObservable":10,"./IteratorObservable":21,"./PromiseObservable":22}],19:[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _Observable2 = require('../Observable');

var _Observable3 = _interopRequireDefault(_Observable2);

var InfiniteObservable = (function (_Observable) {
    _inherits(InfiniteObservable, _Observable);

    function InfiniteObservable() {
        _classCallCheck(this, InfiniteObservable);

        _Observable.call(this);
    }

    InfiniteObservable.create = function create() {
        return new InfiniteObservable();
    };

    InfiniteObservable.prototype._subscribe = function _subscribe(subscriber) {};

    return InfiniteObservable;
})(_Observable3['default']);

exports['default'] = InfiniteObservable;
module.exports = exports['default'];
},{"../Observable":4}],20:[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _utilIsNumeric = require('../util/isNumeric');

var _utilIsNumeric2 = _interopRequireDefault(_utilIsNumeric);

var _Observable2 = require('../Observable');

var _Observable3 = _interopRequireDefault(_Observable2);

var _schedulersNextTick = require('../schedulers/nextTick');

var _schedulersNextTick2 = _interopRequireDefault(_schedulersNextTick);

var IntervalObservable = (function (_Observable) {
    _inherits(IntervalObservable, _Observable);

    function IntervalObservable() {
        var period = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];
        var scheduler = arguments.length <= 1 || arguments[1] === undefined ? _schedulersNextTick2['default'] : arguments[1];

        _classCallCheck(this, IntervalObservable);

        _Observable.call(this);
        this.period = period;
        this.scheduler = scheduler;
        if (!_utilIsNumeric2['default'](period) || period < 0) {
            this.period = 0;
        }
        if (!scheduler || typeof scheduler.schedule !== "function") {
            this.scheduler = _schedulersNextTick2['default'];
        }
    }

    IntervalObservable.create = function create() {
        var period = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];
        var scheduler = arguments.length <= 1 || arguments[1] === undefined ? _schedulersNextTick2['default'] : arguments[1];

        return new IntervalObservable(period, scheduler);
    };

    IntervalObservable.dispatch = function dispatch(state) {
        var index = state.index;
        var subscriber = state.subscriber;
        var period = state.period;

        subscriber.next(index);
        if (subscriber.isUnsubscribed) {
            return;
        }
        state.index += 1;
        this.schedule(state, period);
    };

    IntervalObservable.prototype._subscribe = function _subscribe(subscriber) {
        var index = 0;
        var period = this.period;
        var scheduler = this.scheduler;
        subscriber.add(scheduler.schedule(IntervalObservable.dispatch, period, {
            index: index, subscriber: subscriber, period: period
        }));
    };

    return IntervalObservable;
})(_Observable3['default']);

exports['default'] = IntervalObservable;
module.exports = exports['default'];
},{"../Observable":4,"../schedulers/nextTick":115,"../util/isNumeric":130}],21:[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _Observable2 = require('../Observable');

var _Observable3 = _interopRequireDefault(_Observable2);

var _utilRoot = require('../util/root');

var _utilSymbol_iterator = require('../util/Symbol_iterator');

var _utilSymbol_iterator2 = _interopRequireDefault(_utilSymbol_iterator);

var _utilTryCatch = require('../util/tryCatch');

var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

var _utilErrorObject = require('../util/errorObject');

var IteratorObservable = (function (_Observable) {
    _inherits(IteratorObservable, _Observable);

    function IteratorObservable(iterator, project, thisArg, scheduler) {
        _classCallCheck(this, IteratorObservable);

        _Observable.call(this);
        this.iterator = iterator;
        this.project = project;
        this.thisArg = thisArg;
        this.scheduler = scheduler;
    }

    IteratorObservable.create = function create(iterator, project, thisArg, scheduler) {
        if (iterator == null) {
            throw new Error('iterator cannot be null.');
        }
        if (project && typeof project !== "function") {
            throw new Error('When provided, `project` must be a function.');
        }
        return new IteratorObservable(iterator, project, thisArg, scheduler);
    };

    IteratorObservable.dispatch = function dispatch(state) {
        var index = state.index;
        var hasError = state.hasError;
        var thisArg = state.thisArg;
        var project = state.project;
        var iterator = state.iterator;
        var subscriber = state.subscriber;

        if (hasError) {
            subscriber.error(state.error);
            return;
        }
        var result = iterator.next();
        if (result.done) {
            subscriber.complete();
            return;
        }
        if (project) {
            result = _utilTryCatch2['default'](project).call(thisArg, result.value, index);
            if (result === _utilErrorObject.errorObject) {
                state.error = _utilErrorObject.errorObject.e;
                state.hasError = true;
            } else {
                subscriber.next(result);
                state.index = index + 1;
            }
        } else {
            subscriber.next(result.value);
            state.index = index + 1;
        }
        if (subscriber.isUnsubscribed) {
            return;
        }
        this.schedule(state);
    };

    IteratorObservable.prototype._subscribe = function _subscribe(subscriber) {
        var index = 0;
        var project = this.project;
        var thisArg = this.thisArg;
        var iterator = getIterator(Object(this.iterator));
        var scheduler = this.scheduler;
        if (scheduler) {
            subscriber.add(scheduler.schedule(IteratorObservable.dispatch, 0, {
                index: index, thisArg: thisArg, project: project, iterator: iterator, subscriber: subscriber
            }));
        } else {
            do {
                var result = iterator.next();
                if (result.done) {
                    subscriber.complete();
                    break;
                } else if (project) {
                    result = _utilTryCatch2['default'](project).call(thisArg, result.value, index++);
                    if (result === _utilErrorObject.errorObject) {
                        subscriber.error(_utilErrorObject.errorObject.e);
                        break;
                    }
                    subscriber.next(result);
                } else {
                    subscriber.next(result.value);
                }
                if (subscriber.isUnsubscribed) {
                    break;
                }
            } while (true);
        }
    };

    return IteratorObservable;
})(_Observable3['default']);

exports['default'] = IteratorObservable;

var maxSafeInteger = Math.pow(2, 53) - 1;

var StringIterator = (function () {
    function StringIterator(str) {
        var idx = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
        var len = arguments.length <= 2 || arguments[2] === undefined ? str.length : arguments[2];
        return (function () {
            _classCallCheck(this, StringIterator);

            this.str = str;
            this.idx = idx;
            this.len = len;
        }).apply(this, arguments);
    }

    StringIterator.prototype[_utilSymbol_iterator2['default']] = function () {
        return this;
    };

    StringIterator.prototype.next = function next() {
        return this.idx < this.len ? {
            done: false,
            value: this.str.charAt(this.idx++)
        } : {
            done: true,
            value: undefined
        };
    };

    return StringIterator;
})();

var ArrayIterator = (function () {
    function ArrayIterator(arr) {
        var idx = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
        var len = arguments.length <= 2 || arguments[2] === undefined ? toLength(arr) : arguments[2];
        return (function () {
            _classCallCheck(this, ArrayIterator);

            this.arr = arr;
            this.idx = idx;
            this.len = len;
        }).apply(this, arguments);
    }

    ArrayIterator.prototype[_utilSymbol_iterator2['default']] = function () {
        return this;
    };

    ArrayIterator.prototype.next = function next() {
        return this.idx < this.len ? {
            done: false,
            value: this.arr[this.idx++]
        } : {
            done: true,
            value: undefined
        };
    };

    return ArrayIterator;
})();

function getIterator(o) {
    var i = o[_utilSymbol_iterator2['default']];
    if (!i && typeof o === 'string') {
        return new StringIterator(o);
    }
    if (!i && o.length !== undefined) {
        return new ArrayIterator(o);
    }
    if (!i) {
        throw new TypeError('Object is not iterable');
    }
    return o[_utilSymbol_iterator2['default']]();
}
function toLength(o) {
    var len = +o.length;
    if (isNaN(len)) {
        return 0;
    }
    if (len === 0 || !numberIsFinite(len)) {
        return len;
    }
    len = sign(len) * Math.floor(Math.abs(len));
    if (len <= 0) {
        return 0;
    }
    if (len > maxSafeInteger) {
        return maxSafeInteger;
    }
    return len;
}
function numberIsFinite(value) {
    return typeof value === 'number' && _utilRoot.root.isFinite(value);
}
function isNan(n) {
    return n !== n;
}
function sign(value) {
    var valueAsNumber = +value;
    if (valueAsNumber === 0) {
        return valueAsNumber;
    }
    if (isNaN(valueAsNumber)) {
        return valueAsNumber;
    }
    return valueAsNumber < 0 ? -1 : 1;
}
module.exports = exports['default'];
},{"../Observable":4,"../util/Symbol_iterator":125,"../util/errorObject":128,"../util/root":133,"../util/tryCatch":136}],22:[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _Observable2 = require('../Observable');

var _Observable3 = _interopRequireDefault(_Observable2);

var _Subscription = require('../Subscription');

var _Subscription2 = _interopRequireDefault(_Subscription);

var _schedulersImmediate = require('../schedulers/immediate');

var _schedulersImmediate2 = _interopRequireDefault(_schedulersImmediate);

var PromiseObservable = (function (_Observable) {
    _inherits(PromiseObservable, _Observable);

    function PromiseObservable(promise, scheduler) {
        _classCallCheck(this, PromiseObservable);

        _Observable.call(this);
        this.promise = promise;
        this.scheduler = scheduler;
        this._isScalar = false;
    }

    PromiseObservable.create = function create(promise) {
        var scheduler = arguments.length <= 1 || arguments[1] === undefined ? _schedulersImmediate2['default'] : arguments[1];

        return new PromiseObservable(promise, scheduler);
    };

    PromiseObservable.prototype._subscribe = function _subscribe(subscriber) {
        var _this = this;

        var scheduler = this.scheduler;
        var promise = this.promise;
        if (scheduler === _schedulersImmediate2['default']) {
            if (this._isScalar) {
                subscriber.next(this.value);
                subscriber.complete();
            } else {
                promise.then(function (value) {
                    _this._isScalar = true;
                    _this.value = value;
                    subscriber.next(value);
                    subscriber.complete();
                }, function (err) {
                    return subscriber.error(err);
                }).then(null, function (err) {
                    // escape the promise trap, throw unhandled errors
                    setTimeout(function () {
                        throw err;
                    });
                });
            }
        } else {
            var _ret = (function () {
                var subscription = new _Subscription2['default']();
                if (_this._isScalar) {
                    var value = _this.value;
                    subscription.add(scheduler.schedule(dispatchNext, 0, { value: value, subscriber: subscriber }));
                } else {
                    promise.then(function (value) {
                        _this._isScalar = true;
                        _this.value = value;
                        subscription.add(scheduler.schedule(dispatchNext, 0, { value: value, subscriber: subscriber }));
                    }, function (err) {
                        return subscription.add(scheduler.schedule(dispatchError, 0, { err: err, subscriber: subscriber }));
                    }).then(null, function (err) {
                        // escape the promise trap, throw unhandled errors
                        scheduler.schedule(function () {
                            throw err;
                        });
                    });
                    ;
                }
                return {
                    v: subscription
                };
            })();

            if (typeof _ret === 'object') return _ret.v;
        }
    };

    return PromiseObservable;
})(_Observable3['default']);

exports['default'] = PromiseObservable;

function dispatchNext(_ref) {
    var value = _ref.value;
    var subscriber = _ref.subscriber;

    subscriber.next(value);
    subscriber.complete();
}
function dispatchError(_ref2) {
    var err = _ref2.err;
    var subscriber = _ref2.subscriber;

    subscriber.error(err);
}
module.exports = exports['default'];
},{"../Observable":4,"../Subscription":9,"../schedulers/immediate":114}],23:[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _Observable2 = require('../Observable');

var _Observable3 = _interopRequireDefault(_Observable2);

var RangeObservable = (function (_Observable) {
    _inherits(RangeObservable, _Observable);

    function RangeObservable(start, end, scheduler) {
        _classCallCheck(this, RangeObservable);

        _Observable.call(this);
        this.start = start;
        this.end = end;
        this.scheduler = scheduler;
    }

    RangeObservable.create = function create(start, end, scheduler) {
        if (start === undefined) start = 0;
        if (end === undefined) end = 0;

        return new RangeObservable(start, end, scheduler);
    };

    RangeObservable.dispatch = function dispatch(state) {
        var start = state.start;
        var index = state.index;
        var end = state.end;
        var subscriber = state.subscriber;

        if (index >= end) {
            subscriber.complete();
            return;
        }
        subscriber.next(start);
        if (subscriber.isUnsubscribed) {
            return;
        }
        state.index = index + 1;
        state.start = start + 1;
        this.schedule(state);
    };

    RangeObservable.prototype._subscribe = function _subscribe(subscriber) {
        var index = 0;
        var start = this.start;
        var end = this.end;
        var scheduler = this.scheduler;
        if (scheduler) {
            subscriber.add(scheduler.schedule(RangeObservable.dispatch, 0, {
                index: index, end: end, start: start, subscriber: subscriber
            }));
        } else {
            do {
                if (index++ >= end) {
                    subscriber.complete();
                    break;
                }
                subscriber.next(start++);
                if (subscriber.isUnsubscribed) {
                    break;
                }
            } while (true);
        }
    };

    return RangeObservable;
})(_Observable3['default']);

exports['default'] = RangeObservable;
module.exports = exports['default'];
},{"../Observable":4}],24:[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _Observable2 = require('../Observable');

var _Observable3 = _interopRequireDefault(_Observable2);

var ScalarObservable = (function (_Observable) {
    _inherits(ScalarObservable, _Observable);

    function ScalarObservable(value, scheduler) {
        _classCallCheck(this, ScalarObservable);

        _Observable.call(this);
        this.value = value;
        this.scheduler = scheduler;
        this._isScalar = true;
    }

    ScalarObservable.create = function create(value, scheduler) {
        return new ScalarObservable(value, scheduler);
    };

    ScalarObservable.dispatch = function dispatch(state) {
        var done = state.done;
        var value = state.value;
        var subscriber = state.subscriber;

        if (done) {
            subscriber.complete();
            return;
        }
        subscriber.next(value);
        if (subscriber.isUnsubscribed) {
            return;
        }
        state.done = true;
        this.schedule(state);
    };

    ScalarObservable.prototype._subscribe = function _subscribe(subscriber) {
        var value = this.value;
        var scheduler = this.scheduler;
        if (scheduler) {
            subscriber.add(scheduler.schedule(ScalarObservable.dispatch, 0, {
                done: false, value: value, subscriber: subscriber
            }));
        } else {
            subscriber.next(value);
            if (!subscriber.isUnsubscribed) {
                subscriber.complete();
            }
        }
    };

    return ScalarObservable;
})(_Observable3['default']);

exports['default'] = ScalarObservable;
module.exports = exports['default'];
},{"../Observable":4}],25:[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _Observable2 = require('../Observable');

var _Observable3 = _interopRequireDefault(_Observable2);

var _schedulersNextTick = require('../schedulers/nextTick');

var _schedulersNextTick2 = _interopRequireDefault(_schedulersNextTick);

var SubscribeOnObservable = (function (_Observable) {
    _inherits(SubscribeOnObservable, _Observable);

    function SubscribeOnObservable(source) {
        var delay = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
        var scheduler = arguments.length <= 2 || arguments[2] === undefined ? _schedulersNextTick2['default'] : arguments[2];

        _classCallCheck(this, SubscribeOnObservable);

        _Observable.call(this);
        this.source = source;
        this.delayTime = delay;
        this.scheduler = scheduler;
    }

    SubscribeOnObservable.create = function create(source) {
        var delay = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
        var scheduler = arguments.length <= 2 || arguments[2] === undefined ? _schedulersNextTick2['default'] : arguments[2];

        return new SubscribeOnObservable(source, delay, scheduler);
    };

    SubscribeOnObservable.dispatch = function dispatch(_ref) {
        var source = _ref.source;
        var subscriber = _ref.subscriber;

        return source.subscribe(subscriber);
    };

    SubscribeOnObservable.prototype._subscribe = function _subscribe(subscriber) {
        var delay = this.delayTime;
        var source = this.source;
        var scheduler = this.scheduler;
        subscriber.add(scheduler.schedule(SubscribeOnObservable.dispatch, delay, {
            source: source, subscriber: subscriber
        }));
    };

    return SubscribeOnObservable;
})(_Observable3['default']);

exports['default'] = SubscribeOnObservable;
module.exports = exports['default'];
},{"../Observable":4,"../schedulers/nextTick":115}],26:[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _utilIsNumeric = require('../util/isNumeric');

var _utilIsNumeric2 = _interopRequireDefault(_utilIsNumeric);

var _Observable2 = require('../Observable');

var _Observable3 = _interopRequireDefault(_Observable2);

var _schedulersNextTick = require('../schedulers/nextTick');

var _schedulersNextTick2 = _interopRequireDefault(_schedulersNextTick);

var TimerObservable = (function (_Observable) {
    _inherits(TimerObservable, _Observable);

    function TimerObservable(dueTime, period, scheduler) {
        if (dueTime === undefined) dueTime = 0;

        _classCallCheck(this, TimerObservable);

        _Observable.call(this);
        this.dueTime = dueTime;
        this.period = period;
        this.scheduler = scheduler;
        if (_utilIsNumeric2['default'](period)) {
            this._period = Number(period) < 1 && 1 || Number(period);
        } else if (period && typeof period.schedule === "function") {
            scheduler = period;
        }
        if (!scheduler || typeof scheduler.schedule !== "function") {
            scheduler = _schedulersNextTick2['default'];
        }
        this.scheduler = scheduler;
    }

    TimerObservable.create = function create(dueTime, period, scheduler) {
        if (dueTime === undefined) dueTime = 0;

        return new TimerObservable(dueTime, period, scheduler);
    };

    TimerObservable.dispatch = function dispatch(state) {
        var index = state.index;
        var period = state.period;
        var subscriber = state.subscriber;

        var action = this;
        subscriber.next(index);
        if (typeof period === "undefined") {
            subscriber.complete();
            return;
        } else if (subscriber.isUnsubscribed) {
            return;
        }
        if (typeof action.delay === 'undefined') {
            action.add(action.scheduler.schedule(TimerObservable.dispatch, period, {
                index: index + 1, period: period, subscriber: subscriber
            }));
        } else {
            state.index = index + 1;
            action.schedule(state, period);
        }
    };

    TimerObservable.prototype._subscribe = function _subscribe(subscriber) {
        var index = 0;
        var period = this._period;
        var dueTime = this.dueTime;
        var scheduler = this.scheduler;
        subscriber.add(scheduler.schedule(TimerObservable.dispatch, dueTime, { index: index, period: period, subscriber: subscriber }));
    };

    return TimerObservable;
})(_Observable3['default']);

exports['default'] = TimerObservable;
module.exports = exports['default'];
},{"../Observable":4,"../schedulers/nextTick":115,"../util/isNumeric":130}],27:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = buffer;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _Subscriber3 = require('../Subscriber');

var _Subscriber4 = _interopRequireDefault(_Subscriber3);

/**
 * buffers the incoming observable values until the passed `closingNotifier` emits a value, at which point
 * it emits the buffer on the returned observable and starts a new buffer internally, awaiting the
 * next time `closingNotifier` emits
 *
 * @param {Observable<any>} closingNotifier an observable, that signals the buffer to be emitted from the returned observable
 * @returns {Observable<T[]>} an observable of buffers, which are arrays of values
 */

function buffer(closingNotifier) {
    return this.lift(new BufferOperator(closingNotifier));
}

var BufferOperator = (function () {
    function BufferOperator(closingNotifier) {
        _classCallCheck(this, BufferOperator);

        this.closingNotifier = closingNotifier;
    }

    BufferOperator.prototype.call = function call(subscriber) {
        return new BufferSubscriber(subscriber, this.closingNotifier);
    };

    return BufferOperator;
})();

var BufferSubscriber = (function (_Subscriber) {
    _inherits(BufferSubscriber, _Subscriber);

    function BufferSubscriber(destination, closingNotifier) {
        _classCallCheck(this, BufferSubscriber);

        _Subscriber.call(this, destination);
        this.buffer = [];
        this.add(closingNotifier._subscribe(new BufferClosingNotifierSubscriber(this)));
    }

    BufferSubscriber.prototype._next = function _next(value) {
        this.buffer.push(value);
    };

    BufferSubscriber.prototype._error = function _error(err) {
        this.destination.error(err);
    };

    BufferSubscriber.prototype._complete = function _complete() {
        this.flushBuffer();
        this.destination.complete();
    };

    BufferSubscriber.prototype.flushBuffer = function flushBuffer() {
        var buffer = this.buffer;
        this.buffer = [];
        if (buffer.length > 0) {
            this.destination.next(buffer);
        }
    };

    return BufferSubscriber;
})(_Subscriber4['default']);

var BufferClosingNotifierSubscriber = (function (_Subscriber2) {
    _inherits(BufferClosingNotifierSubscriber, _Subscriber2);

    function BufferClosingNotifierSubscriber(parent) {
        _classCallCheck(this, BufferClosingNotifierSubscriber);

        _Subscriber2.call(this, null);
        this.parent = parent;
    }

    BufferClosingNotifierSubscriber.prototype._next = function _next(value) {
        this.parent.flushBuffer();
    };

    BufferClosingNotifierSubscriber.prototype._error = function _error(err) {
        this.parent.error(err);
    };

    BufferClosingNotifierSubscriber.prototype._complete = function _complete() {
        // noop
    };

    return BufferClosingNotifierSubscriber;
})(_Subscriber4['default']);

module.exports = exports['default'];
},{"../Subscriber":8}],28:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = bufferCount;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _Subscriber2 = require('../Subscriber');

var _Subscriber3 = _interopRequireDefault(_Subscriber2);

function bufferCount(bufferSize) {
    var startBufferEvery = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

    return this.lift(new BufferCountOperator(bufferSize, startBufferEvery));
}

var BufferCountOperator = (function () {
    function BufferCountOperator(bufferSize, startBufferEvery) {
        _classCallCheck(this, BufferCountOperator);

        this.bufferSize = bufferSize;
        this.startBufferEvery = startBufferEvery;
    }

    BufferCountOperator.prototype.call = function call(subscriber) {
        return new BufferCountSubscriber(subscriber, this.bufferSize, this.startBufferEvery);
    };

    return BufferCountOperator;
})();

var BufferCountSubscriber = (function (_Subscriber) {
    _inherits(BufferCountSubscriber, _Subscriber);

    function BufferCountSubscriber(destination, bufferSize, startBufferEvery) {
        _classCallCheck(this, BufferCountSubscriber);

        _Subscriber.call(this, destination);
        this.bufferSize = bufferSize;
        this.startBufferEvery = startBufferEvery;
        this.buffers = [[]];
        this.count = 0;
    }

    BufferCountSubscriber.prototype._next = function _next(value) {
        var count = this.count += 1;
        var destination = this.destination;
        var bufferSize = this.bufferSize;
        var startBufferEvery = this.startBufferEvery == null ? bufferSize : this.startBufferEvery;
        var buffers = this.buffers;
        var len = buffers.length;
        var remove = -1;
        if (count % startBufferEvery === 0) {
            buffers.push([]);
        }
        for (var i = 0; i < len; i++) {
            var buffer = buffers[i];
            buffer.push(value);
            if (buffer.length === bufferSize) {
                remove = i;
                this.destination.next(buffer);
            }
        }
        if (remove !== -1) {
            buffers.splice(remove, 1);
        }
    };

    BufferCountSubscriber.prototype._error = function _error(err) {
        this.destination.error(err);
    };

    BufferCountSubscriber.prototype._complete = function _complete() {
        var destination = this.destination;
        var buffers = this.buffers;
        while (buffers.length > 0) {
            var buffer = buffers.shift();
            if (buffer.length > 0) {
                destination.next(buffer);
            }
        }
        destination.complete();
    };

    return BufferCountSubscriber;
})(_Subscriber3['default']);

module.exports = exports['default'];
},{"../Subscriber":8}],29:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = bufferTime;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _Subscriber2 = require('../Subscriber');

var _Subscriber3 = _interopRequireDefault(_Subscriber2);

var _schedulersNextTick = require('../schedulers/nextTick');

var _schedulersNextTick2 = _interopRequireDefault(_schedulersNextTick);

function bufferTime(bufferTimeSpan) {
    var bufferCreationInterval = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
    var scheduler = arguments.length <= 2 || arguments[2] === undefined ? _schedulersNextTick2['default'] : arguments[2];

    return this.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, scheduler));
}

var BufferTimeOperator = (function () {
    function BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, scheduler) {
        _classCallCheck(this, BufferTimeOperator);

        this.bufferTimeSpan = bufferTimeSpan;
        this.bufferCreationInterval = bufferCreationInterval;
        this.scheduler = scheduler;
    }

    BufferTimeOperator.prototype.call = function call(subscriber) {
        return new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.scheduler);
    };

    return BufferTimeOperator;
})();

var BufferTimeSubscriber = (function (_Subscriber) {
    _inherits(BufferTimeSubscriber, _Subscriber);

    function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, scheduler) {
        _classCallCheck(this, BufferTimeSubscriber);

        _Subscriber.call(this, destination);
        this.bufferTimeSpan = bufferTimeSpan;
        this.bufferCreationInterval = bufferCreationInterval;
        this.scheduler = scheduler;
        this.buffers = [];
        var buffer = this.openBuffer();
        if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {
            this.add(scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber: this, buffer: buffer }));
            this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, { bufferTimeSpan: bufferTimeSpan, bufferCreationInterval: bufferCreationInterval, subscriber: this, scheduler: scheduler }));
        } else {
            this.add(scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, { subscriber: this, buffer: buffer, bufferTimeSpan: bufferTimeSpan }));
        }
    }

    BufferTimeSubscriber.prototype._next = function _next(value) {
        var buffers = this.buffers;
        var len = buffers.length;
        for (var i = 0; i < len; i++) {
            buffers[i].push(value);
        }
    };

    BufferTimeSubscriber.prototype._error = function _error(err) {
        this.buffers.length = 0;
        this.destination.error(err);
    };

    BufferTimeSubscriber.prototype._complete = function _complete() {
        var buffers = this.buffers;
        while (buffers.length > 0) {
            this.destination.next(buffers.shift());
        }
        this.destination.complete();
    };

    BufferTimeSubscriber.prototype.openBuffer = function openBuffer() {
        var buffer = [];
        this.buffers.push(buffer);
        return buffer;
    };

    BufferTimeSubscriber.prototype.closeBuffer = function closeBuffer(buffer) {
        this.destination.next(buffer);
        var buffers = this.buffers;
        buffers.splice(buffers.indexOf(buffer), 1);
    };

    return BufferTimeSubscriber;
})(_Subscriber3['default']);

function dispatchBufferTimeSpanOnly(state) {
    var subscriber = state.subscriber;
    var prevBuffer = state.buffer;
    if (prevBuffer) {
        subscriber.closeBuffer(prevBuffer);
    }
    state.buffer = subscriber.openBuffer();
    if (!subscriber.isUnsubscribed) {
        this.schedule(state, state.bufferTimeSpan);
    }
}
function dispatchBufferCreation(state) {
    var bufferCreationInterval = state.bufferCreationInterval;
    var bufferTimeSpan = state.bufferTimeSpan;
    var subscriber = state.subscriber;
    var scheduler = state.scheduler;

    var buffer = subscriber.openBuffer();
    var action = this;
    if (!subscriber.isUnsubscribed) {
        action.add(scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber: subscriber, buffer: buffer }));
        action.schedule(state, bufferCreationInterval);
    }
}
function dispatchBufferClose(_ref) {
    var subscriber = _ref.subscriber;
    var buffer = _ref.buffer;

    subscriber.closeBuffer(buffer);
}
module.exports = exports['default'];
},{"../Subscriber":8,"../schedulers/nextTick":115}],30:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = bufferToggle;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _Subscriber4 = require('../Subscriber');

var _Subscriber5 = _interopRequireDefault(_Subscriber4);

var _Subscription = require('../Subscription');

var _Subscription2 = _interopRequireDefault(_Subscription);

var _utilTryCatch = require('../util/tryCatch');

var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

var _utilErrorObject = require('../util/errorObject');

function bufferToggle(openings, closingSelector) {
    return this.lift(new BufferToggleOperator(openings, closingSelector));
}

var BufferToggleOperator = (function () {
    function BufferToggleOperator(openings, closingSelector) {
        _classCallCheck(this, BufferToggleOperator);

        this.openings = openings;
        this.closingSelector = closingSelector;
    }

    BufferToggleOperator.prototype.call = function call(subscriber) {
        return new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector);
    };

    return BufferToggleOperator;
})();

var BufferToggleSubscriber = (function (_Subscriber) {
    _inherits(BufferToggleSubscriber, _Subscriber);

    function BufferToggleSubscriber(destination, openings, closingSelector) {
        _classCallCheck(this, BufferToggleSubscriber);

        _Subscriber.call(this, destination);
        this.openings = openings;
        this.closingSelector = closingSelector;
        this.buffers = [];
        this.add(this.openings._subscribe(new BufferToggleOpeningsSubscriber(this)));
    }

    BufferToggleSubscriber.prototype._next = function _next(value) {
        var buffers = this.buffers;
        var len = buffers.length;
        for (var i = 0; i < len; i++) {
            buffers[i].push(value);
        }
    };

    BufferToggleSubscriber.prototype._error = function _error(err) {
        this.buffers = null;
        this.destination.error(err);
    };

    BufferToggleSubscriber.prototype._complete = function _complete() {
        var buffers = this.buffers;
        while (buffers.length > 0) {
            this.destination.next(buffers.shift());
        }
        this.destination.complete();
    };

    BufferToggleSubscriber.prototype.openBuffer = function openBuffer(value) {
        var closingSelector = this.closingSelector;
        var buffers = this.buffers;
        var closingNotifier = _utilTryCatch2['default'](closingSelector)(value);
        if (closingNotifier === _utilErrorObject.errorObject) {
            var err = closingNotifier.e;
            this.buffers = null;
            this.destination.error(err);
        } else {
            var buffer = [];
            var context = {
                buffer: buffer,
                subscription: new _Subscription2['default']()
            };
            buffers.push(buffer);
            this.add(context.subscription.add(closingNotifier._subscribe(new BufferClosingNotifierSubscriber(this, context))));
        }
    };

    BufferToggleSubscriber.prototype.closeBuffer = function closeBuffer(context) {
        var buffer = context.buffer;
        var subscription = context.subscription;

        var buffers = this.buffers;
        this.destination.next(buffer);
        buffers.splice(buffers.indexOf(buffer), 1);
        this.remove(subscription);
        subscription.unsubscribe();
    };

    return BufferToggleSubscriber;
})(_Subscriber5['default']);

var BufferClosingNotifierSubscriber = (function (_Subscriber2) {
    _inherits(BufferClosingNotifierSubscriber, _Subscriber2);

    function BufferClosingNotifierSubscriber(parent, context) {
        _classCallCheck(this, BufferClosingNotifierSubscriber);

        _Subscriber2.call(this, null);
        this.parent = parent;
        this.context = context;
    }

    BufferClosingNotifierSubscriber.prototype._next = function _next() {
        this.parent.closeBuffer(this.context);
    };

    BufferClosingNotifierSubscriber.prototype._error = function _error(err) {
        this.parent.error(err);
    };

    BufferClosingNotifierSubscriber.prototype._complete = function _complete() {
        // noop
    };

    return BufferClosingNotifierSubscriber;
})(_Subscriber5['default']);

var BufferToggleOpeningsSubscriber = (function (_Subscriber3) {
    _inherits(BufferToggleOpeningsSubscriber, _Subscriber3);

    function BufferToggleOpeningsSubscriber(parent) {
        _classCallCheck(this, BufferToggleOpeningsSubscriber);

        _Subscriber3.call(this, null);
        this.parent = parent;
    }

    BufferToggleOpeningsSubscriber.prototype._next = function _next(value) {
        this.parent.openBuffer(value);
    };

    BufferToggleOpeningsSubscriber.prototype._error = function _error(err) {
        this.parent.error(err);
    };

    BufferToggleOpeningsSubscriber.prototype._complete = function _complete() {
        // noop
    };

    return BufferToggleOpeningsSubscriber;
})(_Subscriber5['default']);

module.exports = exports['default'];
},{"../Subscriber":8,"../Subscription":9,"../util/errorObject":128,"../util/tryCatch":136}],31:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = bufferWhen;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _Subscriber3 = require('../Subscriber');

var _Subscriber4 = _interopRequireDefault(_Subscriber3);

var _utilTryCatch = require('../util/tryCatch');

var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

var _utilErrorObject = require('../util/errorObject');

function bufferWhen(closingSelector) {
    return this.lift(new BufferWhenOperator(closingSelector));
}

var BufferWhenOperator = (function () {
    function BufferWhenOperator(closingSelector) {
        _classCallCheck(this, BufferWhenOperator);

        this.closingSelector = closingSelector;
    }

    BufferWhenOperator.prototype.call = function call(subscriber) {
        return new BufferWhenSubscriber(subscriber, this.closingSelector);
    };

    return BufferWhenOperator;
})();

var BufferWhenSubscriber = (function (_Subscriber) {
    _inherits(BufferWhenSubscriber, _Subscriber);

    function BufferWhenSubscriber(destination, closingSelector) {
        _classCallCheck(this, BufferWhenSubscriber);

        _Subscriber.call(this, destination);
        this.closingSelector = closingSelector;
        this.openBuffer();
    }

    BufferWhenSubscriber.prototype._next = function _next(value) {
        this.buffer.push(value);
    };

    BufferWhenSubscriber.prototype._error = function _error(err) {
        this.buffer = null;
        this.destination.error(err);
    };

    BufferWhenSubscriber.prototype._complete = function _complete() {
        var buffer = this.buffer;
        this.destination.next(buffer);
        this.buffer = null;
        this.destination.complete();
    };

    BufferWhenSubscriber.prototype.openBuffer = function openBuffer() {
        var prevClosingNotification = this.closingNotification;
        if (prevClosingNotification) {
            this.remove(prevClosingNotification);
            prevClosingNotification.unsubscribe();
        }
        var buffer = this.buffer;
        if (buffer) {
            this.destination.next(buffer);
        }
        this.buffer = [];
        var closingNotifier = _utilTryCatch2['default'](this.closingSelector)();
        if (closingNotifier === _utilErrorObject.errorObject) {
            var err = closingNotifier.e;
            this.buffer = null;
            this.destination.error(err);
        } else {
            this.add(this.closingNotification = closingNotifier._subscribe(new BufferClosingNotifierSubscriber(this)));
        }
    };

    return BufferWhenSubscriber;
})(_Subscriber4['default']);

var BufferClosingNotifierSubscriber = (function (_Subscriber2) {
    _inherits(BufferClosingNotifierSubscriber, _Subscriber2);

    function BufferClosingNotifierSubscriber(parent) {
        _classCallCheck(this, BufferClosingNotifierSubscriber);

        _Subscriber2.call(this, null);
        this.parent = parent;
    }

    BufferClosingNotifierSubscriber.prototype._next = function _next() {
        this.parent.openBuffer();
    };

    BufferClosingNotifierSubscriber.prototype._error = function _error(err) {
        this.parent.error(err);
    };

    BufferClosingNotifierSubscriber.prototype._complete = function _complete() {
        // noop
    };

    return BufferClosingNotifierSubscriber;
})(_Subscriber4['default']);

module.exports = exports['default'];
},{"../Subscriber":8,"../util/errorObject":128,"../util/tryCatch":136}],32:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = _catch;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _Subscriber2 = require('../Subscriber');

var _Subscriber3 = _interopRequireDefault(_Subscriber2);

var _utilTryCatch = require('../util/tryCatch');

var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

var _utilErrorObject = require('../util/errorObject');

function _catch(selector) {
    var catchOperator = new CatchOperator(selector);
    var caught = this.lift(catchOperator);
    catchOperator.caught = caught;
    return caught;
}

var CatchOperator = (function () {
    function CatchOperator(selector) {
        _classCallCheck(this, CatchOperator);

        this.selector = selector;
    }

    CatchOperator.prototype.call = function call(subscriber) {
        return new CatchSubscriber(subscriber, this.selector, this.caught);
    };

    return CatchOperator;
})();

var CatchSubscriber = (function (_Subscriber) {
    _inherits(CatchSubscriber, _Subscriber);

    function CatchSubscriber(destination, selector, caught) {
        _classCallCheck(this, CatchSubscriber);

        _Subscriber.call(this, destination);
        this.selector = selector;
        this.caught = caught;
    }

    CatchSubscriber.prototype._error = function _error(err) {
        var result = _utilTryCatch2['default'](this.selector)(err, this.caught);
        if (result === _utilErrorObject.errorObject) {
            this.destination.error(_utilErrorObject.errorObject.e);
        } else {
            this.add(result.subscribe(this.destination));
        }
    };

    return CatchSubscriber;
})(_Subscriber3['default']);

module.exports = exports['default'];
},{"../Subscriber":8,"../util/errorObject":128,"../util/tryCatch":136}],33:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = combineAll;

var _combineLatestSupport = require('./combineLatest-support');

function combineAll(project) {
    return this.lift(new _combineLatestSupport.CombineLatestOperator(project));
}

module.exports = exports['default'];
},{"./combineLatest-support":35}],34:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = combineLatest;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _observablesArrayObservable = require('../observables/ArrayObservable');

var _observablesArrayObservable2 = _interopRequireDefault(_observablesArrayObservable);

var _combineLatestSupport = require('./combineLatest-support');

function combineLatest() {
    var project = undefined,
        scheduler = undefined;

    for (var _len = arguments.length, observables = Array(_len), _key = 0; _key < _len; _key++) {
        observables[_key] = arguments[_key];
    }

    if (typeof observables[observables.length - 1].schedule === 'function') {
        scheduler = observables.pop();
    }
    if (typeof observables[observables.length - 1] === 'function') {
        project = observables.pop();
    }
    return new _observablesArrayObservable2['default'](observables, scheduler).lift(new _combineLatestSupport.CombineLatestOperator(project));
}

module.exports = exports['default'];
},{"../observables/ArrayObservable":10,"./combineLatest-support":35}],35:[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _utilTryCatch = require('../util/tryCatch');

var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

var _utilErrorObject = require('../util/errorObject');

var _OuterSubscriber2 = require('../OuterSubscriber');

var _OuterSubscriber3 = _interopRequireDefault(_OuterSubscriber2);

var _utilSubscribeToResult = require('../util/subscribeToResult');

var _utilSubscribeToResult2 = _interopRequireDefault(_utilSubscribeToResult);

var CombineLatestOperator = (function () {
    function CombineLatestOperator(project) {
        _classCallCheck(this, CombineLatestOperator);

        this.project = project;
    }

    CombineLatestOperator.prototype.call = function call(subscriber) {
        return new CombineLatestSubscriber(subscriber, this.project);
    };

    return CombineLatestOperator;
})();

exports.CombineLatestOperator = CombineLatestOperator;

var CombineLatestSubscriber = (function (_OuterSubscriber) {
    _inherits(CombineLatestSubscriber, _OuterSubscriber);

    function CombineLatestSubscriber(destination, project) {
        _classCallCheck(this, CombineLatestSubscriber);

        _OuterSubscriber.call(this, destination);
        this.project = project;
        this.active = 0;
        this.values = [];
        this.observables = [];
        this.toRespond = [];
    }

    CombineLatestSubscriber.prototype._next = function _next(observable) {
        var toRespond = this.toRespond;
        toRespond.push(toRespond.length);
        this.observables.push(observable);
    };

    CombineLatestSubscriber.prototype._complete = function _complete() {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
            this.destination.complete();
        } else {
            this.active = len;
            for (var i = 0; i < len; i++) {
                var observable = observables[i];
                this.add(_utilSubscribeToResult2['default'](this, observable, observable, i));
            }
        }
    };

    CombineLatestSubscriber.prototype.notifyComplete = function notifyComplete(innerSubscriber) {
        if ((this.active -= 1) === 0) {
            this.destination.complete();
        }
    };

    CombineLatestSubscriber.prototype.notifyNext = function notifyNext(value, observable, innerIndex, outerIndex) {
        var values = this.values;
        values[outerIndex] = value;
        var toRespond = this.toRespond;
        if (toRespond.length > 0) {
            var found = toRespond.indexOf(outerIndex);
            if (found !== -1) {
                toRespond.splice(found, 1);
            }
        }
        if (toRespond.length === 0) {
            var project = this.project;
            var destination = this.destination;
            if (project) {
                var result = _utilTryCatch2['default'](project).apply(this, values);
                if (result === _utilErrorObject.errorObject) {
                    destination.error(_utilErrorObject.errorObject.e);
                } else {
                    destination.next(result);
                }
            } else {
                destination.next(values);
            }
        }
    };

    return CombineLatestSubscriber;
})(_OuterSubscriber3['default']);

exports.CombineLatestSubscriber = CombineLatestSubscriber;
},{"../OuterSubscriber":5,"../util/errorObject":128,"../util/subscribeToResult":134,"../util/tryCatch":136}],36:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = combineLatest;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _observablesArrayObservable = require('../observables/ArrayObservable');

var _observablesArrayObservable2 = _interopRequireDefault(_observablesArrayObservable);

var _combineLatestSupport = require('./combineLatest-support');

function combineLatest() {
    for (var _len = arguments.length, observables = Array(_len), _key = 0; _key < _len; _key++) {
        observables[_key] = arguments[_key];
    }

    observables.unshift(this);
    var project = undefined;
    if (typeof observables[observables.length - 1] === "function") {
        project = observables.pop();
    }
    return new _observablesArrayObservable2['default'](observables).lift(new _combineLatestSupport.CombineLatestOperator(project));
}

module.exports = exports['default'];
},{"../observables/ArrayObservable":10,"./combineLatest-support":35}],37:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = concat;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _mergeStatic = require('./merge-static');

var _mergeStatic2 = _interopRequireDefault(_mergeStatic);

var _schedulersImmediate = require('../schedulers/immediate');

var _schedulersImmediate2 = _interopRequireDefault(_schedulersImmediate);

function concat() {
    var scheduler = _schedulersImmediate2['default'];

    for (var _len = arguments.length, observables = Array(_len), _key = 0; _key < _len; _key++) {
        observables[_key] = arguments[_key];
    }

    var args = observables;
    var len = args.length;
    if (typeof args[observables.length - 1].schedule === 'function') {
        scheduler = args.pop();
        args.push(1, scheduler);
    }
    return _mergeStatic2['default'].apply(this, observables);
}

module.exports = exports['default'];
},{"../schedulers/immediate":114,"./merge-static":60}],38:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = concatProto;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _mergeStatic = require('./merge-static');

var _mergeStatic2 = _interopRequireDefault(_mergeStatic);

function concatProto() {
    for (var _len = arguments.length, observables = Array(_len), _key = 0; _key < _len; _key++) {
        observables[_key] = arguments[_key];
    }

    var args = observables;
    args.unshift(this);
    if (args.length > 1 && typeof args[args.length - 1].schedule === 'function') {
        args.splice(args.length - 2, 0, 1);
    }
    return _mergeStatic2['default'].apply(this, args);
}

module.exports = exports['default'];
},{"./merge-static":60}],39:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = concatAll;

var _mergeAllSupport = require('./mergeAll-support');

function concatAll() {
    return this.lift(new _mergeAllSupport.MergeAllOperator(1));
}

module.exports = exports['default'];
},{"./mergeAll-support":62}],40:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = concatMap;

var _mergeMapSupport = require('./mergeMap-support');

function concatMap(project, projectResult) {
    return this.lift(new _mergeMapSupport.MergeMapOperator(project, projectResult, 1));
}

module.exports = exports['default'];
},{"./mergeMap-support":64}],41:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = concatMapTo;

var _mergeMapToSupport = require('./mergeMapTo-support');

function concatMapTo(observable, projectResult) {
    return this.lift(new _mergeMapToSupport.MergeMapToOperator(observable, projectResult, 1));
}

module.exports = exports['default'];
},{"./mergeMapTo-support":66}],42:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = count;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _Subscriber2 = require('../Subscriber');

var _Subscriber3 = _interopRequireDefault(_Subscriber2);

function count() {
    return this.lift(new CountOperator());
}

var CountOperator = (function () {
    function CountOperator() {
        _classCallCheck(this, CountOperator);
    }

    CountOperator.prototype.call = function call(subscriber) {
        return new CountSubscriber(subscriber);
    };

    return CountOperator;
})();

var CountSubscriber = (function (_Subscriber) {
    _inherits(CountSubscriber, _Subscriber);

    function CountSubscriber(destination) {
        _classCallCheck(this, CountSubscriber);

        _Subscriber.call(this, destination);
        this.count = 0;
    }

    CountSubscriber.prototype._next = function _next(x) {
        this.count += 1;
    };

    CountSubscriber.prototype._complete = function _complete() {
        this.destination.next(this.count);
        this.destination.complete();
    };

    return CountSubscriber;
})(_Subscriber3['default']);

module.exports = exports['default'];
},{"../Subscriber":8}],43:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = debounce;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _Subscriber2 = require('../Subscriber');

var _Subscriber3 = _interopRequireDefault(_Subscriber2);

var _schedulersNextTick = require('../schedulers/nextTick');

var _schedulersNextTick2 = _interopRequireDefault(_schedulersNextTick);

function debounce(dueTime) {
    var scheduler = arguments.length <= 1 || arguments[1] === undefined ? _schedulersNextTick2['default'] : arguments[1];

    return this.lift(new DebounceOperator(dueTime, scheduler));
}

var DebounceOperator = (function () {
    function DebounceOperator(dueTime, scheduler) {
        _classCallCheck(this, DebounceOperator);

        this.dueTime = dueTime;
        this.scheduler = scheduler;
    }

    DebounceOperator.prototype.call = function call(subscriber) {
        return new DebounceSubscriber(subscriber, this.dueTime, this.scheduler);
    };

    return DebounceOperator;
})();

var DebounceSubscriber = (function (_Subscriber) {
    _inherits(DebounceSubscriber, _Subscriber);

    function DebounceSubscriber(destination, dueTime, scheduler) {
        _classCallCheck(this, DebounceSubscriber);

        _Subscriber.call(this, destination);
        this.dueTime = dueTime;
        this.scheduler = scheduler;
    }

    DebounceSubscriber.prototype._next = function _next(value) {
        if (!this.debounced) {
            this.add(this.debounced = this.scheduler.schedule(dispatchNext, this.dueTime, { value: value, subscriber: this }));
        }
    };

    DebounceSubscriber.prototype.clearDebounce = function clearDebounce() {
        var debounced = this.debounced;
        if (debounced) {
            debounced.unsubscribe();
            this.remove(debounced);
        }
    };

    DebounceSubscriber.prototype.debouncedNext = function debouncedNext(value) {
        this.clearDebounce();
        this.destination.next(value);
    };

    return DebounceSubscriber;
})(_Subscriber3['default']);

function dispatchNext(_ref) {
    var value = _ref.value;
    var subscriber = _ref.subscriber;

    subscriber.debouncedNext(value);
}
module.exports = exports['default'];
},{"../Subscriber":8,"../schedulers/nextTick":115}],44:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = defaultIfEmpty;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _Subscriber2 = require('../Subscriber');

var _Subscriber3 = _interopRequireDefault(_Subscriber2);

function defaultIfEmpty() {
    var defaultValue = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

    return this.lift(new DefaultIfEmptyOperator(defaultValue));
}

var DefaultIfEmptyOperator = (function () {
    function DefaultIfEmptyOperator(defaultValue) {
        _classCallCheck(this, DefaultIfEmptyOperator);

        this.defaultValue = defaultValue;
    }

    DefaultIfEmptyOperator.prototype.call = function call(subscriber) {
        return new DefaultIfEmptySubscriber(subscriber, this.defaultValue);
    };

    return DefaultIfEmptyOperator;
})();

var DefaultIfEmptySubscriber = (function (_Subscriber) {
    _inherits(DefaultIfEmptySubscriber, _Subscriber);

    function DefaultIfEmptySubscriber(destination, defaultValue) {
        _classCallCheck(this, DefaultIfEmptySubscriber);

        _Subscriber.call(this, destination);
        this.defaultValue = defaultValue;
        this.isEmpty = true;
    }

    DefaultIfEmptySubscriber.prototype._next = function _next(x) {
        this.isEmpty = false;
        this.destination.next(x);
    };

    DefaultIfEmptySubscriber.prototype._complete = function _complete() {
        if (this.isEmpty) {
            this.destination.next(this.defaultValue);
        }
        this.destination.complete();
    };

    return DefaultIfEmptySubscriber;
})(_Subscriber3['default']);

module.exports = exports['default'];
},{"../Subscriber":8}],45:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = delay;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _Subscriber2 = require('../Subscriber');

var _Subscriber3 = _interopRequireDefault(_Subscriber2);

var _Notification = require('../Notification');

var _Notification2 = _interopRequireDefault(_Notification);

var _schedulersImmediate = require('../schedulers/immediate');

var _schedulersImmediate2 = _interopRequireDefault(_schedulersImmediate);

function delay(delay) {
    var scheduler = arguments.length <= 1 || arguments[1] === undefined ? _schedulersImmediate2['default'] : arguments[1];

    return this.lift(new DelayOperator(delay, scheduler));
}

var DelayOperator = (function () {
    function DelayOperator(delay, scheduler) {
        _classCallCheck(this, DelayOperator);

        this.delay = delay;
        this.scheduler = scheduler;
    }

    DelayOperator.prototype.call = function call(subscriber) {
        return new DelaySubscriber(subscriber, this.delay, this.scheduler);
    };

    return DelayOperator;
})();

var DelaySubscriber = (function (_Subscriber) {
    _inherits(DelaySubscriber, _Subscriber);

    function DelaySubscriber(destination, delay, scheduler) {
        _classCallCheck(this, DelaySubscriber);

        _Subscriber.call(this, destination);
        this.queue = [];
        this.active = false;
        this.errored = false;
        this.delay = delay;
        this.scheduler = scheduler;
    }

    DelaySubscriber.dispatch = function dispatch(state) {
        var source = state.source;
        var queue = source.queue;
        var scheduler = state.scheduler;
        var destination = state.destination;
        while (queue.length > 0 && queue[0].time - scheduler.now() <= 0) {
            queue.shift().notification.observe(destination);
        }
        if (queue.length > 0) {
            var _delay = Math.max(0, queue[0].time - scheduler.now());
            this.schedule(state, _delay);
        } else {
            source.active = false;
        }
    };

    DelaySubscriber.prototype._next = function _next(x) {
        if (this.errored) {
            return;
        }
        var scheduler = this.scheduler;
        this.queue.push(new DelayMessage(scheduler.now() + this.delay, _Notification2['default'].createNext(x)));
        if (this.active === false) {
            this._schedule(scheduler);
        }
    };

    DelaySubscriber.prototype._error = function _error(e) {
        var scheduler = this.scheduler;
        this.errored = true;
        this.queue = [new DelayMessage(scheduler.now() + this.delay, _Notification2['default'].createError(e))];
        if (this.active === false) {
            this._schedule(scheduler);
        }
    };

    DelaySubscriber.prototype._complete = function _complete() {
        if (this.errored) {
            return;
        }
        var scheduler = this.scheduler;
        this.queue.push(new DelayMessage(scheduler.now() + this.delay, _Notification2['default'].createComplete()));
        if (this.active === false) {
            this._schedule(scheduler);
        }
    };

    DelaySubscriber.prototype._schedule = function _schedule(scheduler) {
        this.active = true;
        this.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {
            source: this, destination: this.destination, scheduler: scheduler
        }));
    };

    return DelaySubscriber;
})(_Subscriber3['default']);

var DelayMessage = function DelayMessage(time, notification) {
    _classCallCheck(this, DelayMessage);

    this.time = time;
    this.notification = notification;
};

module.exports = exports['default'];
},{"../Notification":3,"../Subscriber":8,"../schedulers/immediate":114}],46:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = distinctUntilChanged;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _Subscriber2 = require('../Subscriber');

var _Subscriber3 = _interopRequireDefault(_Subscriber2);

var _utilTryCatch = require('../util/tryCatch');

var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

var _utilErrorObject = require('../util/errorObject');

var _utilBindCallback = require('../util/bindCallback');

var _utilBindCallback2 = _interopRequireDefault(_utilBindCallback);

function distinctUntilChanged(compare, thisArg) {
    return this.lift(new DistinctUntilChangedOperator(thisArg ? _utilBindCallback2['default'](compare, thisArg, 2) : compare));
}

var DistinctUntilChangedOperator = (function () {
    function DistinctUntilChangedOperator(compare) {
        _classCallCheck(this, DistinctUntilChangedOperator);

        this.compare = compare;
    }

    DistinctUntilChangedOperator.prototype.call = function call(subscriber) {
        return new DistinctUntilChangedSubscriber(subscriber, this.compare);
    };

    return DistinctUntilChangedOperator;
})();

var DistinctUntilChangedSubscriber = (function (_Subscriber) {
    _inherits(DistinctUntilChangedSubscriber, _Subscriber);

    function DistinctUntilChangedSubscriber(destination, compare) {
        _classCallCheck(this, DistinctUntilChangedSubscriber);

        _Subscriber.call(this, destination);
        this.hasValue = false;
        if (typeof compare === "function") {
            this.compare = compare;
        }
    }

    DistinctUntilChangedSubscriber.prototype.compare = function compare(x, y) {
        return x === y;
    };

    DistinctUntilChangedSubscriber.prototype._next = function _next(x) {
        var result = false;
        if (this.hasValue) {
            result = _utilTryCatch2['default'](this.compare)(this.value, x);
            if (result === _utilErrorObject.errorObject) {
                this.destination.error(_utilErrorObject.errorObject.e);
                return;
            }
        } else {
            this.hasValue = true;
        }
        if (Boolean(result) === false) {
            this.value = x;
            this.destination.next(x);
        }
    };

    return DistinctUntilChangedSubscriber;
})(_Subscriber3['default']);

module.exports = exports['default'];
},{"../Subscriber":8,"../util/bindCallback":127,"../util/errorObject":128,"../util/tryCatch":136}],47:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = distinctUntilKeyChanged;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _distinctUntilChanged = require('./distinctUntilChanged');

var _distinctUntilChanged2 = _interopRequireDefault(_distinctUntilChanged);

function distinctUntilKeyChanged(key, compare, thisArg) {
    return _distinctUntilChanged2['default'].call(this, function (x, y) {
        if (compare) {
            return compare.call(thisArg, x[key], y[key]);
        }
        return x[key] === y[key];
    });
}

module.exports = exports['default'];
},{"./distinctUntilChanged":46}],48:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = _do;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _Subscriber2 = require('../Subscriber');

var _Subscriber3 = _interopRequireDefault(_Subscriber2);

var _utilNoop = require('../util/noop');

var _utilNoop2 = _interopRequireDefault(_utilNoop);

var _utilTryCatch = require('../util/tryCatch');

var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

var _utilErrorObject = require('../util/errorObject');

function _do(next, error, complete) {
    return this.lift(new DoOperator(next || _utilNoop2['default'], error || _utilNoop2['default'], complete || _utilNoop2['default']));
}

var DoOperator = (function () {
    function DoOperator(next, error, complete) {
        _classCallCheck(this, DoOperator);

        this.next = next;
        this.error = error;
        this.complete = complete;
    }

    DoOperator.prototype.call = function call(subscriber) {
        return new DoSubscriber(subscriber, this.next, this.error, this.complete);
    };

    return DoOperator;
})();

var DoSubscriber = (function (_Subscriber) {
    _inherits(DoSubscriber, _Subscriber);

    function DoSubscriber(destination, next, error, complete) {
        _classCallCheck(this, DoSubscriber);

        _Subscriber.call(this, destination);
        this.__next = next;
        this.__error = error;
        this.__complete = complete;
    }

    DoSubscriber.prototype._next = function _next(x) {
        var result = _utilTryCatch2['default'](this.__next)(x);
        if (result === _utilErrorObject.errorObject) {
            this.destination.error(_utilErrorObject.errorObject.e);
        } else {
            this.destination.next(x);
        }
    };

    DoSubscriber.prototype._error = function _error(e) {
        var result = _utilTryCatch2['default'](this.__error)(e);
        if (result === _utilErrorObject.errorObject) {
            this.destination.error(_utilErrorObject.errorObject.e);
        } else {
            this.destination.error(e);
        }
    };

    DoSubscriber.prototype._complete = function _complete() {
        var result = _utilTryCatch2['default'](this.__complete)();
        if (result === _utilErrorObject.errorObject) {
            this.destination.error(_utilErrorObject.errorObject.e);
        } else {
            this.destination.complete();
        }
    };

    return DoSubscriber;
})(_Subscriber3['default']);

module.exports = exports['default'];
},{"../Subscriber":8,"../util/errorObject":128,"../util/noop":131,"../util/tryCatch":136}],49:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = elementAt;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _Subscriber2 = require('../Subscriber');

var _Subscriber3 = _interopRequireDefault(_Subscriber2);

var _utilArgumentOutOfRangeError = require('../util/ArgumentOutOfRangeError');

var _utilArgumentOutOfRangeError2 = _interopRequireDefault(_utilArgumentOutOfRangeError);

function elementAt(index, defaultValue) {
    return this.lift(new ElementAtOperator(index, defaultValue));
}

var ElementAtOperator = (function () {
    function ElementAtOperator(index, defaultValue) {
        _classCallCheck(this, ElementAtOperator);

        this.index = index;
        this.defaultValue = defaultValue;
        if (index < 0) {
            throw new _utilArgumentOutOfRangeError2['default']();
        }
    }

    ElementAtOperator.prototype.call = function call(subscriber) {
        return new ElementAtSubscriber(subscriber, this.index, this.defaultValue);
    };

    return ElementAtOperator;
})();

var ElementAtSubscriber = (function (_Subscriber) {
    _inherits(ElementAtSubscriber, _Subscriber);

    function ElementAtSubscriber(destination, index, defaultValue) {
        _classCallCheck(this, ElementAtSubscriber);

        _Subscriber.call(this, destination);
        this.index = index;
        this.defaultValue = defaultValue;
    }

    ElementAtSubscriber.prototype._next = function _next(x) {
        if (this.index-- === 0) {
            this.destination.next(x);
            this.destination.complete();
        }
    };

    ElementAtSubscriber.prototype._complete = function _complete() {
        var destination = this.destination;
        if (this.index >= 0) {
            if (typeof this.defaultValue !== 'undefined') {
                destination.next(this.defaultValue);
            } else {
                destination.error(new _utilArgumentOutOfRangeError2['default']());
            }
        }
        destination.complete();
    };

    return ElementAtSubscriber;
})(_Subscriber3['default']);

module.exports = exports['default'];
},{"../Subscriber":8,"../util/ArgumentOutOfRangeError":120}],50:[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _utilTryCatch = require('../util/tryCatch');

var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

var _utilErrorObject = require('../util/errorObject');

var _OuterSubscriber2 = require('../OuterSubscriber');

var _OuterSubscriber3 = _interopRequireDefault(_OuterSubscriber2);

var _utilSubscribeToResult = require('../util/subscribeToResult');

var _utilSubscribeToResult2 = _interopRequireDefault(_utilSubscribeToResult);

var ExpandOperator = (function () {
    function ExpandOperator(project) {
        var concurrent = arguments.length <= 1 || arguments[1] === undefined ? Number.POSITIVE_INFINITY : arguments[1];

        _classCallCheck(this, ExpandOperator);

        this.project = project;
        this.concurrent = concurrent;
    }

    ExpandOperator.prototype.call = function call(subscriber) {
        return new ExpandSubscriber(subscriber, this.project, this.concurrent);
    };

    return ExpandOperator;
})();

exports.ExpandOperator = ExpandOperator;

var ExpandSubscriber = (function (_OuterSubscriber) {
    _inherits(ExpandSubscriber, _OuterSubscriber);

    function ExpandSubscriber(destination, project) {
        var concurrent = arguments.length <= 2 || arguments[2] === undefined ? Number.POSITIVE_INFINITY : arguments[2];

        _classCallCheck(this, ExpandSubscriber);

        _OuterSubscriber.call(this, destination);
        this.project = project;
        this.concurrent = concurrent;
        this.index = 0;
        this.active = 0;
        this.hasCompleted = false;
        if (concurrent < Number.POSITIVE_INFINITY) {
            this.buffer = [];
        }
    }

    ExpandSubscriber.prototype._next = function _next(value) {
        var index = this.index++;
        this.destination.next(value);
        if (this.active < this.concurrent) {
            var result = _utilTryCatch2['default'](this.project)(value, index);
            if (result === _utilErrorObject.errorObject) {
                this.destination.error(result.e);
            } else {
                if (result._isScalar) {
                    this._next(result.value);
                } else {
                    this.active++;
                    this.add(_utilSubscribeToResult2['default'](this, result, value, index));
                }
            }
        } else {
            this.buffer.push(value);
        }
    };

    ExpandSubscriber.prototype._complete = function _complete() {
        this.hasCompleted = true;
        if (this.hasCompleted && this.active === 0) {
            this.destination.complete();
        }
    };

    ExpandSubscriber.prototype.notifyComplete = function notifyComplete(innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer && buffer.length > 0) {
            this._next(buffer.shift());
        }
        if (this.hasCompleted && this.active === 0) {
            this.destination.complete();
        }
    };

    ExpandSubscriber.prototype.notifyNext = function notifyNext(innerValue, outerValue, innerIndex, outerIndex) {
        this._next(innerValue);
    };

    return ExpandSubscriber;
})(_OuterSubscriber3['default']);

exports.ExpandSubscriber = ExpandSubscriber;
},{"../OuterSubscriber":5,"../util/errorObject":128,"../util/subscribeToResult":134,"../util/tryCatch":136}],51:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = expand;

var _expandSupport = require('./expand-support');

function expand(project) {
    var concurrent = arguments.length <= 1 || arguments[1] === undefined ? Number.POSITIVE_INFINITY : arguments[1];

    return this.lift(new _expandSupport.ExpandOperator(project, concurrent));
}

module.exports = exports['default'];
},{"./expand-support":50}],52:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = filter;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _Subscriber2 = require('../Subscriber');

var _Subscriber3 = _interopRequireDefault(_Subscriber2);

var _utilTryCatch = require('../util/tryCatch');

var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

var _utilErrorObject = require('../util/errorObject');

var _utilBindCallback = require('../util/bindCallback');

var _utilBindCallback2 = _interopRequireDefault(_utilBindCallback);

/**
 * Similar to the well-known `Array.prototype.filter` method, this operator filters values down to a set
 * allowed by a `select` function
 *
 * @param {Function} select a function that is used to select the resulting values
 *  if it returns `true`, the value is emitted, if `false` the value is not passed to the resulting observable
 * @param {any} [thisArg] an optional argument to determine the value of `this` in the `select` function
 * @returns {Observable} an observable of values allowed by the select function
 */

function filter(select, thisArg) {
    return this.lift(new FilterOperator(select, thisArg));
}

var FilterOperator = (function () {
    function FilterOperator(select, thisArg) {
        _classCallCheck(this, FilterOperator);

        this.select = _utilBindCallback2['default'](select, thisArg, 2);
    }

    FilterOperator.prototype.call = function call(subscriber) {
        return new FilterSubscriber(subscriber, this.select);
    };

    return FilterOperator;
})();

var FilterSubscriber = (function (_Subscriber) {
    _inherits(FilterSubscriber, _Subscriber);

    function FilterSubscriber(destination, select) {
        _classCallCheck(this, FilterSubscriber);

        _Subscriber.call(this, destination);
        this.count = 0;
        this.select = select;
    }

    FilterSubscriber.prototype._next = function _next(x) {
        var result = _utilTryCatch2['default'](this.select)(x, this.count++);
        if (result === _utilErrorObject.errorObject) {
            this.destination.error(_utilErrorObject.errorObject.e);
        } else if (Boolean(result)) {
            this.destination.next(x);
        }
    };

    return FilterSubscriber;
})(_Subscriber3['default']);

module.exports = exports['default'];
},{"../Subscriber":8,"../util/bindCallback":127,"../util/errorObject":128,"../util/tryCatch":136}],53:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = _finally;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _Subscriber2 = require('../Subscriber');

var _Subscriber3 = _interopRequireDefault(_Subscriber2);

var _Subscription = require('../Subscription');

var _Subscription2 = _interopRequireDefault(_Subscription);

var _utilBindCallback = require('../util/bindCallback');

var _utilBindCallback2 = _interopRequireDefault(_utilBindCallback);

function _finally(finallySelector, thisArg) {
    return this.lift(new FinallyOperator(thisArg ? _utilBindCallback2['default'](finallySelector, thisArg, 2) : finallySelector));
}

var FinallyOperator = (function () {
    function FinallyOperator(finallySelector) {
        _classCallCheck(this, FinallyOperator);

        this.finallySelector = finallySelector;
    }

    FinallyOperator.prototype.call = function call(subscriber) {
        return new FinallySubscriber(subscriber, this.finallySelector);
    };

    return FinallyOperator;
})();

var FinallySubscriber = (function (_Subscriber) {
    _inherits(FinallySubscriber, _Subscriber);

    function FinallySubscriber(destination, finallySelector) {
        _classCallCheck(this, FinallySubscriber);

        _Subscriber.call(this, destination);
        this.add(new _Subscription2['default'](finallySelector));
    }

    return FinallySubscriber;
})(_Subscriber3['default']);

module.exports = exports['default'];
},{"../Subscriber":8,"../Subscription":9,"../util/bindCallback":127}],54:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = groupBy;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _Subscriber3 = require('../Subscriber');

var _Subscriber4 = _interopRequireDefault(_Subscriber3);

var _utilMap = require('../util/Map');

var _utilMap2 = _interopRequireDefault(_utilMap);

var _utilFastMap = require('../util/FastMap');

var _utilFastMap2 = _interopRequireDefault(_utilFastMap);

var _subjectsGroupSubject = require('../subjects/GroupSubject');

var _subjectsGroupSubject2 = _interopRequireDefault(_subjectsGroupSubject);

var _utilTryCatch = require('../util/tryCatch');

var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

var _utilErrorObject = require('../util/errorObject');

function groupBy(keySelector, elementSelector, durationSelector) {
    return this.lift(new GroupByOperator(keySelector, durationSelector, elementSelector));
}

var GroupByOperator = (function () {
    function GroupByOperator(keySelector, durationSelector, elementSelector) {
        _classCallCheck(this, GroupByOperator);

        this.keySelector = keySelector;
        this.durationSelector = durationSelector;
        this.elementSelector = elementSelector;
    }

    GroupByOperator.prototype.call = function call(subscriber) {
        return new GroupBySubscriber(subscriber, this.keySelector, this.durationSelector, this.elementSelector);
    };

    return GroupByOperator;
})();

var GroupBySubscriber = (function (_Subscriber) {
    _inherits(GroupBySubscriber, _Subscriber);

    function GroupBySubscriber(destination, keySelector, durationSelector, elementSelector) {
        _classCallCheck(this, GroupBySubscriber);

        _Subscriber.call(this, destination);
        this.keySelector = keySelector;
        this.durationSelector = durationSelector;
        this.elementSelector = elementSelector;
        this.groups = null;
    }

    GroupBySubscriber.prototype._next = function _next(x) {
        var key = _utilTryCatch2['default'](this.keySelector)(x);
        if (key === _utilErrorObject.errorObject) {
            this.error(key.e);
        } else {
            var groups = this.groups;
            var elementSelector = this.elementSelector;
            var durationSelector = this.durationSelector;
            if (!groups) {
                groups = this.groups = typeof key === 'string' ? new _utilFastMap2['default']() : new _utilMap2['default']();
            }
            var group = groups.get(key);
            if (!group) {
                groups.set(key, group = new _subjectsGroupSubject2['default'](key));
                if (durationSelector) {
                    var duration = _utilTryCatch2['default'](durationSelector)(group);
                    if (duration === _utilErrorObject.errorObject) {
                        this.error(duration.e);
                    } else {
                        this.add(duration._subscribe(new GroupDurationSubscriber(group, this)));
                    }
                }
                this.destination.next(group);
            }
            if (elementSelector) {
                var value = _utilTryCatch2['default'](elementSelector)(x);
                if (value === _utilErrorObject.errorObject) {
                    group.error(value.e);
                } else {
                    group.next(value);
                }
            } else {
                group.next(x);
            }
        }
    };

    GroupBySubscriber.prototype._error = function _error(err) {
        var _this = this;

        var groups = this.groups;
        if (groups) {
            groups.forEach(function (group, key) {
                group.error(err);
                _this.removeGroup(key);
            });
        }
        this.destination.error(err);
    };

    GroupBySubscriber.prototype._complete = function _complete() {
        var _this2 = this;

        var groups = this.groups;
        if (groups) {
            groups.forEach(function (group, key) {
                group.complete();
                _this2.removeGroup(group);
            });
        }
        this.destination.complete();
    };

    GroupBySubscriber.prototype.removeGroup = function removeGroup(key) {
        this.groups[key] = null;
    };

    return GroupBySubscriber;
})(_Subscriber4['default']);

var GroupDurationSubscriber = (function (_Subscriber2) {
    _inherits(GroupDurationSubscriber, _Subscriber2);

    function GroupDurationSubscriber(group, parent) {
        _classCallCheck(this, GroupDurationSubscriber);

        _Subscriber2.call(this, null);
        this.group = group;
        this.parent = parent;
    }

    GroupDurationSubscriber.prototype._next = function _next(value) {
        var group = this.group;
        group.complete();
        this.parent.removeGroup(group.key);
    };

    GroupDurationSubscriber.prototype._error = function _error(err) {
        var group = this.group;
        group.error(err);
        this.parent.removeGroup(group.key);
    };

    GroupDurationSubscriber.prototype._complete = function _complete() {
        var group = this.group;
        group.complete();
        this.parent.removeGroup(group.key);
    };

    return GroupDurationSubscriber;
})(_Subscriber4['default']);

module.exports = exports['default'];
},{"../Subscriber":8,"../subjects/GroupSubject":117,"../util/FastMap":122,"../util/Map":124,"../util/errorObject":128,"../util/tryCatch":136}],55:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = isEmpty;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _Subscriber2 = require('../Subscriber');

var _Subscriber3 = _interopRequireDefault(_Subscriber2);

function isEmpty() {
    return this.lift(new IsEmptyOperator());
}

var IsEmptyOperator = (function () {
    function IsEmptyOperator() {
        _classCallCheck(this, IsEmptyOperator);
    }

    IsEmptyOperator.prototype.call = function call(observer) {
        return new IsEmptySubscriber(observer);
    };

    return IsEmptyOperator;
})();

var IsEmptySubscriber = (function (_Subscriber) {
    _inherits(IsEmptySubscriber, _Subscriber);

    function IsEmptySubscriber(destination) {
        _classCallCheck(this, IsEmptySubscriber);

        _Subscriber.call(this, destination);
    }

    IsEmptySubscriber.prototype.notifyComplete = function notifyComplete(isEmpty) {
        var destination = this.destination;
        destination.next(isEmpty);
        destination.complete();
    };

    IsEmptySubscriber.prototype._next = function _next(value) {
        this.notifyComplete(false);
    };

    IsEmptySubscriber.prototype._complete = function _complete() {
        this.notifyComplete(true);
    };

    return IsEmptySubscriber;
})(_Subscriber3['default']);

module.exports = exports['default'];
},{"../Subscriber":8}],56:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = last;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _Subscriber2 = require('../Subscriber');

var _Subscriber3 = _interopRequireDefault(_Subscriber2);

var _utilTryCatch = require('../util/tryCatch');

var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

var _utilErrorObject = require('../util/errorObject');

var _utilBindCallback = require('../util/bindCallback');

var _utilBindCallback2 = _interopRequireDefault(_utilBindCallback);

var _utilEmptyError = require('../util/EmptyError');

var _utilEmptyError2 = _interopRequireDefault(_utilEmptyError);

function last(predicate, thisArg, defaultValue) {
    return this.lift(new LastOperator(predicate, thisArg, defaultValue, this));
}

var LastOperator = (function () {
    function LastOperator(predicate, thisArg, defaultValue, source) {
        _classCallCheck(this, LastOperator);

        this.predicate = predicate;
        this.thisArg = thisArg;
        this.defaultValue = defaultValue;
        this.source = source;
    }

    LastOperator.prototype.call = function call(observer) {
        return new LastSubscriber(observer, this.predicate, this.thisArg, this.defaultValue, this.source);
    };

    return LastOperator;
})();

var LastSubscriber = (function (_Subscriber) {
    _inherits(LastSubscriber, _Subscriber);

    function LastSubscriber(destination, predicate, thisArg, defaultValue, source) {
        _classCallCheck(this, LastSubscriber);

        _Subscriber.call(this, destination);
        this.thisArg = thisArg;
        this.defaultValue = defaultValue;
        this.source = source;
        this.hasValue = false;
        this.index = 0;
        if (typeof defaultValue !== 'undefined') {
            this.lastValue = defaultValue;
            this.hasValue = true;
        }
        if (typeof predicate === 'function') {
            this.predicate = _utilBindCallback2['default'](predicate, thisArg, 3);
        }
    }

    LastSubscriber.prototype._next = function _next(value) {
        var predicate = this.predicate;
        if (predicate) {
            var result = _utilTryCatch2['default'](predicate)(value, this.index++, this.source);
            if (result === _utilErrorObject.errorObject) {
                this.destination.error(result.e);
            } else if (result) {
                this.lastValue = value;
                this.hasValue = true;
            }
        } else {
            this.lastValue = value;
            this.hasValue = true;
        }
    };

    LastSubscriber.prototype._complete = function _complete() {
        var destination = this.destination;
        if (this.hasValue) {
            destination.next(this.lastValue);
            destination.complete();
        } else {
            destination.error(new _utilEmptyError2['default']());
        }
    };

    return LastSubscriber;
})(_Subscriber3['default']);

module.exports = exports['default'];
},{"../Subscriber":8,"../util/EmptyError":121,"../util/bindCallback":127,"../util/errorObject":128,"../util/tryCatch":136}],57:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = map;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _Subscriber2 = require('../Subscriber');

var _Subscriber3 = _interopRequireDefault(_Subscriber2);

var _utilTryCatch = require('../util/tryCatch');

var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

var _utilErrorObject = require('../util/errorObject');

var _utilBindCallback = require('../util/bindCallback');

var _utilBindCallback2 = _interopRequireDefault(_utilBindCallback);

/**
 * Similar to the well known `Array.prototype.map` function, this operator
 * applies a projection to each value and emits that projection in the returned observable
 *
 * @param {Function} project the function to create projection
 * @param {any} [thisArg] an optional argument to define what `this` is in the project function
 * @returns {Observable} a observable of projected values
 */

function map(project, thisArg) {
    return this.lift(new MapOperator(project, thisArg));
}

var MapOperator = (function () {
    function MapOperator(project, thisArg) {
        _classCallCheck(this, MapOperator);

        this.project = _utilBindCallback2['default'](project, thisArg, 2);
    }

    MapOperator.prototype.call = function call(subscriber) {
        return new MapSubscriber(subscriber, this.project);
    };

    return MapOperator;
})();

var MapSubscriber = (function (_Subscriber) {
    _inherits(MapSubscriber, _Subscriber);

    function MapSubscriber(destination, project) {
        _classCallCheck(this, MapSubscriber);

        _Subscriber.call(this, destination);
        this.count = 0;
        this.project = project;
    }

    MapSubscriber.prototype._next = function _next(x) {
        var result = _utilTryCatch2['default'](this.project)(x, this.count++);
        if (result === _utilErrorObject.errorObject) {
            this.error(_utilErrorObject.errorObject.e);
        } else {
            this.destination.next(result);
        }
    };

    return MapSubscriber;
})(_Subscriber3['default']);

module.exports = exports['default'];
},{"../Subscriber":8,"../util/bindCallback":127,"../util/errorObject":128,"../util/tryCatch":136}],58:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = mapTo;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _Subscriber2 = require('../Subscriber');

var _Subscriber3 = _interopRequireDefault(_Subscriber2);

/**
 * Maps every value to the same value every time.
 * @param {any} value the value to map each incoming value to
 * @returns {Observable} an observable of the passed value that emits everytime the source does
 */

function mapTo(value) {
    return this.lift(new MapToOperator(value));
}

var MapToOperator = (function () {
    function MapToOperator(value) {
        _classCallCheck(this, MapToOperator);

        this.value = value;
    }

    MapToOperator.prototype.call = function call(subscriber) {
        return new MapToSubscriber(subscriber, this.value);
    };

    return MapToOperator;
})();

var MapToSubscriber = (function (_Subscriber) {
    _inherits(MapToSubscriber, _Subscriber);

    function MapToSubscriber(destination, value) {
        _classCallCheck(this, MapToSubscriber);

        _Subscriber.call(this, destination);
        this.value = value;
    }

    MapToSubscriber.prototype._next = function _next(x) {
        this.destination.next(this.value);
    };

    return MapToSubscriber;
})(_Subscriber3['default']);

module.exports = exports['default'];
},{"../Subscriber":8}],59:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = materialize;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _Subscriber2 = require('../Subscriber');

var _Subscriber3 = _interopRequireDefault(_Subscriber2);

var _Notification = require('../Notification');

var _Notification2 = _interopRequireDefault(_Notification);

function materialize() {
    return this.lift(new MaterializeOperator());
}

var MaterializeOperator = (function () {
    function MaterializeOperator() {
        _classCallCheck(this, MaterializeOperator);
    }

    MaterializeOperator.prototype.call = function call(subscriber) {
        return new MaterializeSubscriber(subscriber);
    };

    return MaterializeOperator;
})();

var MaterializeSubscriber = (function (_Subscriber) {
    _inherits(MaterializeSubscriber, _Subscriber);

    function MaterializeSubscriber(destination) {
        _classCallCheck(this, MaterializeSubscriber);

        _Subscriber.call(this, destination);
    }

    MaterializeSubscriber.prototype._next = function _next(value) {
        this.destination.next(_Notification2['default'].createNext(value));
    };

    MaterializeSubscriber.prototype._error = function _error(err) {
        var destination = this.destination;
        destination.next(_Notification2['default'].createError(err));
        destination.complete();
    };

    MaterializeSubscriber.prototype._complete = function _complete() {
        var destination = this.destination;
        destination.next(_Notification2['default'].createComplete());
        destination.complete();
    };

    return MaterializeSubscriber;
})(_Subscriber3['default']);

module.exports = exports['default'];
},{"../Notification":3,"../Subscriber":8}],60:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = merge;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _observablesArrayObservable = require('../observables/ArrayObservable');

var _observablesArrayObservable2 = _interopRequireDefault(_observablesArrayObservable);

var _mergeAllSupport = require('./mergeAll-support');

var _schedulersImmediate = require('../schedulers/immediate');

var _schedulersImmediate2 = _interopRequireDefault(_schedulersImmediate);

function merge() {
    var concurrent = Number.POSITIVE_INFINITY;
    var scheduler = _schedulersImmediate2['default'];

    for (var _len = arguments.length, observables = Array(_len), _key = 0; _key < _len; _key++) {
        observables[_key] = arguments[_key];
    }

    var last = observables[observables.length - 1];
    if (typeof last.schedule === 'function') {
        scheduler = observables.pop();
        if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
            concurrent = observables.pop();
        }
    } else if (typeof last === 'number') {
        concurrent = observables.pop();
    }
    if (observables.length === 1) {
        return observables[0];
    }
    return new _observablesArrayObservable2['default'](observables, scheduler).lift(new _mergeAllSupport.MergeAllOperator(concurrent));
}

module.exports = exports['default'];
},{"../observables/ArrayObservable":10,"../schedulers/immediate":114,"./mergeAll-support":62}],61:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = merge;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _mergeStatic = require('./merge-static');

var _mergeStatic2 = _interopRequireDefault(_mergeStatic);

function merge() {
    for (var _len = arguments.length, observables = Array(_len), _key = 0; _key < _len; _key++) {
        observables[_key] = arguments[_key];
    }

    observables.unshift(this);
    return _mergeStatic2['default'].apply(this, observables);
}

module.exports = exports['default'];
},{"./merge-static":60}],62:[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _OuterSubscriber2 = require('../OuterSubscriber');

var _OuterSubscriber3 = _interopRequireDefault(_OuterSubscriber2);

var _utilSubscribeToResult = require('../util/subscribeToResult');

var _utilSubscribeToResult2 = _interopRequireDefault(_utilSubscribeToResult);

var MergeAllOperator = (function () {
    function MergeAllOperator(concurrent) {
        _classCallCheck(this, MergeAllOperator);

        this.concurrent = concurrent;
    }

    MergeAllOperator.prototype.call = function call(observer) {
        return new MergeAllSubscriber(observer, this.concurrent);
    };

    return MergeAllOperator;
})();

exports.MergeAllOperator = MergeAllOperator;

var MergeAllSubscriber = (function (_OuterSubscriber) {
    _inherits(MergeAllSubscriber, _OuterSubscriber);

    function MergeAllSubscriber(destination, concurrent) {
        _classCallCheck(this, MergeAllSubscriber);

        _OuterSubscriber.call(this, destination);
        this.concurrent = concurrent;
        this.hasCompleted = false;
        this.buffer = [];
        this.active = 0;
    }

    MergeAllSubscriber.prototype._next = function _next(observable) {
        if (this.active < this.concurrent) {
            if (observable._isScalar) {
                this.destination.next(observable.value);
            } else {
                this.active++;
                this.add(_utilSubscribeToResult2['default'](this, observable));
            }
        } else {
            this.buffer.push(observable);
        }
    };

    MergeAllSubscriber.prototype._complete = function _complete() {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            this.destination.complete();
        }
    };

    MergeAllSubscriber.prototype.notifyComplete = function notifyComplete(innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        } else if (this.active === 0 && this.hasCompleted) {
            this.destination.complete();
        }
    };

    return MergeAllSubscriber;
})(_OuterSubscriber3['default']);

exports.MergeAllSubscriber = MergeAllSubscriber;
},{"../OuterSubscriber":5,"../util/subscribeToResult":134}],63:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = mergeAll;

var _mergeAllSupport = require('./mergeAll-support');

function mergeAll() {
    var concurrent = arguments.length <= 0 || arguments[0] === undefined ? Number.POSITIVE_INFINITY : arguments[0];

    return this.lift(new _mergeAllSupport.MergeAllOperator(concurrent));
}

module.exports = exports['default'];
},{"./mergeAll-support":62}],64:[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _utilTryCatch = require('../util/tryCatch');

var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

var _utilErrorObject = require('../util/errorObject');

var _utilSubscribeToResult = require('../util/subscribeToResult');

var _utilSubscribeToResult2 = _interopRequireDefault(_utilSubscribeToResult);

var _OuterSubscriber2 = require('../OuterSubscriber');

var _OuterSubscriber3 = _interopRequireDefault(_OuterSubscriber2);

var MergeMapOperator = (function () {
    function MergeMapOperator(project, resultSelector) {
        var concurrent = arguments.length <= 2 || arguments[2] === undefined ? Number.POSITIVE_INFINITY : arguments[2];

        _classCallCheck(this, MergeMapOperator);

        this.project = project;
        this.resultSelector = resultSelector;
        this.concurrent = concurrent;
    }

    MergeMapOperator.prototype.call = function call(observer) {
        return new MergeMapSubscriber(observer, this.project, this.resultSelector, this.concurrent);
    };

    return MergeMapOperator;
})();

exports.MergeMapOperator = MergeMapOperator;

var MergeMapSubscriber = (function (_OuterSubscriber) {
    _inherits(MergeMapSubscriber, _OuterSubscriber);

    function MergeMapSubscriber(destination, project, resultSelector) {
        var concurrent = arguments.length <= 3 || arguments[3] === undefined ? Number.POSITIVE_INFINITY : arguments[3];

        _classCallCheck(this, MergeMapSubscriber);

        _OuterSubscriber.call(this, destination);
        this.project = project;
        this.resultSelector = resultSelector;
        this.concurrent = concurrent;
        this.hasCompleted = false;
        this.buffer = [];
        this.active = 0;
        this.index = 0;
    }

    MergeMapSubscriber.prototype._next = function _next(value) {
        if (this.active < this.concurrent) {
            var resultSelector = this.resultSelector;
            var index = this.index++;
            var ish = _utilTryCatch2['default'](this.project)(value, index);
            var destination = this.destination;
            if (ish === _utilErrorObject.errorObject) {
                destination.error(ish.e);
            } else {
                this.active++;
                this._innerSub(ish, value, index);
            }
        } else {
            this.buffer.push(value);
        }
    };

    MergeMapSubscriber.prototype._innerSub = function _innerSub(ish, value, index) {
        this.add(_utilSubscribeToResult2['default'](this, ish, value, index));
    };

    MergeMapSubscriber.prototype._complete = function _complete() {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            this.destination.complete();
        }
    };

    MergeMapSubscriber.prototype.notifyNext = function notifyNext(innerValue, outerValue, innerIndex, outerIndex) {
        var destination = this.destination;
        var resultSelector = this.resultSelector;

        if (resultSelector) {
            var result = _utilTryCatch2['default'](resultSelector)(innerValue, outerValue, innerIndex, outerIndex);
            if (result === _utilErrorObject.errorObject) {
                destination.error(_utilErrorObject.errorObject.e);
            } else {
                destination.next(result);
            }
        }
        destination.next(innerValue);
    };

    MergeMapSubscriber.prototype.notifyComplete = function notifyComplete(innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        } else if (this.active === 0 && this.hasCompleted) {
            this.destination.complete();
        }
    };

    return MergeMapSubscriber;
})(_OuterSubscriber3['default']);

exports.MergeMapSubscriber = MergeMapSubscriber;
},{"../OuterSubscriber":5,"../util/errorObject":128,"../util/subscribeToResult":134,"../util/tryCatch":136}],65:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = mergeMap;

var _mergeMapSupport = require('./mergeMap-support');

function mergeMap(project, resultSelector) {
    var concurrent = arguments.length <= 2 || arguments[2] === undefined ? Number.POSITIVE_INFINITY : arguments[2];

    return this.lift(new _mergeMapSupport.MergeMapOperator(project, resultSelector, concurrent));
}

module.exports = exports['default'];
},{"./mergeMap-support":64}],66:[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _utilTryCatch = require('../util/tryCatch');

var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

var _utilErrorObject = require('../util/errorObject');

var _OuterSubscriber2 = require('../OuterSubscriber');

var _OuterSubscriber3 = _interopRequireDefault(_OuterSubscriber2);

var _utilSubscribeToResult = require('../util/subscribeToResult');

var _utilSubscribeToResult2 = _interopRequireDefault(_utilSubscribeToResult);

var MergeMapToOperator = (function () {
    function MergeMapToOperator(ish, resultSelector) {
        var concurrent = arguments.length <= 2 || arguments[2] === undefined ? Number.POSITIVE_INFINITY : arguments[2];

        _classCallCheck(this, MergeMapToOperator);

        this.ish = ish;
        this.resultSelector = resultSelector;
        this.concurrent = concurrent;
    }

    MergeMapToOperator.prototype.call = function call(observer) {
        return new MergeMapToSubscriber(observer, this.ish, this.resultSelector, this.concurrent);
    };

    return MergeMapToOperator;
})();

exports.MergeMapToOperator = MergeMapToOperator;

var MergeMapToSubscriber = (function (_OuterSubscriber) {
    _inherits(MergeMapToSubscriber, _OuterSubscriber);

    function MergeMapToSubscriber(destination, ish, resultSelector) {
        var concurrent = arguments.length <= 3 || arguments[3] === undefined ? Number.POSITIVE_INFINITY : arguments[3];

        _classCallCheck(this, MergeMapToSubscriber);

        _OuterSubscriber.call(this, destination);
        this.ish = ish;
        this.resultSelector = resultSelector;
        this.concurrent = concurrent;
        this.hasCompleted = false;
        this.buffer = [];
        this.active = 0;
        this.index = 0;
    }

    MergeMapToSubscriber.prototype._next = function _next(value) {
        if (this.active < this.concurrent) {
            var resultSelector = this.resultSelector;
            var index = this.index++;
            var ish = this.ish;
            var destination = this.destination;
            if (ish === _utilErrorObject.errorObject) {
                destination.error(ish.e);
            } else {
                this.active--;
                this._innerSub(ish, destination, resultSelector, value, index);
            }
        } else {
            this.buffer.push(value);
        }
    };

    MergeMapToSubscriber.prototype._innerSub = function _innerSub(ish, destination, resultSelector, value, index) {
        this.add(_utilSubscribeToResult2['default'](this, ish, value, index));
    };

    MergeMapToSubscriber.prototype._complete = function _complete() {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            this.destination.complete();
        }
    };

    MergeMapToSubscriber.prototype.notifyNext = function notifyNext(innerValue, outerValue, innerIndex, outerIndex) {
        var resultSelector = this.resultSelector;
        var destination = this.destination;

        if (resultSelector) {
            var result = _utilTryCatch2['default'](resultSelector)(innerValue, outerValue, innerIndex, outerIndex);
            if (result === _utilErrorObject.errorObject) {
                destination.error(_utilErrorObject.errorObject.e);
            } else {
                destination.next(result);
            }
        } else {
            destination.next(innerValue);
        }
    };

    MergeMapToSubscriber.prototype.notifyError = function notifyError(err) {
        this.destination.error(err);
    };

    MergeMapToSubscriber.prototype.notifyComplete = function notifyComplete(innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        } else if (this.active === 0 && this.hasCompleted) {
            this.destination.complete();
        }
    };

    return MergeMapToSubscriber;
})(_OuterSubscriber3['default']);

exports.MergeMapToSubscriber = MergeMapToSubscriber;
},{"../OuterSubscriber":5,"../util/errorObject":128,"../util/subscribeToResult":134,"../util/tryCatch":136}],67:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = mergeMapTo;

var _mergeMapToSupport = require('./mergeMapTo-support');

function mergeMapTo(observable, resultSelector) {
    var concurrent = arguments.length <= 2 || arguments[2] === undefined ? Number.POSITIVE_INFINITY : arguments[2];

    return this.lift(new _mergeMapToSupport.MergeMapToOperator(observable, resultSelector, concurrent));
}

module.exports = exports['default'];
},{"./mergeMapTo-support":66}],68:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = multicast;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _observablesConnectableObservable = require('../observables/ConnectableObservable');

var _observablesConnectableObservable2 = _interopRequireDefault(_observablesConnectableObservable);

function multicast(subjectFactory) {
    return new _observablesConnectableObservable2['default'](this, subjectFactory);
}

module.exports = exports['default'];
},{"../observables/ConnectableObservable":11}],69:[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _Subscriber2 = require('../Subscriber');

var _Subscriber3 = _interopRequireDefault(_Subscriber2);

var _Notification = require('../Notification');

var _Notification2 = _interopRequireDefault(_Notification);

var ObserveOnOperator = (function () {
    function ObserveOnOperator(scheduler) {
        var delay = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

        _classCallCheck(this, ObserveOnOperator);

        this.delay = delay;
        this.scheduler = scheduler;
    }

    ObserveOnOperator.prototype.call = function call(subscriber) {
        return new ObserveOnSubscriber(subscriber, this.scheduler, this.delay);
    };

    return ObserveOnOperator;
})();

exports.ObserveOnOperator = ObserveOnOperator;

var ObserveOnSubscriber = (function (_Subscriber) {
    _inherits(ObserveOnSubscriber, _Subscriber);

    function ObserveOnSubscriber(destination, scheduler) {
        var delay = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];

        _classCallCheck(this, ObserveOnSubscriber);

        _Subscriber.call(this, destination);
        this.delay = delay;
        this.scheduler = scheduler;
    }

    ObserveOnSubscriber.dispatch = function dispatch(_ref) {
        var notification = _ref.notification;
        var destination = _ref.destination;

        notification.observe(destination);
    };

    ObserveOnSubscriber.prototype._next = function _next(x) {
        this.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(_Notification2['default'].createNext(x), this.destination)));
    };

    ObserveOnSubscriber.prototype._error = function _error(e) {
        this.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(_Notification2['default'].createError(e), this.destination)));
    };

    ObserveOnSubscriber.prototype._complete = function _complete() {
        this.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(_Notification2['default'].createComplete(), this.destination)));
    };

    return ObserveOnSubscriber;
})(_Subscriber3['default']);

exports.ObserveOnSubscriber = ObserveOnSubscriber;

var ObserveOnMessage = function ObserveOnMessage(notification, destination) {
    _classCallCheck(this, ObserveOnMessage);

    this.notification = notification;
    this.destination = destination;
};
},{"../Notification":3,"../Subscriber":8}],70:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = observeOn;

var _observeOnSupport = require('./observeOn-support');

function observeOn(scheduler) {
    var delay = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

    return this.lift(new _observeOnSupport.ObserveOnOperator(scheduler, delay));
}

module.exports = exports['default'];
},{"./observeOn-support":69}],71:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = partition;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _utilNot = require('../util/not');

var _utilNot2 = _interopRequireDefault(_utilNot);

var _filter = require('./filter');

var _filter2 = _interopRequireDefault(_filter);

function partition(predicate, thisArg) {
    return [_filter2['default'].call(this, predicate), _filter2['default'].call(this, _utilNot2['default'](predicate, thisArg))];
}

module.exports = exports['default'];
},{"../util/not":132,"./filter":52}],72:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = publish;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _Subject = require('../Subject');

var _Subject2 = _interopRequireDefault(_Subject);

var _multicast = require('./multicast');

var _multicast2 = _interopRequireDefault(_multicast);

function subjectFactory() {
    return new _Subject2['default']();
}

function publish() {
    return _multicast2['default'].call(this, subjectFactory);
}

module.exports = exports['default'];
},{"../Subject":7,"./multicast":68}],73:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = publishBehavior;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _subjectsBehaviorSubject = require('../subjects/BehaviorSubject');

var _subjectsBehaviorSubject2 = _interopRequireDefault(_subjectsBehaviorSubject);

var _multicast = require('./multicast');

var _multicast2 = _interopRequireDefault(_multicast);

function publishBehavior(value) {
    return _multicast2['default'].call(this, function () {
        return new _subjectsBehaviorSubject2['default'](value);
    });
}

module.exports = exports['default'];
},{"../subjects/BehaviorSubject":116,"./multicast":68}],74:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = publishReplay;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _subjectsReplaySubject = require('../subjects/ReplaySubject');

var _subjectsReplaySubject2 = _interopRequireDefault(_subjectsReplaySubject);

var _multicast = require('./multicast');

var _multicast2 = _interopRequireDefault(_multicast);

function publishReplay(bufferSize, windowTime, scheduler) {
    if (bufferSize === undefined) bufferSize = Number.POSITIVE_INFINITY;
    if (windowTime === undefined) windowTime = Number.POSITIVE_INFINITY;

    return _multicast2['default'].call(this, function () {
        return new _subjectsReplaySubject2['default'](bufferSize, windowTime, scheduler);
    });
}

module.exports = exports['default'];
},{"../subjects/ReplaySubject":118,"./multicast":68}],75:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = reduce;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _Subscriber2 = require('../Subscriber');

var _Subscriber3 = _interopRequireDefault(_Subscriber2);

var _utilTryCatch = require('../util/tryCatch');

var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

var _utilErrorObject = require('../util/errorObject');

function reduce(project, acc) {
    return this.lift(new ReduceOperator(project, acc));
}

var ReduceOperator = (function () {
    function ReduceOperator(project, acc) {
        _classCallCheck(this, ReduceOperator);

        this.acc = acc;
        this.project = project;
    }

    ReduceOperator.prototype.call = function call(subscriber) {
        return new ReduceSubscriber(subscriber, this.project, this.acc);
    };

    return ReduceOperator;
})();

var ReduceSubscriber = (function (_Subscriber) {
    _inherits(ReduceSubscriber, _Subscriber);

    function ReduceSubscriber(destination, project, acc) {
        _classCallCheck(this, ReduceSubscriber);

        _Subscriber.call(this, destination);
        this.hasValue = false;
        this.acc = acc;
        this.project = project;
        this.hasSeed = typeof acc !== "undefined";
    }

    ReduceSubscriber.prototype._next = function _next(x) {
        if (this.hasValue || (this.hasValue = this.hasSeed)) {
            var result = _utilTryCatch2['default'](this.project).call(this, this.acc, x);
            if (result === _utilErrorObject.errorObject) {
                this.destination.error(_utilErrorObject.errorObject.e);
            } else {
                this.acc = result;
            }
        } else {
            this.acc = x;
            this.hasValue = true;
        }
    };

    ReduceSubscriber.prototype._complete = function _complete() {
        if (this.hasValue || this.hasSeed) {
            this.destination.next(this.acc);
        }
        this.destination.complete();
    };

    return ReduceSubscriber;
})(_Subscriber3['default']);

module.exports = exports['default'];
},{"../Subscriber":8,"../util/errorObject":128,"../util/tryCatch":136}],76:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = repeat;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _Subscriber2 = require('../Subscriber');

var _Subscriber3 = _interopRequireDefault(_Subscriber2);

function repeat(count) {
    return this.lift(new RepeatOperator(count, this));
}

var RepeatOperator = (function () {
    function RepeatOperator(count, original) {
        _classCallCheck(this, RepeatOperator);

        this.count = count;
        this.original = original;
    }

    RepeatOperator.prototype.call = function call(subscriber) {
        return new RepeatSubscriber(subscriber, this.count, this.original);
    };

    return RepeatOperator;
})();

var RepeatSubscriber = (function (_Subscriber) {
    _inherits(RepeatSubscriber, _Subscriber);

    function RepeatSubscriber(destination, count, original) {
        _classCallCheck(this, RepeatSubscriber);

        _Subscriber.call(this, destination);
        this.count = count;
        this.original = original;
        this.repeated = 0;
    }

    RepeatSubscriber.prototype._complete = function _complete() {
        if (this.count === (this.repeated += 1)) {
            this.destination.complete();
        } else {
            this.resubscribe();
        }
    };

    RepeatSubscriber.prototype.resubscribe = function resubscribe() {
        this.original.subscribe(this);
    };

    return RepeatSubscriber;
})(_Subscriber3['default']);

module.exports = exports['default'];
},{"../Subscriber":8}],77:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = retry;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _Subscriber2 = require('../Subscriber');

var _Subscriber3 = _interopRequireDefault(_Subscriber2);

function retry() {
    var count = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];

    return this.lift(new RetryOperator(count, this));
}

var RetryOperator = (function () {
    function RetryOperator(count, original) {
        _classCallCheck(this, RetryOperator);

        this.count = count;
        this.original = original;
    }

    RetryOperator.prototype.call = function call(subscriber) {
        return new RetrySubscriber(subscriber, this.count, this.original);
    };

    return RetryOperator;
})();

var RetrySubscriber = (function (_Subscriber) {
    _inherits(RetrySubscriber, _Subscriber);

    function RetrySubscriber(destination, count, original) {
        _classCallCheck(this, RetrySubscriber);

        _Subscriber.call(this, destination);
        this.count = count;
        this.original = original;
        this.retries = 0;
    }

    RetrySubscriber.prototype._error = function _error(err) {
        var count = this.count;
        if (count && count === (this.retries += 1)) {
            this.destination.error(err);
        } else {
            this.resubscribe();
        }
    };

    RetrySubscriber.prototype.resubscribe = function resubscribe() {
        this.original.subscribe(this);
    };

    return RetrySubscriber;
})(_Subscriber3['default']);

module.exports = exports['default'];
},{"../Subscriber":8}],78:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = retryWhen;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _Subscriber3 = require('../Subscriber');

var _Subscriber4 = _interopRequireDefault(_Subscriber3);

var _Subject = require('../Subject');

var _Subject2 = _interopRequireDefault(_Subject);

var _utilTryCatch = require('../util/tryCatch');

var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

var _utilErrorObject = require('../util/errorObject');

function retryWhen(notifier) {
    return this.lift(new RetryWhenOperator(notifier, this));
}

var RetryWhenOperator = (function () {
    function RetryWhenOperator(notifier, original) {
        _classCallCheck(this, RetryWhenOperator);

        this.notifier = notifier;
        this.original = original;
    }

    RetryWhenOperator.prototype.call = function call(subscriber) {
        return new RetryWhenSubscriber(subscriber, this.notifier, this.original);
    };

    return RetryWhenOperator;
})();

var RetryWhenSubscriber = (function (_Subscriber) {
    _inherits(RetryWhenSubscriber, _Subscriber);

    function RetryWhenSubscriber(destination, notifier, original) {
        _classCallCheck(this, RetryWhenSubscriber);

        _Subscriber.call(this, destination);
        this.notifier = notifier;
        this.original = original;
    }

    RetryWhenSubscriber.prototype._error = function _error(err) {
        if (!this.retryNotifications) {
            this.errors = new _Subject2['default']();
            var notifications = _utilTryCatch2['default'](this.notifier).call(this, this.errors);
            if (notifications === _utilErrorObject.errorObject) {
                this.destination.error(_utilErrorObject.errorObject.e);
            } else {
                this.retryNotifications = notifications;
                this.add(notifications._subscribe(new RetryNotificationSubscriber(this)));
            }
        }
        this.errors.next(err);
    };

    RetryWhenSubscriber.prototype.finalError = function finalError(err) {
        this.destination.error(err);
    };

    RetryWhenSubscriber.prototype.resubscribe = function resubscribe() {
        this.original.subscribe(this);
    };

    return RetryWhenSubscriber;
})(_Subscriber4['default']);

var RetryNotificationSubscriber = (function (_Subscriber2) {
    _inherits(RetryNotificationSubscriber, _Subscriber2);

    function RetryNotificationSubscriber(parent) {
        _classCallCheck(this, RetryNotificationSubscriber);

        _Subscriber2.call(this, null);
        this.parent = parent;
    }

    RetryNotificationSubscriber.prototype._next = function _next(value) {
        this.parent.resubscribe();
    };

    RetryNotificationSubscriber.prototype._error = function _error(err) {
        this.parent.finalError(err);
    };

    RetryNotificationSubscriber.prototype._complete = function _complete() {
        this.parent.complete();
    };

    return RetryNotificationSubscriber;
})(_Subscriber4['default']);

module.exports = exports['default'];
},{"../Subject":7,"../Subscriber":8,"../util/errorObject":128,"../util/tryCatch":136}],79:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = sample;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _Subscriber3 = require('../Subscriber');

var _Subscriber4 = _interopRequireDefault(_Subscriber3);

function sample(notifier) {
    return this.lift(new SampleOperator(notifier));
}

var SampleOperator = (function () {
    function SampleOperator(notifier) {
        _classCallCheck(this, SampleOperator);

        this.notifier = notifier;
    }

    SampleOperator.prototype.call = function call(subscriber) {
        return new SampleSubscriber(subscriber, this.notifier);
    };

    return SampleOperator;
})();

var SampleSubscriber = (function (_Subscriber) {
    _inherits(SampleSubscriber, _Subscriber);

    function SampleSubscriber(destination, notifier) {
        _classCallCheck(this, SampleSubscriber);

        _Subscriber.call(this, destination);
        this.notifier = notifier;
        this.hasValue = false;
        this.add(notifier._subscribe(new SampleNoficationSubscriber(this)));
    }

    SampleSubscriber.prototype._next = function _next(value) {
        this.lastValue = value;
        this.hasValue = true;
    };

    SampleSubscriber.prototype.notifyNext = function notifyNext() {
        if (this.hasValue) {
            this.destination.next(this.lastValue);
        }
    };

    return SampleSubscriber;
})(_Subscriber4['default']);

var SampleNoficationSubscriber = (function (_Subscriber2) {
    _inherits(SampleNoficationSubscriber, _Subscriber2);

    function SampleNoficationSubscriber(parent) {
        _classCallCheck(this, SampleNoficationSubscriber);

        _Subscriber2.call(this, null);
        this.parent = parent;
    }

    SampleNoficationSubscriber.prototype._next = function _next() {
        this.parent.notifyNext();
    };

    SampleNoficationSubscriber.prototype._error = function _error(err) {
        this.parent.error(err);
    };

    SampleNoficationSubscriber.prototype._complete = function _complete() {
        //noop
    };

    return SampleNoficationSubscriber;
})(_Subscriber4['default']);

module.exports = exports['default'];
},{"../Subscriber":8}],80:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = sampleTime;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _Subscriber2 = require('../Subscriber');

var _Subscriber3 = _interopRequireDefault(_Subscriber2);

var _schedulersNextTick = require('../schedulers/nextTick');

var _schedulersNextTick2 = _interopRequireDefault(_schedulersNextTick);

function sampleTime(delay) {
    var scheduler = arguments.length <= 1 || arguments[1] === undefined ? _schedulersNextTick2['default'] : arguments[1];

    return this.lift(new SampleTimeOperator(delay, scheduler));
}

var SampleTimeOperator = (function () {
    function SampleTimeOperator(delay, scheduler) {
        _classCallCheck(this, SampleTimeOperator);

        this.delay = delay;
        this.scheduler = scheduler;
    }

    SampleTimeOperator.prototype.call = function call(subscriber) {
        return new SampleTimeSubscriber(subscriber, this.delay, this.scheduler);
    };

    return SampleTimeOperator;
})();

var SampleTimeSubscriber = (function (_Subscriber) {
    _inherits(SampleTimeSubscriber, _Subscriber);

    function SampleTimeSubscriber(destination, delay, scheduler) {
        _classCallCheck(this, SampleTimeSubscriber);

        _Subscriber.call(this, destination);
        this.delay = delay;
        this.scheduler = scheduler;
        this.hasValue = false;
        this.add(scheduler.schedule(dispatchNotification, delay, { subscriber: this, delay: delay }));
    }

    SampleTimeSubscriber.prototype._next = function _next(value) {
        this.lastValue = value;
        this.hasValue = true;
    };

    SampleTimeSubscriber.prototype.notifyNext = function notifyNext() {
        if (this.hasValue) {
            this.destination.next(this.lastValue);
        }
    };

    return SampleTimeSubscriber;
})(_Subscriber3['default']);

function dispatchNotification(state) {
    var subscriber = state.subscriber;
    var delay = state.delay;

    subscriber.notifyNext();
    this.schedule(state, delay);
}
module.exports = exports['default'];
},{"../Subscriber":8,"../schedulers/nextTick":115}],81:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = scan;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _Subscriber2 = require('../Subscriber');

var _Subscriber3 = _interopRequireDefault(_Subscriber2);

var _utilTryCatch = require('../util/tryCatch');

var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

var _utilErrorObject = require('../util/errorObject');

function scan(project, acc) {
    return this.lift(new ScanOperator(project));
}

var ScanOperator = (function () {
    function ScanOperator(project, acc) {
        _classCallCheck(this, ScanOperator);

        this.acc = acc;
        this.project = project;
    }

    ScanOperator.prototype.call = function call(subscriber) {
        return new ScanSubscriber(subscriber, this.project, this.acc);
    };

    return ScanOperator;
})();

var ScanSubscriber = (function (_Subscriber) {
    _inherits(ScanSubscriber, _Subscriber);

    function ScanSubscriber(destination, project, acc) {
        _classCallCheck(this, ScanSubscriber);

        _Subscriber.call(this, destination);
        this.hasValue = false;
        this.acc = acc;
        this.project = project;
        this.hasSeed = typeof acc !== "undefined";
    }

    ScanSubscriber.prototype._next = function _next(x) {
        if (this.hasValue || (this.hasValue = this.hasSeed)) {
            var result = _utilTryCatch2['default'](this.project).call(this, this.acc, x);
            if (result === _utilErrorObject.errorObject) {
                this.destination.error(_utilErrorObject.errorObject.e);
            } else {
                this.destination.next(this.acc = result);
            }
        } else {
            return this.destination.next((this.hasValue = true) && (this.acc = x));
        }
    };

    ScanSubscriber.prototype._complete = function _complete() {
        if (!this.hasValue && this.hasSeed) {
            this.destination.next(this.acc);
        }
        this.destination.complete();
    };

    return ScanSubscriber;
})(_Subscriber3['default']);

module.exports = exports['default'];
},{"../Subscriber":8,"../util/errorObject":128,"../util/tryCatch":136}],82:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = single;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _Subscriber2 = require('../Subscriber');

var _Subscriber3 = _interopRequireDefault(_Subscriber2);

var _utilTryCatch = require('../util/tryCatch');

var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

var _utilErrorObject = require('../util/errorObject');

var _utilBindCallback = require('../util/bindCallback');

var _utilBindCallback2 = _interopRequireDefault(_utilBindCallback);

var _utilEmptyError = require('../util/EmptyError');

var _utilEmptyError2 = _interopRequireDefault(_utilEmptyError);

function single(predicate, thisArg) {
    return this.lift(new SingleOperator(predicate, thisArg, this));
}

var SingleOperator = (function () {
    function SingleOperator(predicate, thisArg, source) {
        _classCallCheck(this, SingleOperator);

        this.predicate = predicate;
        this.thisArg = thisArg;
        this.source = source;
    }

    SingleOperator.prototype.call = function call(subscriber) {
        return new SingleSubscriber(subscriber, this.predicate, this.thisArg, this.source);
    };

    return SingleOperator;
})();

var SingleSubscriber = (function (_Subscriber) {
    _inherits(SingleSubscriber, _Subscriber);

    function SingleSubscriber(destination, predicate, thisArg, source) {
        _classCallCheck(this, SingleSubscriber);

        _Subscriber.call(this, destination);
        this.thisArg = thisArg;
        this.source = source;
        this.seenValue = false;
        this.index = 0;
        if (typeof predicate === 'function') {
            this.predicate = _utilBindCallback2['default'](predicate, thisArg, 3);
        }
    }

    SingleSubscriber.prototype.applySingleValue = function applySingleValue(value) {
        if (this.seenValue) {
            this.destination.error('Sequence contains more than one element');
        } else {
            this.seenValue = true;
            this.singleValue = value;
        }
    };

    SingleSubscriber.prototype._next = function _next(value) {
        var predicate = this.predicate;
        var currentIndex = this.index++;
        if (predicate) {
            var result = _utilTryCatch2['default'](predicate)(value, currentIndex, this.source);
            if (result === _utilErrorObject.errorObject) {
                this.destination.error(result.e);
            } else if (result) {
                this.applySingleValue(value);
            }
        } else {
            this.applySingleValue(value);
        }
    };

    SingleSubscriber.prototype._complete = function _complete() {
        var destination = this.destination;
        if (this.index > 0) {
            destination.next(this.seenValue ? this.singleValue : undefined);
            destination.complete();
        } else {
            destination.error(new _utilEmptyError2['default']());
        }
    };

    return SingleSubscriber;
})(_Subscriber3['default']);

module.exports = exports['default'];
},{"../Subscriber":8,"../util/EmptyError":121,"../util/bindCallback":127,"../util/errorObject":128,"../util/tryCatch":136}],83:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = skip;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _Subscriber2 = require('../Subscriber');

var _Subscriber3 = _interopRequireDefault(_Subscriber2);

function skip(total) {
    return this.lift(new SkipOperator(total));
}

var SkipOperator = (function () {
    function SkipOperator(total) {
        _classCallCheck(this, SkipOperator);

        this.total = total;
    }

    SkipOperator.prototype.call = function call(subscriber) {
        return new SkipSubscriber(subscriber, this.total);
    };

    return SkipOperator;
})();

var SkipSubscriber = (function (_Subscriber) {
    _inherits(SkipSubscriber, _Subscriber);

    function SkipSubscriber(destination, total) {
        _classCallCheck(this, SkipSubscriber);

        _Subscriber.call(this, destination);
        this.count = 0;
        this.total = total;
    }

    SkipSubscriber.prototype._next = function _next(x) {
        if (++this.count > this.total) {
            this.destination.next(x);
        }
    };

    return SkipSubscriber;
})(_Subscriber3['default']);

module.exports = exports['default'];
},{"../Subscriber":8}],84:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = skipUntil;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _Subscriber3 = require('../Subscriber');

var _Subscriber4 = _interopRequireDefault(_Subscriber3);

function skipUntil(total) {
    return this.lift(new SkipUntilOperator(total));
}

var SkipUntilOperator = (function () {
    function SkipUntilOperator(notifier) {
        _classCallCheck(this, SkipUntilOperator);

        this.notifier = notifier;
    }

    SkipUntilOperator.prototype.call = function call(subscriber) {
        return new SkipUntilSubscriber(subscriber, this.notifier);
    };

    return SkipUntilOperator;
})();

var SkipUntilSubscriber = (function (_Subscriber) {
    _inherits(SkipUntilSubscriber, _Subscriber);

    function SkipUntilSubscriber(destination, notifier) {
        _classCallCheck(this, SkipUntilSubscriber);

        _Subscriber.call(this, destination);
        this.notifier = notifier;
        this.notificationSubscriber = new NotificationSubscriber();
        this.add(this.notifier.subscribe(this.notificationSubscriber));
    }

    SkipUntilSubscriber.prototype._next = function _next(x) {
        if (this.notificationSubscriber.hasNotified) {
            this.destination.next(x);
        }
    };

    return SkipUntilSubscriber;
})(_Subscriber4['default']);

var NotificationSubscriber = (function (_Subscriber2) {
    _inherits(NotificationSubscriber, _Subscriber2);

    function NotificationSubscriber() {
        _classCallCheck(this, NotificationSubscriber);

        _Subscriber2.call(this, null);
        this.hasNotified = false;
    }

    NotificationSubscriber.prototype._next = function _next() {
        this.hasNotified = true;
        this.unsubscribe();
    };

    return NotificationSubscriber;
})(_Subscriber4['default']);

module.exports = exports['default'];
},{"../Subscriber":8}],85:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = startWith;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _observablesScalarObservable = require('../observables/ScalarObservable');

var _observablesScalarObservable2 = _interopRequireDefault(_observablesScalarObservable);

var _concatStatic = require('./concat-static');

var _concatStatic2 = _interopRequireDefault(_concatStatic);

function startWith(x) {
    return _concatStatic2['default'](new _observablesScalarObservable2['default'](x), this);
}

module.exports = exports['default'];
},{"../observables/ScalarObservable":24,"./concat-static":37}],86:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = subscribeOn;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _observablesSubscribeOnObservable = require('../observables/SubscribeOnObservable');

var _observablesSubscribeOnObservable2 = _interopRequireDefault(_observablesSubscribeOnObservable);

function subscribeOn(scheduler) {
    var delay = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

    return new _observablesSubscribeOnObservable2['default'](this, delay, scheduler);
}

module.exports = exports['default'];
},{"../observables/SubscribeOnObservable":25}],87:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = _switch;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _OuterSubscriber2 = require('../OuterSubscriber');

var _OuterSubscriber3 = _interopRequireDefault(_OuterSubscriber2);

var _utilSubscribeToResult = require('../util/subscribeToResult');

var _utilSubscribeToResult2 = _interopRequireDefault(_utilSubscribeToResult);

function _switch() {
    return this.lift(new SwitchOperator());
}

var SwitchOperator = (function () {
    function SwitchOperator() {
        _classCallCheck(this, SwitchOperator);
    }

    SwitchOperator.prototype.call = function call(subscriber) {
        return new SwitchSubscriber(subscriber);
    };

    return SwitchOperator;
})();

var SwitchSubscriber = (function (_OuterSubscriber) {
    _inherits(SwitchSubscriber, _OuterSubscriber);

    function SwitchSubscriber(destination) {
        _classCallCheck(this, SwitchSubscriber);

        _OuterSubscriber.call(this, destination);
        this.active = 0;
        this.hasCompleted = false;
    }

    SwitchSubscriber.prototype._next = function _next(value) {
        this.unsubscribeInner();
        this.active++;
        this.add(this.innerSubscription = _utilSubscribeToResult2['default'](this, value));
    };

    SwitchSubscriber.prototype._complete = function _complete() {
        this.hasCompleted = true;
        if (this.active === 0) {
            this.destination.complete();
        }
    };

    SwitchSubscriber.prototype.unsubscribeInner = function unsubscribeInner() {
        this.active = this.active > 0 ? this.active - 1 : 0;
        var innerSubscription = this.innerSubscription;
        if (innerSubscription) {
            innerSubscription.unsubscribe();
            this.remove(innerSubscription);
        }
    };

    SwitchSubscriber.prototype.notifyNext = function notifyNext(value) {
        this.destination.next(value);
    };

    SwitchSubscriber.prototype.notifyError = function notifyError(err) {
        this.destination.error(err);
    };

    SwitchSubscriber.prototype.notifyComplete = function notifyComplete() {
        this.unsubscribeInner();
        if (this.hasCompleted && this.active === 0) {
            this.destination.complete();
        }
    };

    return SwitchSubscriber;
})(_OuterSubscriber3['default']);

module.exports = exports['default'];
},{"../OuterSubscriber":5,"../util/subscribeToResult":134}],88:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = switchMap;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _utilTryCatch = require('../util/tryCatch');

var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

var _utilErrorObject = require('../util/errorObject');

var _OuterSubscriber2 = require('../OuterSubscriber');

var _OuterSubscriber3 = _interopRequireDefault(_OuterSubscriber2);

var _utilSubscribeToResult = require('../util/subscribeToResult');

var _utilSubscribeToResult2 = _interopRequireDefault(_utilSubscribeToResult);

function switchMap(project, resultSelector) {
    return this.lift(new SwitchMapOperator(project, resultSelector));
}

var SwitchMapOperator = (function () {
    function SwitchMapOperator(project, resultSelector) {
        _classCallCheck(this, SwitchMapOperator);

        this.project = project;
        this.resultSelector = resultSelector;
    }

    SwitchMapOperator.prototype.call = function call(subscriber) {
        return new SwitchMapSubscriber(subscriber, this.project, this.resultSelector);
    };

    return SwitchMapOperator;
})();

var SwitchMapSubscriber = (function (_OuterSubscriber) {
    _inherits(SwitchMapSubscriber, _OuterSubscriber);

    function SwitchMapSubscriber(destination, project, resultSelector) {
        _classCallCheck(this, SwitchMapSubscriber);

        _OuterSubscriber.call(this, destination);
        this.project = project;
        this.resultSelector = resultSelector;
        this.hasCompleted = false;
        this.index = 0;
    }

    SwitchMapSubscriber.prototype._next = function _next(value) {
        var index = this.index++;
        var destination = this.destination;
        var result = _utilTryCatch2['default'](this.project)(value, index);
        if (result === _utilErrorObject.errorObject) {
            destination.error(result.e);
        } else {
            var innerSubscription = this.innerSubscription;
            if (innerSubscription) {
                innerSubscription.unsubscribe();
            }
            this.add(this.innerSubscription = _utilSubscribeToResult2['default'](this, result, value, index));
        }
    };

    SwitchMapSubscriber.prototype._complete = function _complete() {
        var innerSubscription = this.innerSubscription;
        this.hasCompleted = true;
        if (!innerSubscription || innerSubscription.isUnsubscribed) {
            this.destination.complete();
        }
    };

    SwitchMapSubscriber.prototype.notifyComplete = function notifyComplete(innerSub) {
        this.remove(innerSub);
        var prevSubscription = this.innerSubscription;
        if (prevSubscription) {
            prevSubscription.unsubscribe();
        }
        this.innerSubscription = null;
        if (this.hasCompleted) {
            this.destination.complete();
        }
    };

    SwitchMapSubscriber.prototype.notifyError = function notifyError(err) {
        this.destination.error(err);
    };

    SwitchMapSubscriber.prototype.notifyNext = function notifyNext(innerValue, outerValue, innerIndex, outerIndex) {
        var resultSelector = this.resultSelector;
        var destination = this.destination;

        if (resultSelector) {
            var result = _utilTryCatch2['default'](resultSelector)(innerValue, outerValue, innerIndex, outerIndex);
            if (result === _utilErrorObject.errorObject) {
                destination.error(_utilErrorObject.errorObject.e);
            } else {
                destination.next(result);
            }
        } else {
            destination.next(innerValue);
        }
    };

    return SwitchMapSubscriber;
})(_OuterSubscriber3['default']);

module.exports = exports['default'];
},{"../OuterSubscriber":5,"../util/errorObject":128,"../util/subscribeToResult":134,"../util/tryCatch":136}],89:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = switchMapTo;

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _mergeMapToSupport = require('./mergeMapTo-support');

function switchMapTo(observable, projectResult) {
    return this.lift(new SwitchMapToOperator(observable, projectResult));
}

var SwitchMapToOperator = (function () {
    function SwitchMapToOperator(observable, resultSelector) {
        _classCallCheck(this, SwitchMapToOperator);

        this.observable = observable;
        this.resultSelector = resultSelector;
    }

    SwitchMapToOperator.prototype.call = function call(subscriber) {
        return new SwitchMapToSubscriber(subscriber, this.observable, this.resultSelector);
    };

    return SwitchMapToOperator;
})();

var SwitchMapToSubscriber = (function (_MergeMapToSubscriber) {
    _inherits(SwitchMapToSubscriber, _MergeMapToSubscriber);

    function SwitchMapToSubscriber(destination, observable, resultSelector) {
        _classCallCheck(this, SwitchMapToSubscriber);

        _MergeMapToSubscriber.call(this, destination, observable, resultSelector, 1);
    }

    return SwitchMapToSubscriber;
})(_mergeMapToSupport.MergeMapToSubscriber);

module.exports = exports['default'];
},{"./mergeMapTo-support":66}],90:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = take;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _Subscriber2 = require('../Subscriber');

var _Subscriber3 = _interopRequireDefault(_Subscriber2);

function take(total) {
    return this.lift(new TakeOperator(total));
}

var TakeOperator = (function () {
    function TakeOperator(total) {
        _classCallCheck(this, TakeOperator);

        this.total = total;
    }

    TakeOperator.prototype.call = function call(subscriber) {
        return new TakeSubscriber(subscriber, this.total);
    };

    return TakeOperator;
})();

var TakeSubscriber = (function (_Subscriber) {
    _inherits(TakeSubscriber, _Subscriber);

    function TakeSubscriber(destination, total) {
        _classCallCheck(this, TakeSubscriber);

        _Subscriber.call(this, destination);
        this.count = 0;
        this.total = total;
    }

    TakeSubscriber.prototype._next = function _next(x) {
        var total = this.total;
        if (++this.count <= total) {
            this.destination.next(x);
            if (this.count === total) {
                this.destination.complete();
            }
        }
    };

    return TakeSubscriber;
})(_Subscriber3['default']);

module.exports = exports['default'];
},{"../Subscriber":8}],91:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = takeUntil;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _Subscriber3 = require('../Subscriber');

var _Subscriber4 = _interopRequireDefault(_Subscriber3);

function takeUntil(observable) {
    return this.lift(new TakeUntilOperator(observable));
}

var TakeUntilOperator = (function () {
    function TakeUntilOperator(observable) {
        _classCallCheck(this, TakeUntilOperator);

        this.observable = observable;
    }

    TakeUntilOperator.prototype.call = function call(subscriber) {
        return new TakeUntilSubscriber(subscriber, this.observable);
    };

    return TakeUntilOperator;
})();

var TakeUntilSubscriber = (function (_Subscriber) {
    _inherits(TakeUntilSubscriber, _Subscriber);

    function TakeUntilSubscriber(destination, observable) {
        _classCallCheck(this, TakeUntilSubscriber);

        _Subscriber.call(this, destination);
        this.add(observable._subscribe(new TakeUntilInnerSubscriber(destination)));
    }

    return TakeUntilSubscriber;
})(_Subscriber4['default']);

var TakeUntilInnerSubscriber = (function (_Subscriber2) {
    _inherits(TakeUntilInnerSubscriber, _Subscriber2);

    function TakeUntilInnerSubscriber(destination) {
        _classCallCheck(this, TakeUntilInnerSubscriber);

        _Subscriber2.call(this, destination);
    }

    TakeUntilInnerSubscriber.prototype._next = function _next() {
        this.destination.complete();
    };

    TakeUntilInnerSubscriber.prototype._error = function _error(e) {
        this.destination.error(e);
    };

    TakeUntilInnerSubscriber.prototype._complete = function _complete() {};

    return TakeUntilInnerSubscriber;
})(_Subscriber4['default']);

module.exports = exports['default'];
},{"../Subscriber":8}],92:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = throttle;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _Subscriber2 = require('../Subscriber');

var _Subscriber3 = _interopRequireDefault(_Subscriber2);

var _schedulersNextTick = require('../schedulers/nextTick');

var _schedulersNextTick2 = _interopRequireDefault(_schedulersNextTick);

function throttle(delay) {
    var scheduler = arguments.length <= 1 || arguments[1] === undefined ? _schedulersNextTick2['default'] : arguments[1];

    return this.lift(new ThrottleOperator(delay, scheduler));
}

var ThrottleOperator = (function () {
    function ThrottleOperator(delay, scheduler) {
        _classCallCheck(this, ThrottleOperator);

        this.delay = delay;
        this.scheduler = scheduler;
    }

    ThrottleOperator.prototype.call = function call(subscriber) {
        return new ThrottleSubscriber(subscriber, this.delay, this.scheduler);
    };

    return ThrottleOperator;
})();

var ThrottleSubscriber = (function (_Subscriber) {
    _inherits(ThrottleSubscriber, _Subscriber);

    function ThrottleSubscriber(destination, delay, scheduler) {
        _classCallCheck(this, ThrottleSubscriber);

        _Subscriber.call(this, destination);
        this.delay = delay;
        this.scheduler = scheduler;
    }

    ThrottleSubscriber.prototype._next = function _next(x) {
        this.clearThrottle();
        this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.delay, { value: x, subscriber: this }));
    };

    ThrottleSubscriber.prototype.throttledNext = function throttledNext(x) {
        this.clearThrottle();
        this.destination.next(x);
    };

    ThrottleSubscriber.prototype.clearThrottle = function clearThrottle() {
        var throttled = this.throttled;
        if (throttled) {
            this.remove(throttled);
            throttled.unsubscribe();
            this.throttled = null;
        }
    };

    return ThrottleSubscriber;
})(_Subscriber3['default']);

function dispatchNext(_ref) {
    var value = _ref.value;
    var subscriber = _ref.subscriber;

    subscriber.throttledNext(value);
}
module.exports = exports['default'];
},{"../Subscriber":8,"../schedulers/nextTick":115}],93:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = timeout;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _Subscriber2 = require('../Subscriber');

var _Subscriber3 = _interopRequireDefault(_Subscriber2);

var _schedulersImmediate = require('../schedulers/immediate');

var _schedulersImmediate2 = _interopRequireDefault(_schedulersImmediate);

var _utilIsDate = require('../util/isDate');

var _utilIsDate2 = _interopRequireDefault(_utilIsDate);

function timeout(due) {
    var errorToSend = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
    var scheduler = arguments.length <= 2 || arguments[2] === undefined ? _schedulersImmediate2['default'] : arguments[2];

    var waitFor = _utilIsDate2['default'](due) ? +due - Date.now() : due;
    return this.lift(new TimeoutOperator(waitFor, errorToSend, scheduler));
}

var TimeoutOperator = (function () {
    function TimeoutOperator(waitFor, errorToSend, scheduler) {
        _classCallCheck(this, TimeoutOperator);

        this.waitFor = waitFor;
        this.errorToSend = errorToSend;
        this.scheduler = scheduler;
    }

    TimeoutOperator.prototype.call = function call(subscriber) {
        return new TimeoutSubscriber(subscriber, this.waitFor, this.errorToSend, this.scheduler);
    };

    return TimeoutOperator;
})();

var TimeoutSubscriber = (function (_Subscriber) {
    _inherits(TimeoutSubscriber, _Subscriber);

    function TimeoutSubscriber(destination, waitFor, errorToSend, scheduler) {
        _classCallCheck(this, TimeoutSubscriber);

        _Subscriber.call(this, destination);
        this.waitFor = waitFor;
        this.errorToSend = errorToSend;
        this.scheduler = scheduler;
        var delay = waitFor;
        scheduler.schedule(dispatchTimeout, delay, { subscriber: this });
    }

    TimeoutSubscriber.prototype.sendTimeoutError = function sendTimeoutError() {
        this.error(this.errorToSend || new Error('timeout'));
    };

    return TimeoutSubscriber;
})(_Subscriber3['default']);

function dispatchTimeout(state) {
    var subscriber = state.subscriber;
    subscriber.sendTimeoutError();
}
module.exports = exports['default'];
},{"../Subscriber":8,"../schedulers/immediate":114,"../util/isDate":129}],94:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = timeoutWith;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _Subscriber2 = require('../Subscriber');

var _Subscriber3 = _interopRequireDefault(_Subscriber2);

var _schedulersImmediate = require('../schedulers/immediate');

var _schedulersImmediate2 = _interopRequireDefault(_schedulersImmediate);

var _utilIsDate = require('../util/isDate');

var _utilIsDate2 = _interopRequireDefault(_utilIsDate);

function timeoutWith(due, withObservable) {
    var scheduler = arguments.length <= 2 || arguments[2] === undefined ? _schedulersImmediate2['default'] : arguments[2];

    var waitFor = _utilIsDate2['default'](due) ? +due - Date.now() : due;
    return this.lift(new TimeoutWithOperator(waitFor, withObservable, scheduler));
}

var TimeoutWithOperator = (function () {
    function TimeoutWithOperator(waitFor, withObservable, scheduler) {
        _classCallCheck(this, TimeoutWithOperator);

        this.waitFor = waitFor;
        this.withObservable = withObservable;
        this.scheduler = scheduler;
    }

    TimeoutWithOperator.prototype.call = function call(subscriber) {
        return new TimeoutWithSubscriber(subscriber, this.waitFor, this.withObservable, this.scheduler);
    };

    return TimeoutWithOperator;
})();

var TimeoutWithSubscriber = (function (_Subscriber) {
    _inherits(TimeoutWithSubscriber, _Subscriber);

    function TimeoutWithSubscriber(destination, waitFor, withObservable, scheduler) {
        _classCallCheck(this, TimeoutWithSubscriber);

        _Subscriber.call(this, destination);
        this.waitFor = waitFor;
        this.withObservable = withObservable;
        this.scheduler = scheduler;
        var delay = waitFor;
        scheduler.schedule(dispatchTimeout, delay, { subscriber: this });
    }

    TimeoutWithSubscriber.prototype.handleTimeout = function handleTimeout() {
        var withObservable = this.withObservable;
        this.add(withObservable.subscribe(this));
    };

    return TimeoutWithSubscriber;
})(_Subscriber3['default']);

function dispatchTimeout(state) {
    var subscriber = state.subscriber;
    subscriber.handleTimeout();
}
module.exports = exports['default'];
},{"../Subscriber":8,"../schedulers/immediate":114,"../util/isDate":129}],95:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = toArray;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _Subscriber2 = require('../Subscriber');

var _Subscriber3 = _interopRequireDefault(_Subscriber2);

function toArray() {
    return this.lift(new ToArrayOperator());
}

var ToArrayOperator = (function () {
    function ToArrayOperator() {
        _classCallCheck(this, ToArrayOperator);
    }

    ToArrayOperator.prototype.call = function call(subscriber) {
        return new ToArraySubscriber(subscriber);
    };

    return ToArrayOperator;
})();

var ToArraySubscriber = (function (_Subscriber) {
    _inherits(ToArraySubscriber, _Subscriber);

    function ToArraySubscriber(destination) {
        _classCallCheck(this, ToArraySubscriber);

        _Subscriber.call(this, destination);
        this.array = [];
    }

    ToArraySubscriber.prototype._next = function _next(x) {
        this.array.push(x);
    };

    ToArraySubscriber.prototype._complete = function _complete() {
        this.destination.next(this.array);
        this.destination.complete();
    };

    return ToArraySubscriber;
})(_Subscriber3['default']);

module.exports = exports['default'];
},{"../Subscriber":8}],96:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = toPromise;

var _utilRoot = require('../util/root');

function toPromise(PromiseCtor) {
    var _this = this;

    if (!PromiseCtor) {
        if (_utilRoot.root.Rx && _utilRoot.root.Rx.config && _utilRoot.root.Rx.config.Promise) {
            PromiseCtor = _utilRoot.root.Rx.config.Promise;
        } else if (_utilRoot.root.Promise) {
            PromiseCtor = _utilRoot.root.Promise;
        }
    }
    if (!PromiseCtor) {
        throw new Error('no Promise impl found');
    }
    return new PromiseCtor(function (resolve, reject) {
        var value = undefined;
        _this.subscribe(function (x) {
            return value = x;
        }, function (err) {
            return reject(err);
        }, function () {
            return resolve(value);
        });
    });
}

module.exports = exports['default'];
},{"../util/root":133}],97:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = window;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _Subscriber3 = require('../Subscriber');

var _Subscriber4 = _interopRequireDefault(_Subscriber3);

var _Subject = require('../Subject');

var _Subject2 = _interopRequireDefault(_Subject);

function window(closingNotifier) {
    return this.lift(new WindowOperator(closingNotifier));
}

var WindowOperator = (function () {
    function WindowOperator(closingNotifier) {
        _classCallCheck(this, WindowOperator);

        this.closingNotifier = closingNotifier;
    }

    WindowOperator.prototype.call = function call(subscriber) {
        return new WindowSubscriber(subscriber, this.closingNotifier);
    };

    return WindowOperator;
})();

var WindowSubscriber = (function (_Subscriber) {
    _inherits(WindowSubscriber, _Subscriber);

    function WindowSubscriber(destination, closingNotifier) {
        _classCallCheck(this, WindowSubscriber);

        _Subscriber.call(this, destination);
        this.closingNotifier = closingNotifier;
        this.window = new _Subject2['default']();
        this.add(closingNotifier._subscribe(new WindowClosingNotifierSubscriber(this)));
        this.openWindow();
    }

    WindowSubscriber.prototype._next = function _next(value) {
        this.window.next(value);
    };

    WindowSubscriber.prototype._error = function _error(err) {
        this.window.error(err);
        this.destination.error(err);
    };

    WindowSubscriber.prototype._complete = function _complete() {
        this.window.complete();
        this.destination.complete();
    };

    WindowSubscriber.prototype.openWindow = function openWindow() {
        var prevWindow = this.window;
        if (prevWindow) {
            prevWindow.complete();
        }
        this.destination.next(this.window = new _Subject2['default']());
    };

    return WindowSubscriber;
})(_Subscriber4['default']);

var WindowClosingNotifierSubscriber = (function (_Subscriber2) {
    _inherits(WindowClosingNotifierSubscriber, _Subscriber2);

    function WindowClosingNotifierSubscriber(parent) {
        _classCallCheck(this, WindowClosingNotifierSubscriber);

        _Subscriber2.call(this, null);
        this.parent = parent;
    }

    WindowClosingNotifierSubscriber.prototype._next = function _next() {
        this.parent.openWindow();
    };

    return WindowClosingNotifierSubscriber;
})(_Subscriber4['default']);

module.exports = exports['default'];
},{"../Subject":7,"../Subscriber":8}],98:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = windowCount;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _Subscriber2 = require('../Subscriber');

var _Subscriber3 = _interopRequireDefault(_Subscriber2);

var _Subject = require('../Subject');

var _Subject2 = _interopRequireDefault(_Subject);

function windowCount(windowSize) {
    var startWindowEvery = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

    return this.lift(new WindowCountOperator(windowSize, startWindowEvery));
}

var WindowCountOperator = (function () {
    function WindowCountOperator(windowSize, startWindowEvery) {
        _classCallCheck(this, WindowCountOperator);

        this.windowSize = windowSize;
        this.startWindowEvery = startWindowEvery;
    }

    WindowCountOperator.prototype.call = function call(subscriber) {
        return new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery);
    };

    return WindowCountOperator;
})();

var WindowCountSubscriber = (function (_Subscriber) {
    _inherits(WindowCountSubscriber, _Subscriber);

    function WindowCountSubscriber(destination, windowSize, startWindowEvery) {
        _classCallCheck(this, WindowCountSubscriber);

        _Subscriber.call(this, destination);
        this.windowSize = windowSize;
        this.startWindowEvery = startWindowEvery;
        this.windows = [{ count: 0, notified: false, window: new _Subject2['default']() }];
        this.count = 0;
    }

    WindowCountSubscriber.prototype._next = function _next(value) {
        var count = this.count += 1;
        var startWindowEvery = this.startWindowEvery > 0 ? this.startWindowEvery : this.windowSize;
        var windowSize = this.windowSize;
        var windows = this.windows;
        var len = windows.length;
        if (count % startWindowEvery === 0) {
            var _window = new _Subject2['default']();
            windows.push({ count: 0, notified: false, window: _window });
        }
        for (var i = 0; i < len; i++) {
            var w = windows[i];
            var _window2 = w.window;
            if (!w.notified) {
                w.notified = true;
                this.destination.next(_window2);
            }
            _window2.next(value);
            if (windowSize === (w.count += 1)) {
                _window2.complete();
            }
        }
    };

    WindowCountSubscriber.prototype._error = function _error(err) {
        var windows = this.windows;
        while (windows.length > 0) {
            windows.shift().window.error(err);
        }
        this.destination.error(err);
    };

    WindowCountSubscriber.prototype._complete = function _complete() {
        var windows = this.windows;
        while (windows.length > 0) {
            windows.shift().window.complete();
        }
        this.destination.complete();
    };

    return WindowCountSubscriber;
})(_Subscriber3['default']);

module.exports = exports['default'];
},{"../Subject":7,"../Subscriber":8}],99:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = windowTime;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _Subscriber2 = require('../Subscriber');

var _Subscriber3 = _interopRequireDefault(_Subscriber2);

var _Subject = require('../Subject');

var _Subject2 = _interopRequireDefault(_Subject);

var _schedulersNextTick = require('../schedulers/nextTick');

var _schedulersNextTick2 = _interopRequireDefault(_schedulersNextTick);

function windowTime(windowTimeSpan) {
    var windowCreationInterval = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
    var scheduler = arguments.length <= 2 || arguments[2] === undefined ? _schedulersNextTick2['default'] : arguments[2];

    return this.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, scheduler));
}

var WindowTimeOperator = (function () {
    function WindowTimeOperator(windowTimeSpan, windowCreationInterval, scheduler) {
        _classCallCheck(this, WindowTimeOperator);

        this.windowTimeSpan = windowTimeSpan;
        this.windowCreationInterval = windowCreationInterval;
        this.scheduler = scheduler;
    }

    WindowTimeOperator.prototype.call = function call(subscriber) {
        return new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.scheduler);
    };

    return WindowTimeOperator;
})();

var WindowTimeSubscriber = (function (_Subscriber) {
    _inherits(WindowTimeSubscriber, _Subscriber);

    function WindowTimeSubscriber(destination, windowTimeSpan, windowCreationInterval, scheduler) {
        _classCallCheck(this, WindowTimeSubscriber);

        _Subscriber.call(this, destination);
        this.windowTimeSpan = windowTimeSpan;
        this.windowCreationInterval = windowCreationInterval;
        this.scheduler = scheduler;
        this.windows = [];
        if (windowCreationInterval !== null && windowCreationInterval >= 0) {
            var _window = this.openWindow();
            this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, { subscriber: this, window: _window, context: null }));
            this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, { windowTimeSpan: windowTimeSpan, windowCreationInterval: windowCreationInterval, subscriber: this, scheduler: scheduler }));
        } else {
            var _window2 = this.openWindow();
            this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, { subscriber: this, window: _window2, windowTimeSpan: windowTimeSpan }));
        }
    }

    WindowTimeSubscriber.prototype._next = function _next(value) {
        var windows = this.windows;
        var len = windows.length;
        for (var i = 0; i < len; i++) {
            windows[i].next(value);
        }
    };

    WindowTimeSubscriber.prototype._error = function _error(err) {
        var windows = this.windows;
        while (windows.length > 0) {
            windows.shift().error(err);
        }
        this.destination.error(err);
    };

    WindowTimeSubscriber.prototype._complete = function _complete() {
        var windows = this.windows;
        while (windows.length > 0) {
            windows.shift().complete();
        }
        this.destination.complete();
    };

    WindowTimeSubscriber.prototype.openWindow = function openWindow() {
        var window = new _Subject2['default']();
        this.windows.push(window);
        this.destination.next(window);
        return window;
    };

    WindowTimeSubscriber.prototype.closeWindow = function closeWindow(window) {
        window.complete();
        var windows = this.windows;
        windows.splice(windows.indexOf(window), 1);
    };

    return WindowTimeSubscriber;
})(_Subscriber3['default']);

function dispatchWindowTimeSpanOnly(state) {
    var subscriber = state.subscriber;
    var windowTimeSpan = state.windowTimeSpan;
    var window = state.window;

    if (window) {
        window.complete();
    }
    state.window = subscriber.openWindow();
    this.schedule(state, windowTimeSpan);
}
function dispatchWindowCreation(state) {
    var windowTimeSpan = state.windowTimeSpan;
    var subscriber = state.subscriber;
    var scheduler = state.scheduler;
    var windowCreationInterval = state.windowCreationInterval;

    var window = subscriber.openWindow();
    var action = this;
    var context = { action: action, subscription: null };
    action.add(context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, { subscriber: subscriber, window: window, context: context }));
    action.schedule(state, windowCreationInterval);
}
function dispatchWindowClose(_ref) {
    var subscriber = _ref.subscriber;
    var window = _ref.window;
    var context = _ref.context;

    if (context && context.action && context.subscription) {
        context.action.remove(context.subscription);
    }
    subscriber.closeWindow(window);
}
module.exports = exports['default'];
},{"../Subject":7,"../Subscriber":8,"../schedulers/nextTick":115}],100:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = windowToggle;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _Subscriber4 = require('../Subscriber');

var _Subscriber5 = _interopRequireDefault(_Subscriber4);

var _Subject = require('../Subject');

var _Subject2 = _interopRequireDefault(_Subject);

var _Subscription = require('../Subscription');

var _Subscription2 = _interopRequireDefault(_Subscription);

var _utilTryCatch = require('../util/tryCatch');

var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

var _utilErrorObject = require('../util/errorObject');

function windowToggle(openings, closingSelector) {
    return this.lift(new WindowToggleOperator(openings, closingSelector));
}

var WindowToggleOperator = (function () {
    function WindowToggleOperator(openings, closingSelector) {
        _classCallCheck(this, WindowToggleOperator);

        this.openings = openings;
        this.closingSelector = closingSelector;
    }

    WindowToggleOperator.prototype.call = function call(subscriber) {
        return new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector);
    };

    return WindowToggleOperator;
})();

var WindowToggleSubscriber = (function (_Subscriber) {
    _inherits(WindowToggleSubscriber, _Subscriber);

    function WindowToggleSubscriber(destination, openings, closingSelector) {
        _classCallCheck(this, WindowToggleSubscriber);

        _Subscriber.call(this, destination);
        this.openings = openings;
        this.closingSelector = closingSelector;
        this.windows = [];
        this.add(this.openings._subscribe(new WindowToggleOpeningsSubscriber(this)));
    }

    WindowToggleSubscriber.prototype._next = function _next(value) {
        var windows = this.windows;
        var len = windows.length;
        for (var i = 0; i < len; i++) {
            windows[i].next(value);
        }
    };

    WindowToggleSubscriber.prototype._error = function _error(err) {
        var windows = this.windows;
        while (windows.length > 0) {
            windows.shift().error(err);
        }
        this.destination.error(err);
    };

    WindowToggleSubscriber.prototype._complete = function _complete() {
        var windows = this.windows;
        while (windows.length > 0) {
            windows.shift().complete();
        }
        this.destination.complete();
    };

    WindowToggleSubscriber.prototype.openWindow = function openWindow(value) {
        var window = new _Subject2['default']();
        this.windows.push(window);
        this.destination.next(window);
        var windowContext = {
            window: window,
            subscription: new _Subscription2['default']()
        };
        var closingSelector = this.closingSelector;
        var closingNotifier = _utilTryCatch2['default'](closingSelector)(value);
        if (closingNotifier === _utilErrorObject.errorObject) {
            this.error(closingNotifier.e);
        } else {
            this.add(windowContext.subscription.add(closingNotifier._subscribe(new WindowClosingNotifierSubscriber(this, windowContext))));
        }
    };

    WindowToggleSubscriber.prototype.closeWindow = function closeWindow(windowContext) {
        var window = windowContext.window;
        var subscription = windowContext.subscription;

        var windows = this.windows;
        windows.splice(windows.indexOf(window), 1);
        window.complete();
        this.remove(subscription);
    };

    return WindowToggleSubscriber;
})(_Subscriber5['default']);

var WindowClosingNotifierSubscriber = (function (_Subscriber2) {
    _inherits(WindowClosingNotifierSubscriber, _Subscriber2);

    function WindowClosingNotifierSubscriber(parent, windowContext) {
        _classCallCheck(this, WindowClosingNotifierSubscriber);

        _Subscriber2.call(this, null);
        this.parent = parent;
        this.windowContext = windowContext;
    }

    WindowClosingNotifierSubscriber.prototype._next = function _next() {
        this.parent.closeWindow(this.windowContext);
    };

    WindowClosingNotifierSubscriber.prototype._error = function _error(err) {
        this.parent.error(err);
    };

    WindowClosingNotifierSubscriber.prototype._complete = function _complete() {
        // noop
    };

    return WindowClosingNotifierSubscriber;
})(_Subscriber5['default']);

var WindowToggleOpeningsSubscriber = (function (_Subscriber3) {
    _inherits(WindowToggleOpeningsSubscriber, _Subscriber3);

    function WindowToggleOpeningsSubscriber(parent) {
        _classCallCheck(this, WindowToggleOpeningsSubscriber);

        _Subscriber3.call(this);
        this.parent = parent;
    }

    WindowToggleOpeningsSubscriber.prototype._next = function _next(value) {
        this.parent.openWindow(value);
    };

    WindowToggleOpeningsSubscriber.prototype._error = function _error(err) {
        this.parent.error(err);
    };

    WindowToggleOpeningsSubscriber.prototype._complete = function _complete() {
        // noop
    };

    return WindowToggleOpeningsSubscriber;
})(_Subscriber5['default']);

module.exports = exports['default'];
},{"../Subject":7,"../Subscriber":8,"../Subscription":9,"../util/errorObject":128,"../util/tryCatch":136}],101:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = window;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _Subscriber3 = require('../Subscriber');

var _Subscriber4 = _interopRequireDefault(_Subscriber3);

var _Subject = require('../Subject');

var _Subject2 = _interopRequireDefault(_Subject);

var _Subscription = require('../Subscription');

var _Subscription2 = _interopRequireDefault(_Subscription);

var _utilTryCatch = require('../util/tryCatch');

var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

var _utilErrorObject = require('../util/errorObject');

function window(closingSelector) {
    return this.lift(new WindowOperator(closingSelector));
}

var WindowOperator = (function () {
    function WindowOperator(closingSelector) {
        _classCallCheck(this, WindowOperator);

        this.closingSelector = closingSelector;
    }

    WindowOperator.prototype.call = function call(subscriber) {
        return new WindowSubscriber(subscriber, this.closingSelector);
    };

    return WindowOperator;
})();

var WindowSubscriber = (function (_Subscriber) {
    _inherits(WindowSubscriber, _Subscriber);

    function WindowSubscriber(destination, closingSelector) {
        _classCallCheck(this, WindowSubscriber);

        _Subscriber.call(this, destination);
        this.closingSelector = closingSelector;
        this.window = new _Subject2['default']();
        this.openWindow();
    }

    WindowSubscriber.prototype._next = function _next(value) {
        this.window.next(value);
    };

    WindowSubscriber.prototype._error = function _error(err) {
        this.window.error(err);
        this.destination.error(err);
    };

    WindowSubscriber.prototype._complete = function _complete() {
        this.window.complete();
        this.destination.complete();
    };

    WindowSubscriber.prototype.openWindow = function openWindow() {
        var prevClosingNotification = this.closingNotification;
        if (prevClosingNotification) {
            this.remove(prevClosingNotification);
            prevClosingNotification.unsubscribe();
        }
        var prevWindow = this.window;
        if (prevWindow) {
            prevWindow.complete();
        }
        this.destination.next(this.window = new _Subject2['default']());
        var closingNotifier = _utilTryCatch2['default'](this.closingSelector)();
        if (closingNotifier === _utilErrorObject.errorObject) {
            var err = closingNotifier.e;
            this.destination.error(err);
            this.window.error(err);
        } else {
            var closingNotification = this.closingNotification = new _Subscription2['default']();
            this.add(closingNotification.add(closingNotifier._subscribe(new WindowClosingNotifierSubscriber(this))));
        }
    };

    return WindowSubscriber;
})(_Subscriber4['default']);

var WindowClosingNotifierSubscriber = (function (_Subscriber2) {
    _inherits(WindowClosingNotifierSubscriber, _Subscriber2);

    function WindowClosingNotifierSubscriber(parent) {
        _classCallCheck(this, WindowClosingNotifierSubscriber);

        _Subscriber2.call(this, null);
        this.parent = parent;
    }

    WindowClosingNotifierSubscriber.prototype._next = function _next() {
        this.parent.openWindow();
    };

    WindowClosingNotifierSubscriber.prototype._error = function _error(err) {
        this.parent.error(err);
    };

    WindowClosingNotifierSubscriber.prototype._complete = function _complete() {
        // noop
    };

    return WindowClosingNotifierSubscriber;
})(_Subscriber4['default']);

module.exports = exports['default'];
},{"../Subject":7,"../Subscriber":8,"../Subscription":9,"../util/errorObject":128,"../util/tryCatch":136}],102:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = withLatestFrom;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _utilTryCatch = require('../util/tryCatch');

var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

var _utilErrorObject = require('../util/errorObject');

var _OuterSubscriber2 = require('../OuterSubscriber');

var _OuterSubscriber3 = _interopRequireDefault(_OuterSubscriber2);

var _utilSubscribeToResult = require('../util/subscribeToResult');

var _utilSubscribeToResult2 = _interopRequireDefault(_utilSubscribeToResult);

/**
 * @param {Observable} observables the observables to get the latest values from.
 * @param {Function} [project] optional projection function for merging values together. Receives all values in order
 *  of observables passed. (e.g. `a.withLatestFrom(b, c, (a1, b1, c1) => a1 + b1 + c1)`). If this is not passed, arrays
 *  will be returned.
 * @description merges each value from an observable with the latest values from the other passed observables.
 * All observables must emit at least one value before the resulting observable will emit
 *
 * #### example
 * ```
 * A.withLatestFrom(B, C)
 *
 *  A:     ----a-----------------b---------------c-----------|
 *  B:     ---d----------------e--------------f---------|
 *  C:     --x----------------y-------------z-------------|
 * result: ---([a,d,x])---------([b,e,y])--------([c,f,z])---|
 * ```
 */

function withLatestFrom() {
    var project = undefined;

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
    }

    if (typeof args[args.length - 1] === 'function') {
        project = args.pop();
    }
    var observables = args;
    return this.lift(new WithLatestFromOperator(observables, project));
}

var WithLatestFromOperator = (function () {
    function WithLatestFromOperator(observables, project) {
        _classCallCheck(this, WithLatestFromOperator);

        this.observables = observables;
        this.project = project;
    }

    WithLatestFromOperator.prototype.call = function call(subscriber) {
        return new WithLatestFromSubscriber(subscriber, this.observables, this.project);
    };

    return WithLatestFromOperator;
})();

var WithLatestFromSubscriber = (function (_OuterSubscriber) {
    _inherits(WithLatestFromSubscriber, _OuterSubscriber);

    function WithLatestFromSubscriber(destination, observables, project) {
        _classCallCheck(this, WithLatestFromSubscriber);

        _OuterSubscriber.call(this, destination);
        this.observables = observables;
        this.project = project;
        this.toRespond = [];
        var len = observables.length;
        this.values = new Array(len);
        for (var i = 0; i < len; i++) {
            this.toRespond.push(i);
        }
        for (var i = 0; i < len; i++) {
            var observable = observables[i];
            this.add(_utilSubscribeToResult2['default'](this, observable, observable, i));
        }
    }

    WithLatestFromSubscriber.prototype.notifyNext = function notifyNext(value, observable, index, observableIndex) {
        this.values[observableIndex] = value;
        var toRespond = this.toRespond;
        if (toRespond.length > 0) {
            var found = toRespond.indexOf(observableIndex);
            if (found !== -1) {
                toRespond.splice(found, 1);
            }
        }
    };

    WithLatestFromSubscriber.prototype.notifyComplete = function notifyComplete() {
        // noop
    };

    WithLatestFromSubscriber.prototype._next = function _next(value) {
        if (this.toRespond.length === 0) {
            var values = this.values;
            var destination = this.destination;
            var project = this.project;
            var args = [value].concat(values);
            if (project) {
                var result = _utilTryCatch2['default'](this.project).apply(this, args);
                if (result === _utilErrorObject.errorObject) {
                    destination.error(result.e);
                } else {
                    destination.next(result);
                }
            } else {
                destination.next(args);
            }
        }
    };

    return WithLatestFromSubscriber;
})(_OuterSubscriber3['default']);

module.exports = exports['default'];
},{"../OuterSubscriber":5,"../util/errorObject":128,"../util/subscribeToResult":134,"../util/tryCatch":136}],103:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = zip;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _observablesArrayObservable = require('../observables/ArrayObservable');

var _observablesArrayObservable2 = _interopRequireDefault(_observablesArrayObservable);

var _zipSupport = require('./zip-support');

function zip() {
    for (var _len = arguments.length, observables = Array(_len), _key = 0; _key < _len; _key++) {
        observables[_key] = arguments[_key];
    }

    var project = observables[observables.length - 1];
    if (typeof project === "function") {
        observables.pop();
    }
    return new _observablesArrayObservable2['default'](observables).lift(new _zipSupport.ZipOperator(project));
}

module.exports = exports['default'];
},{"../observables/ArrayObservable":10,"./zip-support":104}],104:[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _utilTryCatch = require('../util/tryCatch');

var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

var _utilErrorObject = require('../util/errorObject');

var _OuterSubscriber2 = require('../OuterSubscriber');

var _OuterSubscriber3 = _interopRequireDefault(_OuterSubscriber2);

var _utilSubscribeToResult = require('../util/subscribeToResult');

var _utilSubscribeToResult2 = _interopRequireDefault(_utilSubscribeToResult);

var ZipOperator = (function () {
    function ZipOperator(project) {
        _classCallCheck(this, ZipOperator);

        this.project = project;
    }

    ZipOperator.prototype.call = function call(subscriber) {
        return new ZipSubscriber(subscriber, this.project);
    };

    return ZipOperator;
})();

exports.ZipOperator = ZipOperator;

var ZipSubscriber = (function (_OuterSubscriber) {
    _inherits(ZipSubscriber, _OuterSubscriber);

    function ZipSubscriber(destination, project) {
        var values = arguments.length <= 2 || arguments[2] === undefined ? Object.create(null) : arguments[2];

        _classCallCheck(this, ZipSubscriber);

        _OuterSubscriber.call(this, destination);
        this.active = 0;
        this.observables = [];
        this.buffers = [];
        this.project = typeof project === "function" ? project : null;
        this.values = values;
    }

    ZipSubscriber.prototype._next = function _next(observable) {
        this.buffers.push([]);
        this.observables.push(observable);
    };

    ZipSubscriber.prototype._complete = function _complete() {
        var values = this.values;
        var observables = this.observables;
        var index = -1;
        var len = observables.length;
        this.active = len;
        while (++index < len) {
            var observable = observables[index];
            this.add(_utilSubscribeToResult2['default'](this, observable, observable, index));
        }
    };

    ZipSubscriber.prototype.notifyNext = function notifyNext(value, observable, index, observableIndex) {
        var buffers = this.buffers;
        buffers[observableIndex].push(value);
        var len = buffers.length;
        for (var i = 0; i < len; i++) {
            if (buffers[i].length === 0) {
                return;
            }
        }
        var args = [];
        var destination = this.destination;
        var project = this.project;
        for (var i = 0; i < len; i++) {
            args.push(buffers[i].shift());
        }
        if (project) {
            var result = _utilTryCatch2['default'](project).apply(this, args);
            if (result === _utilErrorObject.errorObject) {
                destination.error(_utilErrorObject.errorObject.e);
            } else {
                destination.next(result);
            }
        } else {
            destination.next(args);
        }
    };

    ZipSubscriber.prototype.notifyComplete = function notifyComplete() {
        if ((this.active -= 1) === 0) {
            this.destination.complete();
        }
    };

    return ZipSubscriber;
})(_OuterSubscriber3['default']);

exports.ZipSubscriber = ZipSubscriber;
},{"../OuterSubscriber":5,"../util/errorObject":128,"../util/subscribeToResult":134,"../util/tryCatch":136}],105:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = zipProto;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _zipStatic = require('./zip-static');

var _zipStatic2 = _interopRequireDefault(_zipStatic);

function zipProto() {
    for (var _len = arguments.length, observables = Array(_len), _key = 0; _key < _len; _key++) {
        observables[_key] = arguments[_key];
    }

    observables.unshift(this);
    return _zipStatic2['default'].apply(this, observables);
}

module.exports = exports['default'];
},{"./zip-static":103}],106:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = zipAll;

var _zipSupport = require('./zip-support');

function zipAll(project) {
    return this.lift(new _zipSupport.ZipOperator(project));
}

module.exports = exports['default'];
},{"./zip-support":104}],107:[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _ImmediateAction2 = require('./ImmediateAction');

var _ImmediateAction3 = _interopRequireDefault(_ImmediateAction2);

var FutureAction = (function (_ImmediateAction) {
    _inherits(FutureAction, _ImmediateAction);

    function FutureAction(scheduler, work) {
        _classCallCheck(this, FutureAction);

        _ImmediateAction.call(this, scheduler, work);
        this.scheduler = scheduler;
        this.work = work;
    }

    FutureAction.prototype.schedule = function schedule(state) {
        var _this = this;

        var delay = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

        if (this.isUnsubscribed) {
            return this;
        }
        this.delay = delay;
        this.state = state;
        var id = this.id;
        if (id != null) {
            this.id = undefined;
            clearTimeout(id);
        }
        var scheduler = this.scheduler;
        this.id = setTimeout(function () {
            _this.id = void 0;
            scheduler.actions.push(_this);
            scheduler.flush();
        }, this.delay);
        return this;
    };

    FutureAction.prototype.unsubscribe = function unsubscribe() {
        var id = this.id;
        if (id != null) {
            this.id = void 0;
            clearTimeout(id);
        }
        _ImmediateAction.prototype.unsubscribe.call(this);
    };

    return FutureAction;
})(_ImmediateAction3['default']);

exports['default'] = FutureAction;
module.exports = exports['default'];
},{"./ImmediateAction":108}],108:[function(require,module,exports){
"use strict";

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _Subscription2 = require('../Subscription');

var _Subscription3 = _interopRequireDefault(_Subscription2);

var ImmediateAction = (function (_Subscription) {
    _inherits(ImmediateAction, _Subscription);

    function ImmediateAction(scheduler, work) {
        _classCallCheck(this, ImmediateAction);

        _Subscription.call(this);
        this.scheduler = scheduler;
        this.work = work;
    }

    ImmediateAction.prototype.schedule = function schedule(state) {
        if (this.isUnsubscribed) {
            return this;
        }
        this.state = state;
        var scheduler = this.scheduler;
        scheduler.actions.push(this);
        scheduler.flush();
        return this;
    };

    ImmediateAction.prototype.execute = function execute() {
        if (this.isUnsubscribed) {
            throw new Error("How did did we execute a canceled Action?");
        }
        this.work(this.state);
    };

    ImmediateAction.prototype.unsubscribe = function unsubscribe() {
        var scheduler = this.scheduler;
        var actions = scheduler.actions;
        var index = actions.indexOf(this);
        this.work = void 0;
        this.state = void 0;
        this.scheduler = void 0;
        if (index !== -1) {
            actions.splice(index, 1);
        }
        _Subscription.prototype.unsubscribe.call(this);
    };

    return ImmediateAction;
})(_Subscription3["default"]);

exports["default"] = ImmediateAction;
module.exports = exports["default"];
},{"../Subscription":9}],109:[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _ImmediateAction = require('./ImmediateAction');

var _ImmediateAction2 = _interopRequireDefault(_ImmediateAction);

var _FutureAction = require('./FutureAction');

var _FutureAction2 = _interopRequireDefault(_FutureAction);

var ImmediateScheduler = (function () {
    function ImmediateScheduler() {
        _classCallCheck(this, ImmediateScheduler);

        this.actions = [];
        this.active = false;
        this.scheduled = false;
    }

    ImmediateScheduler.prototype.now = function now() {
        return Date.now();
    };

    ImmediateScheduler.prototype.flush = function flush() {
        if (this.active || this.scheduled) {
            return;
        }
        this.active = true;
        var actions = this.actions;
        for (var action = undefined; action = actions.shift();) {
            action.execute();
        }
        this.active = false;
    };

    ImmediateScheduler.prototype.schedule = function schedule(work, delay, state) {
        if (delay === undefined) delay = 0;

        return delay <= 0 ? this.scheduleNow(work, state) : this.scheduleLater(work, delay, state);
    };

    ImmediateScheduler.prototype.scheduleNow = function scheduleNow(work, state) {
        return new _ImmediateAction2['default'](this, work).schedule(state);
    };

    ImmediateScheduler.prototype.scheduleLater = function scheduleLater(work, delay, state) {
        return new _FutureAction2['default'](this, work).schedule(state, delay);
    };

    return ImmediateScheduler;
})();

exports['default'] = ImmediateScheduler;
module.exports = exports['default'];
},{"./FutureAction":107,"./ImmediateAction":108}],110:[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _utilImmediate = require('../util/Immediate');

var _ImmediateAction2 = require('./ImmediateAction');

var _ImmediateAction3 = _interopRequireDefault(_ImmediateAction2);

var NextTickAction = (function (_ImmediateAction) {
    _inherits(NextTickAction, _ImmediateAction);

    function NextTickAction() {
        _classCallCheck(this, NextTickAction);

        _ImmediateAction.apply(this, arguments);
    }

    NextTickAction.prototype.schedule = function schedule(state) {
        var _this = this;

        if (this.isUnsubscribed) {
            return this;
        }
        this.state = state;
        var scheduler = this.scheduler;
        scheduler.actions.push(this);
        if (!scheduler.scheduled) {
            scheduler.scheduled = true;
            this.id = _utilImmediate.Immediate.setImmediate(function () {
                _this.id = void 0;
                _this.scheduler.scheduled = false;
                _this.scheduler.flush();
            });
        }
        return this;
    };

    NextTickAction.prototype.unsubscribe = function unsubscribe() {
        var id = this.id;
        var scheduler = this.scheduler;
        _ImmediateAction.prototype.unsubscribe.call(this);
        if (scheduler.actions.length === 0) {
            scheduler.active = false;
            scheduler.scheduled = false;
            if (id) {
                this.id = void 0;
                _utilImmediate.Immediate.clearImmediate(id);
            }
        }
    };

    return NextTickAction;
})(_ImmediateAction3['default']);

exports['default'] = NextTickAction;
module.exports = exports['default'];
},{"../util/Immediate":123,"./ImmediateAction":108}],111:[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _ImmediateScheduler2 = require('./ImmediateScheduler');

var _ImmediateScheduler3 = _interopRequireDefault(_ImmediateScheduler2);

var _NextTickAction = require('./NextTickAction');

var _NextTickAction2 = _interopRequireDefault(_NextTickAction);

var _ImmediateAction = require('./ImmediateAction');

var _ImmediateAction2 = _interopRequireDefault(_ImmediateAction);

var NextTickScheduler = (function (_ImmediateScheduler) {
    _inherits(NextTickScheduler, _ImmediateScheduler);

    function NextTickScheduler() {
        _classCallCheck(this, NextTickScheduler);

        _ImmediateScheduler.apply(this, arguments);
    }

    NextTickScheduler.prototype.scheduleNow = function scheduleNow(work, state) {
        return (this.scheduled ? new _ImmediateAction2['default'](this, work) : new _NextTickAction2['default'](this, work)).schedule(state);
    };

    return NextTickScheduler;
})(_ImmediateScheduler3['default']);

exports['default'] = NextTickScheduler;
module.exports = exports['default'];
},{"./ImmediateAction":108,"./ImmediateScheduler":109,"./NextTickAction":110}],112:[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _Observable = require('../Observable');

var _Observable2 = _interopRequireDefault(_Observable);

var _VirtualTimeScheduler2 = require('./VirtualTimeScheduler');

var _VirtualTimeScheduler3 = _interopRequireDefault(_VirtualTimeScheduler2);

var _Notification = require('../Notification');

var _Notification2 = _interopRequireDefault(_Notification);

var _Subject = require('../Subject');

var _Subject2 = _interopRequireDefault(_Subject);

var TestScheduler = (function (_VirtualTimeScheduler) {
    _inherits(TestScheduler, _VirtualTimeScheduler);

    function TestScheduler(assertDeepEqual) {
        _classCallCheck(this, TestScheduler);

        _VirtualTimeScheduler.call(this);
        this.assertDeepEqual = assertDeepEqual;
        this.hotObservables = [];
        this.flushTests = [];
    }

    TestScheduler.prototype.createColdObservable = function createColdObservable(marbles, values, error) {
        var _this = this;

        if (marbles.indexOf('^') !== -1) {
            throw new Error('cold observable cannot have subscription offset "^"');
        }
        var messages = TestScheduler.parseMarbles(marbles, values, error);
        return _Observable2['default'].create(function (subscriber) {
            messages.forEach(function (_ref) {
                var notification = _ref.notification;
                var frame = _ref.frame;

                subscriber.add(_this.schedule(function () {
                    notification.observe(subscriber);
                }, frame));
            }, _this);
        });
    };

    TestScheduler.prototype.createHotObservable = function createHotObservable(marbles, values, error) {
        var messages = TestScheduler.parseMarbles(marbles, values, error);
        var subject = new _Subject2['default']();
        this.hotObservables.push({
            setup: function setup(scheduler) {
                messages.forEach(function (_ref2) {
                    var notification = _ref2.notification;
                    var frame = _ref2.frame;

                    scheduler.schedule(function () {
                        notification.observe(subject);
                    }, frame);
                });
            },
            subject: subject
        });
        return subject;
    };

    TestScheduler.prototype.expect = function expect(observable) {
        var _this2 = this;

        var actual = [];
        var flushTest = {
            observable: observable, actual: actual, marbles: null, ready: false
        };
        this.schedule(function () {
            observable.subscribe(function (value) {
                actual.push({ frame: _this2.frame, notification: _Notification2['default'].createNext(value) });
            }, function (err) {
                actual.push({ frame: _this2.frame, notification: _Notification2['default'].createError(err) });
            }, function () {
                actual.push({ frame: _this2.frame, notification: _Notification2['default'].createComplete() });
            });
        }, 0);
        this.flushTests.push(flushTest);
        return {
            toBe: function toBe(marbles, values, errorValue) {
                flushTest.ready = true;
                flushTest.marbles = marbles;
                flushTest.expected = TestScheduler.parseMarbles(marbles, values, errorValue);
            }
        };
    };

    TestScheduler.prototype.flush = function flush() {
        var hotObservables = this.hotObservables;
        while (hotObservables.length > 0) {
            hotObservables.shift().setup(this);
        }
        _VirtualTimeScheduler.prototype.flush.call(this);
        var flushTests = this.flushTests.filter(function (test) {
            return test.ready;
        });
        while (flushTests.length > 0) {
            var test = flushTests.shift();
            test.actual.sort(function (a, b) {
                return a.frame === b.frame ? 0 : a.frame > b.frame ? 1 : -1;
            });
            this.assertDeepEqual(test.actual, test.expected);
        }
    };

    TestScheduler.parseMarbles = function parseMarbles(marbles, values, errorValue) {
        var len = marbles.length;
        var results = [];
        var subIndex = marbles.indexOf('^');
        var frameOffset = subIndex === -1 ? 0 : subIndex * -this.frameTimeFactor;
        var getValue = typeof values !== 'object' ? function (x) {
            return x;
        } : function (x) {
            return values[x];
        };
        var groupStart = -1;
        for (var i = 0; i < len; i++) {
            var frame = i * this.frameTimeFactor;
            var notification = undefined;
            var c = marbles[i];
            switch (c) {
                case '-':
                    break;
                case '(':
                    groupStart = frame;
                    break;
                case ')':
                    groupStart = -1;
                    break;
                case '|':
                    notification = _Notification2['default'].createComplete();
                    break;
                case '^':
                    break;
                case '#':
                    notification = _Notification2['default'].createError(errorValue || 'error');
                    break;
                default:
                    notification = _Notification2['default'].createNext(getValue(c));
                    break;
            }
            frame += frameOffset;
            if (notification) {
                results.push({ frame: groupStart > -1 ? groupStart : frame, notification: notification });
            }
        }
        return results;
    };

    return TestScheduler;
})(_VirtualTimeScheduler3['default']);

exports['default'] = TestScheduler;
module.exports = exports['default'];
},{"../Notification":3,"../Observable":4,"../Subject":7,"./VirtualTimeScheduler":113}],113:[function(require,module,exports){
"use strict";

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _Subscription2 = require('../Subscription');

var _Subscription3 = _interopRequireDefault(_Subscription2);

var VirtualTimeScheduler = (function () {
    function VirtualTimeScheduler() {
        _classCallCheck(this, VirtualTimeScheduler);

        this.actions = [];
        this.active = false;
        this.scheduled = false;
        this.index = 0;
        this.sorted = false;
        this.frame = 0;
        this.maxFrames = 750;
    }

    VirtualTimeScheduler.prototype.now = function now() {
        return this.frame * VirtualTimeScheduler.frameTimeFactor;
    };

    VirtualTimeScheduler.prototype.flush = function flush() {
        var actions = this.actions;
        var maxFrames = this.maxFrames;
        while (actions.length > 0) {
            var action = actions.shift();
            this.frame = action.delay;
            if (this.frame <= maxFrames) {
                action.execute();
            } else {
                break;
            }
        }
        actions.length = 0;
        this.frame = 0;
    };

    VirtualTimeScheduler.prototype.addAction = function addAction(action) {
        var findDelay = action.delay;
        var actions = this.actions;
        var len = actions.length;
        var vaction = action;
        actions.push(action);
        actions.sort(function (a, b) {
            return a.delay === b.delay ? a.index === b.index ? 0 : a.index > b.index ? 1 : -1 : a.delay > b.delay ? 1 : -1;
        });
    };

    VirtualTimeScheduler.prototype.schedule = function schedule(work, delay, state) {
        if (delay === undefined) delay = 0;

        this.sorted = false;
        return new VirtualAction(this, work, this.index++).schedule(state, delay);
    };

    return VirtualTimeScheduler;
})();

exports["default"] = VirtualTimeScheduler;

VirtualTimeScheduler.frameTimeFactor = 10;

var VirtualAction = (function (_Subscription) {
    _inherits(VirtualAction, _Subscription);

    function VirtualAction(scheduler, work, index) {
        _classCallCheck(this, VirtualAction);

        _Subscription.call(this);
        this.scheduler = scheduler;
        this.work = work;
        this.index = index;
    }

    VirtualAction.prototype.schedule = function schedule(state) {
        var delay = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

        if (this.isUnsubscribed) {
            return this;
        }
        var scheduler = this.scheduler;
        var action = scheduler.frame === this.delay ? this : new VirtualAction(scheduler, this.work, scheduler.index += 1);
        action.state = state;
        action.delay = scheduler.frame + delay;
        scheduler.addAction(action);
        return this;
    };

    VirtualAction.prototype.execute = function execute() {
        if (this.isUnsubscribed) {
            throw new Error("How did did we execute a canceled Action?");
        }
        this.work(this.state);
    };

    VirtualAction.prototype.unsubscribe = function unsubscribe() {
        var scheduler = this.scheduler;
        var actions = scheduler.actions;
        var index = actions.indexOf(this);
        this.work = void 0;
        this.state = void 0;
        this.scheduler = void 0;
        if (index !== -1) {
            actions.splice(index, 1);
        }
        _Subscription.prototype.unsubscribe.call(this);
    };

    return VirtualAction;
})(_Subscription3["default"]);

module.exports = exports["default"];
},{"../Subscription":9}],114:[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _ImmediateScheduler = require('./ImmediateScheduler');

var _ImmediateScheduler2 = _interopRequireDefault(_ImmediateScheduler);

exports['default'] = new _ImmediateScheduler2['default']();
module.exports = exports['default'];
},{"./ImmediateScheduler":109}],115:[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _NextTickScheduler = require('./NextTickScheduler');

var _NextTickScheduler2 = _interopRequireDefault(_NextTickScheduler);

exports['default'] = new _NextTickScheduler2['default']();
module.exports = exports['default'];
},{"./NextTickScheduler":111}],116:[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _Subject2 = require('../Subject');

var _Subject3 = _interopRequireDefault(_Subject2);

var BehaviorSubject = (function (_Subject) {
    _inherits(BehaviorSubject, _Subject);

    function BehaviorSubject(value) {
        _classCallCheck(this, BehaviorSubject);

        _Subject.call(this);
        this.value = value;
    }

    BehaviorSubject.prototype._subscribe = function _subscribe(subscriber) {
        var subscription = _Subject.prototype._subscribe.call(this, subscriber);
        if (!subscription) {
            return;
        } else if (!subscription.isUnsubscribed) {
            subscriber.next(this.value);
        }
        return subscription;
    };

    BehaviorSubject.prototype._next = function _next(value) {
        _Subject.prototype._next.call(this, this.value = value);
    };

    return BehaviorSubject;
})(_Subject3['default']);

exports['default'] = BehaviorSubject;
module.exports = exports['default'];
},{"../Subject":7}],117:[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _Subject2 = require('../Subject');

var _Subject3 = _interopRequireDefault(_Subject2);

var GroupSubject = (function (_Subject) {
    _inherits(GroupSubject, _Subject);

    function GroupSubject(key) {
        _classCallCheck(this, GroupSubject);

        _Subject.call(this);
        this.key = key;
    }

    return GroupSubject;
})(_Subject3['default']);

exports['default'] = GroupSubject;
module.exports = exports['default'];
},{"../Subject":7}],118:[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _Subject2 = require('../Subject');

var _Subject3 = _interopRequireDefault(_Subject2);

var _schedulersImmediate = require('../schedulers/immediate');

var _schedulersImmediate2 = _interopRequireDefault(_schedulersImmediate);

var ReplaySubject = (function (_Subject) {
    _inherits(ReplaySubject, _Subject);

    function ReplaySubject(bufferSize, _windowTime, scheduler) {
        if (bufferSize === undefined) bufferSize = Number.POSITIVE_INFINITY;
        if (_windowTime === undefined) _windowTime = Number.POSITIVE_INFINITY;

        _classCallCheck(this, ReplaySubject);

        _Subject.call(this);
        this.events = [];
        this.bufferSize = bufferSize < 1 ? 1 : bufferSize;
        this._windowTime = _windowTime < 1 ? 1 : _windowTime;
        this.scheduler = scheduler;
    }

    ReplaySubject.prototype._next = function _next(value) {
        var now = this._getNow();
        this.events.push(new ReplayEvent(now, value));
        this._getEvents(now);
        _Subject.prototype._next.call(this, value);
    };

    ReplaySubject.prototype._subscribe = function _subscribe(subscriber) {
        var events = this._getEvents(this._getNow());
        var index = -1;
        var len = events.length;
        while (!subscriber.isUnsubscribed && ++index < len) {
            subscriber.next(events[index].value);
        }
        return _Subject.prototype._subscribe.call(this, subscriber);
    };

    ReplaySubject.prototype._getNow = function _getNow() {
        return (this.scheduler || _schedulersImmediate2['default']).now();
    };

    ReplaySubject.prototype._getEvents = function _getEvents(now) {
        var bufferSize = this.bufferSize;
        var _windowTime = this._windowTime;
        var events = this.events;
        var eventsCount = events.length;
        var spliceCount = 0;
        // Trim events that fall out of the time window.
        // Start at the front of the list. Break early once
        // we encounter an event that falls within the window.
        while (spliceCount < eventsCount) {
            if (now - events[spliceCount].time < _windowTime) {
                break;
            }
            spliceCount += 1;
        }
        if (eventsCount > bufferSize) {
            spliceCount = Math.max(spliceCount, eventsCount - bufferSize);
        }
        if (spliceCount > 0) {
            events.splice(0, spliceCount);
        }
        return events;
    };

    return ReplaySubject;
})(_Subject3['default']);

exports['default'] = ReplaySubject;

var ReplayEvent = function ReplayEvent(time, value) {
    _classCallCheck(this, ReplayEvent);

    this.time = time;
    this.value = value;
};

module.exports = exports['default'];
},{"../Subject":7,"../schedulers/immediate":114}],119:[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _Subscription2 = require('../Subscription');

var _Subscription3 = _interopRequireDefault(_Subscription2);

var SubjectSubscription = (function (_Subscription) {
    _inherits(SubjectSubscription, _Subscription);

    function SubjectSubscription(subject, observer) {
        _classCallCheck(this, SubjectSubscription);

        _Subscription.call(this);
        this.subject = subject;
        this.observer = observer;
        this.isUnsubscribed = false;
    }

    SubjectSubscription.prototype.unsubscribe = function unsubscribe() {
        if (this.isUnsubscribed) {
            return;
        }
        this.isUnsubscribed = true;
        var subject = this.subject;
        var observers = subject.observers;
        this.subject = void 0;
        if (!observers || observers.length === 0 || subject.isUnsubscribed) {
            return;
        }
        var subscriberIndex = observers.indexOf(this.observer);
        if (subscriberIndex !== -1) {
            observers.splice(subscriberIndex, 1);
        }
    };

    return SubjectSubscription;
})(_Subscription3['default']);

exports['default'] = SubjectSubscription;
module.exports = exports['default'];
},{"../Subscription":9}],120:[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var ArgumentOutOfRangeError = function ArgumentOutOfRangeError() {
    _classCallCheck(this, ArgumentOutOfRangeError);

    this.name = 'ArgumentOutOfRangeError';
    this.message = 'argument out of range';
};

exports['default'] = ArgumentOutOfRangeError;
module.exports = exports['default'];
},{}],121:[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var EmptyError = function EmptyError() {
    _classCallCheck(this, EmptyError);

    this.name = 'EmptyError';
    this.message = 'no elements in sequence';
};

exports['default'] = EmptyError;
module.exports = exports['default'];
},{}],122:[function(require,module,exports){
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var FastMap = (function () {
    function FastMap() {
        _classCallCheck(this, FastMap);

        this.size = 0;
        this._values = {};
    }

    FastMap.prototype["delete"] = function _delete(key) {
        this._values[key] = null;
        return true;
    };

    FastMap.prototype.set = function set(key, value) {
        this._values[key] = value;
        return this;
    };

    FastMap.prototype.get = function get(key) {
        return this._values[key];
    };

    FastMap.prototype.forEach = function forEach(cb, thisArg) {
        var values = this._values;
        for (var key in values) {
            if (values.hasOwnProperty(key)) {
                cb.call(thisArg, values[key], key);
            }
        }
    };

    FastMap.prototype.clear = function clear() {
        this._values = {};
    };

    return FastMap;
})();

exports["default"] = FastMap;
module.exports = exports["default"];
},{}],123:[function(require,module,exports){
/**
All credit for this helper goes to http://github.com/YuzuJS/setImmediate
*/
"use strict";

exports.__esModule = true;

var _root = require('./root');

var Immediate = {
    setImmediate: function setImmediate(x) {
        return 0;
    },
    clearImmediate: function clearImmediate(id) {}
};
exports.Immediate = Immediate;
if (_root.root && _root.root.setImmediate) {
    Immediate.setImmediate = _root.root.setImmediate;
    Immediate.clearImmediate = _root.root.clearImmediate;
} else {
    exports.Immediate = Immediate = (function (global, Immediate) {
        var nextHandle = 1,
            // Spec says greater than zero
        tasksByHandle = {},
            currentlyRunningATask = false,
            doc = global.document,
            setImmediate;
        // Don't get fooled by e.g. browserify environments.
        if (({}).toString.call(global.process) === "[object process]") {
            // For Node.js before 0.9
            setImmediate = installNextTickImplementation();
        } else if (canUsePostMessage()) {
            // For non-IE10 modern browsers
            setImmediate = installPostMessageImplementation();
        } else if (global.MessageChannel) {
            // For web workers, where supported
            setImmediate = installMessageChannelImplementation();
        } else if (doc && "onreadystatechange" in doc.createElement("script")) {
            // For IE 68
            setImmediate = installReadyStateChangeImplementation();
        } else {
            // For older browsers
            setImmediate = installSetTimeoutImplementation();
        }
        Immediate.setImmediate = setImmediate;
        Immediate.clearImmediate = clearImmediate;
        return Immediate;
        function clearImmediate(handle) {
            delete tasksByHandle[handle];
        }
        function addFromSetImmediateArguments(args) {
            tasksByHandle[nextHandle] = partiallyApplied.apply(undefined, args);
            return nextHandle++;
        }
        // This function accepts the same arguments as setImmediate, but
        // returns a function that requires no arguments.
        function partiallyApplied(handler) {
            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
            }

            return function () {
                if (typeof handler === "function") {
                    handler.apply(undefined, args);
                } else {
                    new Function("" + handler)();
                }
            };
        }
        function runIfPresent(handle) {
            // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
            // So if we're currently running a task, we'll need to delay this invocation.
            if (currentlyRunningATask) {
                // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
                // "too much recursion" error.
                setTimeout(partiallyApplied(runIfPresent, handle), 0);
            } else {
                var task = tasksByHandle[handle];
                if (task) {
                    currentlyRunningATask = true;
                    try {
                        task();
                    } finally {
                        clearImmediate(handle);
                        currentlyRunningATask = false;
                    }
                }
            }
        }
        function installNextTickImplementation() {
            return function setImmediate() {
                var handle = addFromSetImmediateArguments(arguments);
                global.process.nextTick(partiallyApplied(runIfPresent, handle));
                return handle;
            };
        }
        function canUsePostMessage() {
            // The test against `importScripts` prevents this implementation from being installed inside a web worker,
            // where `global.postMessage` means something completely different and can't be used for this purpose.
            if (global.postMessage && !global.importScripts) {
                var postMessageIsAsynchronous = true;
                var oldOnMessage = global.onmessage;
                global.onmessage = function () {
                    postMessageIsAsynchronous = false;
                };
                global.postMessage("", "*");
                global.onmessage = oldOnMessage;
                return postMessageIsAsynchronous;
            }
        }
        function installPostMessageImplementation() {
            // Installs an event handler on `global` for the `message` event: see
            // * https://developer.mozilla.org/en/DOM/window.postMessage
            // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
            var messagePrefix = "setImmediate$" + Math.random() + "$";
            var onGlobalMessage = function onGlobalMessage(event) {
                if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
                    runIfPresent(+event.data.slice(messagePrefix.length));
                }
            };
            if (global.addEventListener) {
                global.addEventListener("message", onGlobalMessage, false);
            } else {
                global.attachEvent("onmessage", onGlobalMessage);
            }
            return function setImmediate() {
                var handle = addFromSetImmediateArguments(arguments);
                global.postMessage(messagePrefix + handle, "*");
                return handle;
            };
        }
        function installMessageChannelImplementation() {
            var channel = new MessageChannel();
            channel.port1.onmessage = function (event) {
                var handle = event.data;
                runIfPresent(handle);
            };
            return function setImmediate() {
                var handle = addFromSetImmediateArguments(arguments);
                channel.port2.postMessage(handle);
                return handle;
            };
        }
        function installReadyStateChangeImplementation() {
            var html = doc.documentElement;
            return function setImmediate() {
                var handle = addFromSetImmediateArguments(arguments);
                // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
                // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
                var script = doc.createElement("script");
                script.onreadystatechange = function () {
                    runIfPresent(handle);
                    script.onreadystatechange = null;
                    html.removeChild(script);
                    script = null;
                };
                html.appendChild(script);
                return handle;
            };
        }
        function installSetTimeoutImplementation() {
            return function setImmediate() {
                var handle = addFromSetImmediateArguments(arguments);
                setTimeout(partiallyApplied(runIfPresent, handle), 0);
                return handle;
            };
        }
    })(_root.root, Immediate);
}
},{"./root":133}],124:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _root = require('./root');

exports['default'] = _root.root.Map || (function () {
    function Map() {
        this.size = 0;
        this._values = [];
        this._keys = [];
    }
    Map.prototype['delete'] = function (key) {
        var i = this._keys.indexOf(key);
        if (i === -1) {
            return false;
        }
        this._values.splice(i, 1);
        this._keys.splice(i, 1);
        this.size--;
        return true;
    };
    Map.prototype.get = function (key) {
        var i = this._keys.indexOf(key);
        return i === -1 ? undefined : this._values[i];
    };
    Map.prototype.set = function (key, value) {
        var i = this._keys.indexOf(key);
        if (i === -1) {
            this._keys.push(key);
            this._values.push(value);
            this.size++;
        } else {
            this._values[i] = value;
        }
        return this;
    };
    Map.prototype.forEach = function (cb, thisArg) {
        for (var i = 0; i < this.size; i++) {
            cb.call(thisArg, this._values[i], this._keys[i]);
        }
    };
    return Map;
})();

module.exports = exports['default'];
},{"./root":133}],125:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _root = require('./root');

if (!_root.root.Symbol) {
    _root.root.Symbol = {};
}
if (!_root.root.Symbol.iterator) {
    if (typeof _root.root.Symbol['for'] === 'function') {
        _root.root.Symbol.iterator = _root.root.Symbol['for']('iterator');
    } else if (_root.root.Set && typeof new _root.root.Set()['@@iterator'] === 'function') {
        _root.root.Symbol.iterator = '@@iterator';
    } else {
        _root.root.Symbol.iterator = '_es6shim_iterator_';
    }
}
exports['default'] = _root.root.Symbol.iterator;

// // Shim in iterator support
// export var $iterator$ = (typeof Symbol === 'function' && Symbol.iterator) || '_es6shim_iterator_';
// // Bug for mozilla version
// if (root.Set && typeof new root.Set()['@@iterator'] === 'function') {
//     $iterator$ = '@@iterator';
// }
module.exports = exports['default'];
},{"./root":133}],126:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _root = require('./root');

if (!_root.root.Symbol) {
    _root.root.Symbol = {};
}
if (!_root.root.Symbol.observable) {
    if (typeof _root.root.Symbol['for'] === 'function') {
        _root.root.Symbol.observable = _root.root.Symbol['for']('observable');
    } else {
        _root.root.Symbol.observable = '@@observable';
    }
}
exports['default'] = _root.root.Symbol.observable;
module.exports = exports['default'];
},{"./root":133}],127:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = bindCallback;

function bindCallback(func, thisArg, argCount) {
    if (typeof thisArg === 'undefined') {
        return func;
    }
    switch (argCount) {
        case 0:
            return function () {
                return func.call(thisArg);
            };
        case 1:
            return function (arg) {
                return func.call(thisArg, arg);
            };
        case 2:
            return function (value, index) {
                return func.call(thisArg, value, index);
            };
        case 3:
            return function (value, index, collection) {
                return func.call(thisArg, value, index, collection);
            };
    }
    return function () {
        return func.apply(thisArg, arguments);
    };
}

;
module.exports = exports['default'];
},{}],128:[function(require,module,exports){
"use strict";

exports.__esModule = true;
var errorObject = { e: {} };
exports.errorObject = errorObject;
},{}],129:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports["default"] = isDate;

function isDate(value) {
    return value instanceof Date && !isNaN(+value);
}

module.exports = exports["default"];
},{}],130:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports["default"] = isNumeric;
var is_array = Array.isArray;

function isNumeric(val) {
    // parseFloat NaNs numeric-cast false positives (null|true|false|"")
    // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
    // subtraction forces infinities to NaN
    // adding 1 corrects loss of precision from parseFloat (#15100)
    return !is_array(val) && val - parseFloat(val) + 1 >= 0;
}

;
module.exports = exports["default"];
},{}],131:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports["default"] = noop;

function noop() {}

module.exports = exports["default"];
},{}],132:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports["default"] = not;

function not(pred, thisArg) {
    function notPred() {
        return !notPred.pred.apply(notPred.thisArg, arguments);
    }
    notPred.pred = pred;
    notPred.thisArg = thisArg;
    return notPred;
}

module.exports = exports["default"];
},{}],133:[function(require,module,exports){
(function (global){
'use strict';

exports.__esModule = true;
var objectTypes = {
    'boolean': false,
    'function': true,
    'object': true,
    'number': false,
    'string': false,
    'undefined': false
};
var root = objectTypes[typeof self] && self || objectTypes[typeof window] && window;
exports.root = root;
var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
var freeGlobal = objectTypes[typeof global] && global;
if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
    exports.root = root = freeGlobal;
}
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],134:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = subscribeToResult;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _Observable = require('../Observable');

var _Observable2 = _interopRequireDefault(_Observable);

var _utilSymbol_iterator = require('../util/Symbol_iterator');

var _utilSymbol_iterator2 = _interopRequireDefault(_utilSymbol_iterator);

var _utilSymbol_observable = require('../util/Symbol_observable');

var _utilSymbol_observable2 = _interopRequireDefault(_utilSymbol_observable);

var _InnerSubscriber = require('../InnerSubscriber');

var _InnerSubscriber2 = _interopRequireDefault(_InnerSubscriber);

var isArray = Array.isArray;

function subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {
    var destination = new _InnerSubscriber2['default'](outerSubscriber, outerValue, outerIndex);
    if (destination.isUnsubscribed) {
        return;
    }
    if (result instanceof _Observable2['default']) {
        if (result._isScalar) {
            destination.next(result.value);
            destination.complete();
            return;
        } else {
            return result.subscribe(destination);
        }
    }
    if (isArray(result)) {
        for (var i = 0, len = result.length; i < len && !destination.isUnsubscribed; i++) {
            destination.next(result[i]);
        }
        if (!destination.isUnsubscribed) {
            destination.complete();
        }
    } else if (typeof result.then === 'function') {
        result.then(function (x) {
            if (!destination.isUnsubscribed) {
                destination.next(x);
                destination.complete();
            }
        }, function (err) {
            return destination.error(err);
        }).then(null, function (err) {
            // Escaping the Promise trap: globally throw unhandled errors
            setTimeout(function () {
                throw err;
            });
        });
        return destination;
    } else if (typeof result[_utilSymbol_iterator2['default']] === 'function') {
        for (var _iterator = result, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
            var _ref;

            if (_isArray) {
                if (_i >= _iterator.length) break;
                _ref = _iterator[_i++];
            } else {
                _i = _iterator.next();
                if (_i.done) break;
                _ref = _i.value;
            }

            var item = _ref;

            destination.next(item);
            if (destination.isUnsubscribed) {
                break;
            }
        }
        if (!destination.isUnsubscribed) {
            destination.complete();
        }
    } else if (typeof result[_utilSymbol_observable2['default']] === 'function') {
        var obs = result[_utilSymbol_observable2['default']]();
        if (typeof obs.subscribe !== 'function') {
            destination.error('invalid observable');
        } else {
            return obs.subscribe(new _InnerSubscriber2['default'](outerSubscriber, outerValue, outerIndex));
        }
    } else {
        destination.error(new TypeError('unknown type returned'));
    }
}

module.exports = exports['default'];
},{"../InnerSubscriber":2,"../Observable":4,"../util/Symbol_iterator":125,"../util/Symbol_observable":126}],135:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports["default"] = throwError;

function throwError(e) {
  throw e;
}

module.exports = exports["default"];
},{}],136:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = tryCatch;

var _errorObject = require('./errorObject');

var tryCatchTarget;
function tryCatcher() {
    try {
        return tryCatchTarget.apply(this, arguments);
    } catch (e) {
        _errorObject.errorObject.e = e;
        return _errorObject.errorObject;
    }
}

function tryCatch(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
}

;
module.exports = exports['default'];
},{"./errorObject":128}],137:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports["default"] = tryOrOnError;

function tryOrOnError(target) {
    function tryCatcher() {
        try {
            tryCatcher.target.apply(this, arguments);
        } catch (e) {
            this.error(e);
        }
    }
    tryCatcher.target = target;
    return tryCatcher;
}

module.exports = exports["default"];
},{}],138:[function(require,module,exports){
module.exports = require('./dist/cjs/Rx');

},{"./dist/cjs/Rx":6}],139:[function(require,module,exports){
(function (global){
((typeof define === "function" && define.amd && function (m) {
    define("formatio", ["samsam"], m);
}) || (typeof module === "object" && function (m) {
    module.exports = m(require("samsam"));
}) || function (m) { this.formatio = m(this.samsam); }
)(function (samsam) {
    "use strict";

    var formatio = {
        excludeConstructors: ["Object", /^.$/],
        quoteStrings: true,
        limitChildrenCount: 0
    };

    var hasOwn = Object.prototype.hasOwnProperty;

    var specialObjects = [];
    if (typeof global !== "undefined") {
        specialObjects.push({ object: global, value: "[object global]" });
    }
    if (typeof document !== "undefined") {
        specialObjects.push({
            object: document,
            value: "[object HTMLDocument]"
        });
    }
    if (typeof window !== "undefined") {
        specialObjects.push({ object: window, value: "[object Window]" });
    }

    function functionName(func) {
        if (!func) { return ""; }
        if (func.displayName) { return func.displayName; }
        if (func.name) { return func.name; }
        var matches = func.toString().match(/function\s+([^\(]+)/m);
        return (matches && matches[1]) || "";
    }

    function constructorName(f, object) {
        var name = functionName(object && object.constructor);
        var excludes = f.excludeConstructors ||
                formatio.excludeConstructors || [];

        var i, l;
        for (i = 0, l = excludes.length; i < l; ++i) {
            if (typeof excludes[i] === "string" && excludes[i] === name) {
                return "";
            } else if (excludes[i].test && excludes[i].test(name)) {
                return "";
            }
        }

        return name;
    }

    function isCircular(object, objects) {
        if (typeof object !== "object") { return false; }
        var i, l;
        for (i = 0, l = objects.length; i < l; ++i) {
            if (objects[i] === object) { return true; }
        }
        return false;
    }

    function ascii(f, object, processed, indent) {
        if (typeof object === "string") {
            var qs = f.quoteStrings;
            var quote = typeof qs !== "boolean" || qs;
            return processed || quote ? '"' + object + '"' : object;
        }

        if (typeof object === "function" && !(object instanceof RegExp)) {
            return ascii.func(object);
        }

        processed = processed || [];

        if (isCircular(object, processed)) { return "[Circular]"; }

        if (Object.prototype.toString.call(object) === "[object Array]") {
            return ascii.array.call(f, object, processed);
        }

        if (!object) { return String((1/object) === -Infinity ? "-0" : object); }
        if (samsam.isElement(object)) { return ascii.element(object); }

        if (typeof object.toString === "function" &&
                object.toString !== Object.prototype.toString) {
            return object.toString();
        }

        var i, l;
        for (i = 0, l = specialObjects.length; i < l; i++) {
            if (object === specialObjects[i].object) {
                return specialObjects[i].value;
            }
        }

        return ascii.object.call(f, object, processed, indent);
    }

    ascii.func = function (func) {
        return "function " + functionName(func) + "() {}";
    };

    ascii.array = function (array, processed) {
        processed = processed || [];
        processed.push(array);
        var pieces = [];
        var i, l;
        l = (this.limitChildrenCount > 0) ? 
            Math.min(this.limitChildrenCount, array.length) : array.length;

        for (i = 0; i < l; ++i) {
            pieces.push(ascii(this, array[i], processed));
        }

        if(l < array.length)
            pieces.push("[... " + (array.length - l) + " more elements]");

        return "[" + pieces.join(", ") + "]";
    };

    ascii.object = function (object, processed, indent) {
        processed = processed || [];
        processed.push(object);
        indent = indent || 0;
        var pieces = [], properties = samsam.keys(object).sort();
        var length = 3;
        var prop, str, obj, i, k, l;
        l = (this.limitChildrenCount > 0) ? 
            Math.min(this.limitChildrenCount, properties.length) : properties.length;

        for (i = 0; i < l; ++i) {
            prop = properties[i];
            obj = object[prop];

            if (isCircular(obj, processed)) {
                str = "[Circular]";
            } else {
                str = ascii(this, obj, processed, indent + 2);
            }

            str = (/\s/.test(prop) ? '"' + prop + '"' : prop) + ": " + str;
            length += str.length;
            pieces.push(str);
        }

        var cons = constructorName(this, object);
        var prefix = cons ? "[" + cons + "] " : "";
        var is = "";
        for (i = 0, k = indent; i < k; ++i) { is += " "; }

        if(l < properties.length)
            pieces.push("[... " + (properties.length - l) + " more elements]");

        if (length + indent > 80) {
            return prefix + "{\n  " + is + pieces.join(",\n  " + is) + "\n" +
                is + "}";
        }
        return prefix + "{ " + pieces.join(", ") + " }";
    };

    ascii.element = function (element) {
        var tagName = element.tagName.toLowerCase();
        var attrs = element.attributes, attr, pairs = [], attrName, i, l, val;

        for (i = 0, l = attrs.length; i < l; ++i) {
            attr = attrs.item(i);
            attrName = attr.nodeName.toLowerCase().replace("html:", "");
            val = attr.nodeValue;
            if (attrName !== "contenteditable" || val !== "inherit") {
                if (!!val) { pairs.push(attrName + "=\"" + val + "\""); }
            }
        }

        var formatted = "<" + tagName + (pairs.length > 0 ? " " : "");
        var content = element.innerHTML;

        if (content.length > 20) {
            content = content.substr(0, 20) + "[...]";
        }

        var res = formatted + pairs.join(" ") + ">" + content +
                "</" + tagName + ">";

        return res.replace(/ contentEditable="inherit"/, "");
    };

    function Formatio(options) {
        for (var opt in options) {
            this[opt] = options[opt];
        }
    }

    Formatio.prototype = {
        functionName: functionName,

        configure: function (options) {
            return new Formatio(options);
        },

        constructorName: function (object) {
            return constructorName(this, object);
        },

        ascii: function (object, processed, indent) {
            return ascii(this, object, processed, indent);
        }
    };

    return Formatio.prototype;
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"samsam":143}],140:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],141:[function(require,module,exports){
(function (global){
/*global global, window*/
/**
 * @author Christian Johansen (christian@cjohansen.no) and contributors
 * @license BSD
 *
 * Copyright (c) 2010-2014 Christian Johansen
 */

(function (global) {
    "use strict";

    // Make properties writable in IE, as per
    // http://www.adequatelygood.com/Replacing-setTimeout-Globally.html
    // JSLint being anal
    var glbl = global;

    global.setTimeout = glbl.setTimeout;
    global.clearTimeout = glbl.clearTimeout;
    global.setInterval = glbl.setInterval;
    global.clearInterval = glbl.clearInterval;
    global.Date = glbl.Date;

    // setImmediate is not a standard function
    // avoid adding the prop to the window object if not present
    if('setImmediate' in global) {
        global.setImmediate = glbl.setImmediate;
        global.clearImmediate = glbl.clearImmediate;
    }

    // node expects setTimeout/setInterval to return a fn object w/ .ref()/.unref()
    // browsers, a number.
    // see https://github.com/cjohansen/Sinon.JS/pull/436

    var NOOP = function () { return undefined; };
    var timeoutResult = setTimeout(NOOP, 0);
    var addTimerReturnsObject = typeof timeoutResult === "object";
    clearTimeout(timeoutResult);

    var NativeDate = Date;
    var uniqueTimerId = 1;

    /**
     * Parse strings like "01:10:00" (meaning 1 hour, 10 minutes, 0 seconds) into
     * number of milliseconds. This is used to support human-readable strings passed
     * to clock.tick()
     */
    function parseTime(str) {
        if (!str) {
            return 0;
        }

        var strings = str.split(":");
        var l = strings.length, i = l;
        var ms = 0, parsed;

        if (l > 3 || !/^(\d\d:){0,2}\d\d?$/.test(str)) {
            throw new Error("tick only understands numbers and 'h:m:s'");
        }

        while (i--) {
            parsed = parseInt(strings[i], 10);

            if (parsed >= 60) {
                throw new Error("Invalid time " + str);
            }

            ms += parsed * Math.pow(60, (l - i - 1));
        }

        return ms * 1000;
    }

    /**
     * Used to grok the `now` parameter to createClock.
     */
    function getEpoch(epoch) {
        if (!epoch) { return 0; }
        if (typeof epoch.getTime === "function") { return epoch.getTime(); }
        if (typeof epoch === "number") { return epoch; }
        throw new TypeError("now should be milliseconds since UNIX epoch");
    }

    function inRange(from, to, timer) {
        return timer && timer.callAt >= from && timer.callAt <= to;
    }

    function mirrorDateProperties(target, source) {
        var prop;
        for (prop in source) {
            if (source.hasOwnProperty(prop)) {
                target[prop] = source[prop];
            }
        }

        // set special now implementation
        if (source.now) {
            target.now = function now() {
                return target.clock.now;
            };
        } else {
            delete target.now;
        }

        // set special toSource implementation
        if (source.toSource) {
            target.toSource = function toSource() {
                return source.toSource();
            };
        } else {
            delete target.toSource;
        }

        // set special toString implementation
        target.toString = function toString() {
            return source.toString();
        };

        target.prototype = source.prototype;
        target.parse = source.parse;
        target.UTC = source.UTC;
        target.prototype.toUTCString = source.prototype.toUTCString;

        return target;
    }

    function createDate() {
        function ClockDate(year, month, date, hour, minute, second, ms) {
            // Defensive and verbose to avoid potential harm in passing
            // explicit undefined when user does not pass argument
            switch (arguments.length) {
            case 0:
                return new NativeDate(ClockDate.clock.now);
            case 1:
                return new NativeDate(year);
            case 2:
                return new NativeDate(year, month);
            case 3:
                return new NativeDate(year, month, date);
            case 4:
                return new NativeDate(year, month, date, hour);
            case 5:
                return new NativeDate(year, month, date, hour, minute);
            case 6:
                return new NativeDate(year, month, date, hour, minute, second);
            default:
                return new NativeDate(year, month, date, hour, minute, second, ms);
            }
        }

        return mirrorDateProperties(ClockDate, NativeDate);
    }

    function addTimer(clock, timer) {
        if (timer.func === undefined) {
            throw new Error("Callback must be provided to timer calls");
        }

        if (!clock.timers) {
            clock.timers = {};
        }

        timer.id = uniqueTimerId++;
        timer.createdAt = clock.now;
        timer.callAt = clock.now + (timer.delay || (clock.duringTick ? 1 : 0));

        clock.timers[timer.id] = timer;

        if (addTimerReturnsObject) {
            return {
                id: timer.id,
                ref: NOOP,
                unref: NOOP
            };
        }

        return timer.id;
    }


    function compareTimers(a, b) {
        // Sort first by absolute timing
        if (a.callAt < b.callAt) {
            return -1;
        }
        if (a.callAt > b.callAt) {
            return 1;
        }

        // Sort next by immediate, immediate timers take precedence
        if (a.immediate && !b.immediate) {
            return -1;
        }
        if (!a.immediate && b.immediate) {
            return 1;
        }

        // Sort next by creation time, earlier-created timers take precedence
        if (a.createdAt < b.createdAt) {
            return -1;
        }
        if (a.createdAt > b.createdAt) {
            return 1;
        }

        // Sort next by id, lower-id timers take precedence
        if (a.id < b.id) {
            return -1;
        }
        if (a.id > b.id) {
            return 1;
        }

        // As timer ids are unique, no fallback `0` is necessary
    }

    function firstTimerInRange(clock, from, to) {
        var timers = clock.timers,
            timer = null,
            id,
            isInRange;

        for (id in timers) {
            if (timers.hasOwnProperty(id)) {
                isInRange = inRange(from, to, timers[id]);

                if (isInRange && (!timer || compareTimers(timer, timers[id]) === 1)) {
                    timer = timers[id];
                }
            }
        }

        return timer;
    }

    function callTimer(clock, timer) {
        var exception;

        if (typeof timer.interval === "number") {
            clock.timers[timer.id].callAt += timer.interval;
        } else {
            delete clock.timers[timer.id];
        }

        try {
            if (typeof timer.func === "function") {
                timer.func.apply(null, timer.args);
            } else {
                eval(timer.func);
            }
        } catch (e) {
            exception = e;
        }

        if (!clock.timers[timer.id]) {
            if (exception) {
                throw exception;
            }
            return;
        }

        if (exception) {
            throw exception;
        }
    }

    function timerType(timer) {
        if (timer.immediate) {
            return "Immediate";
        } else if (typeof timer.interval !== "undefined") {
            return "Interval";
        } else {
            return "Timeout";
        }
    }

    function clearTimer(clock, timerId, ttype) {
        if (!timerId) {
            // null appears to be allowed in most browsers, and appears to be
            // relied upon by some libraries, like Bootstrap carousel
            return;
        }

        if (!clock.timers) {
            clock.timers = [];
        }

        // in Node, timerId is an object with .ref()/.unref(), and
        // its .id field is the actual timer id.
        if (typeof timerId === "object") {
            timerId = timerId.id;
        }

        if (clock.timers.hasOwnProperty(timerId)) {
            // check that the ID matches a timer of the correct type
            var timer = clock.timers[timerId];
            if (timerType(timer) === ttype) {
                delete clock.timers[timerId];
            } else {
				throw new Error("Cannot clear timer: timer created with set" + ttype + "() but cleared with clear" + timerType(timer) + "()");
			}
        }
    }

    function uninstall(clock, target) {
        var method,
            i,
            l;

        for (i = 0, l = clock.methods.length; i < l; i++) {
            method = clock.methods[i];

            if (target[method].hadOwnProperty) {
                target[method] = clock["_" + method];
            } else {
                try {
                    delete target[method];
                } catch (ignore) {}
            }
        }

        // Prevent multiple executions which will completely remove these props
        clock.methods = [];
    }

    function hijackMethod(target, method, clock) {
        var prop;

        clock[method].hadOwnProperty = Object.prototype.hasOwnProperty.call(target, method);
        clock["_" + method] = target[method];

        if (method === "Date") {
            var date = mirrorDateProperties(clock[method], target[method]);
            target[method] = date;
        } else {
            target[method] = function () {
                return clock[method].apply(clock, arguments);
            };

            for (prop in clock[method]) {
                if (clock[method].hasOwnProperty(prop)) {
                    target[method][prop] = clock[method][prop];
                }
            }
        }

        target[method].clock = clock;
    }

    var timers = {
        setTimeout: setTimeout,
        clearTimeout: clearTimeout,
        setImmediate: global.setImmediate,
        clearImmediate: global.clearImmediate,
        setInterval: setInterval,
        clearInterval: clearInterval,
        Date: Date
    };

    var keys = Object.keys || function (obj) {
        var ks = [],
            key;

        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                ks.push(key);
            }
        }

        return ks;
    };

    exports.timers = timers;

    function createClock(now) {
        var clock = {
            now: getEpoch(now),
            timeouts: {},
            Date: createDate()
        };

        clock.Date.clock = clock;

        clock.setTimeout = function setTimeout(func, timeout) {
            return addTimer(clock, {
                func: func,
                args: Array.prototype.slice.call(arguments, 2),
                delay: timeout
            });
        };

        clock.clearTimeout = function clearTimeout(timerId) {
            return clearTimer(clock, timerId, "Timeout");
        };

        clock.setInterval = function setInterval(func, timeout) {
            return addTimer(clock, {
                func: func,
                args: Array.prototype.slice.call(arguments, 2),
                delay: timeout,
                interval: timeout
            });
        };

        clock.clearInterval = function clearInterval(timerId) {
            return clearTimer(clock, timerId, "Interval");
        };

        clock.setImmediate = function setImmediate(func) {
            return addTimer(clock, {
                func: func,
                args: Array.prototype.slice.call(arguments, 1),
                immediate: true
            });
        };

        clock.clearImmediate = function clearImmediate(timerId) {
            return clearTimer(clock, timerId, "Immediate");
        };

        clock.tick = function tick(ms) {
            ms = typeof ms === "number" ? ms : parseTime(ms);
            var tickFrom = clock.now, tickTo = clock.now + ms, previous = clock.now;
            var timer = firstTimerInRange(clock, tickFrom, tickTo);
            var oldNow;

            clock.duringTick = true;

            var firstException;
            while (timer && tickFrom <= tickTo) {
                if (clock.timers[timer.id]) {
                    tickFrom = clock.now = timer.callAt;
                    try {
                        oldNow = clock.now;
                        callTimer(clock, timer);
                        // compensate for any setSystemTime() call during timer callback
                        if (oldNow !== clock.now) {
                            tickFrom += clock.now - oldNow;
                            tickTo += clock.now - oldNow;
                            previous += clock.now - oldNow;
                        }
                    } catch (e) {
                        firstException = firstException || e;
                    }
                }

                timer = firstTimerInRange(clock, previous, tickTo);
                previous = tickFrom;
            }

            clock.duringTick = false;
            clock.now = tickTo;

            if (firstException) {
                throw firstException;
            }

            return clock.now;
        };

        clock.reset = function reset() {
            clock.timers = {};
        };

        clock.setSystemTime = function setSystemTime(now) {
            // determine time difference
            var newNow = getEpoch(now);
            var difference = newNow - clock.now;

            // update 'system clock'
            clock.now = newNow;

            // update timers and intervals to keep them stable
            for (var id in clock.timers) {
                if (clock.timers.hasOwnProperty(id)) {
                    var timer = clock.timers[id];
                    timer.createdAt += difference;
                    timer.callAt += difference;
                }
            }
        };

        return clock;
    }
    exports.createClock = createClock;

    exports.install = function install(target, now, toFake) {
        var i,
            l;

        if (typeof target === "number") {
            toFake = now;
            now = target;
            target = null;
        }

        if (!target) {
            target = global;
        }

        var clock = createClock(now);

        clock.uninstall = function () {
            uninstall(clock, target);
        };

        clock.methods = toFake || [];

        if (clock.methods.length === 0) {
            clock.methods = keys(timers);
        }

        for (i = 0, l = clock.methods.length; i < l; i++) {
            hijackMethod(target, clock.methods[i], clock);
        }

        return clock;
    };

}(global || this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],142:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

(function () {
    try {
        cachedSetTimeout = setTimeout;
    } catch (e) {
        cachedSetTimeout = function () {
            throw new Error('setTimeout is not defined');
        }
    }
    try {
        cachedClearTimeout = clearTimeout;
    } catch (e) {
        cachedClearTimeout = function () {
            throw new Error('clearTimeout is not defined');
        }
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],143:[function(require,module,exports){
((typeof define === "function" && define.amd && function (m) { define("samsam", m); }) ||
 (typeof module === "object" &&
      function (m) { module.exports = m(); }) || // Node
 function (m) { this.samsam = m(); } // Browser globals
)(function () {
    var o = Object.prototype;
    var div = typeof document !== "undefined" && document.createElement("div");

    function isNaN(value) {
        // Unlike global isNaN, this avoids type coercion
        // typeof check avoids IE host object issues, hat tip to
        // lodash
        var val = value; // JsLint thinks value !== value is "weird"
        return typeof value === "number" && value !== val;
    }

    function getClass(value) {
        // Returns the internal [[Class]] by calling Object.prototype.toString
        // with the provided value as this. Return value is a string, naming the
        // internal class, e.g. "Array"
        return o.toString.call(value).split(/[ \]]/)[1];
    }

    /**
     * @name samsam.isArguments
     * @param Object object
     *
     * Returns ``true`` if ``object`` is an ``arguments`` object,
     * ``false`` otherwise.
     */
    function isArguments(object) {
        if (getClass(object) === 'Arguments') { return true; }
        if (typeof object !== "object" || typeof object.length !== "number" ||
                getClass(object) === "Array") {
            return false;
        }
        if (typeof object.callee == "function") { return true; }
        try {
            object[object.length] = 6;
            delete object[object.length];
        } catch (e) {
            return true;
        }
        return false;
    }

    /**
     * @name samsam.isElement
     * @param Object object
     *
     * Returns ``true`` if ``object`` is a DOM element node. Unlike
     * Underscore.js/lodash, this function will return ``false`` if ``object``
     * is an *element-like* object, i.e. a regular object with a ``nodeType``
     * property that holds the value ``1``.
     */
    function isElement(object) {
        if (!object || object.nodeType !== 1 || !div) { return false; }
        try {
            object.appendChild(div);
            object.removeChild(div);
        } catch (e) {
            return false;
        }
        return true;
    }

    /**
     * @name samsam.keys
     * @param Object object
     *
     * Return an array of own property names.
     */
    function keys(object) {
        var ks = [], prop;
        for (prop in object) {
            if (o.hasOwnProperty.call(object, prop)) { ks.push(prop); }
        }
        return ks;
    }

    /**
     * @name samsam.isDate
     * @param Object value
     *
     * Returns true if the object is a ``Date``, or *date-like*. Duck typing
     * of date objects work by checking that the object has a ``getTime``
     * function whose return value equals the return value from the object's
     * ``valueOf``.
     */
    function isDate(value) {
        return typeof value.getTime == "function" &&
            value.getTime() == value.valueOf();
    }

    /**
     * @name samsam.isNegZero
     * @param Object value
     *
     * Returns ``true`` if ``value`` is ``-0``.
     */
    function isNegZero(value) {
        return value === 0 && 1 / value === -Infinity;
    }

    /**
     * @name samsam.equal
     * @param Object obj1
     * @param Object obj2
     *
     * Returns ``true`` if two objects are strictly equal. Compared to
     * ``===`` there are two exceptions:
     *
     *   - NaN is considered equal to NaN
     *   - -0 and +0 are not considered equal
     */
    function identical(obj1, obj2) {
        if (obj1 === obj2 || (isNaN(obj1) && isNaN(obj2))) {
            return obj1 !== 0 || isNegZero(obj1) === isNegZero(obj2);
        }
    }


    /**
     * @name samsam.deepEqual
     * @param Object obj1
     * @param Object obj2
     *
     * Deep equal comparison. Two values are "deep equal" if:
     *
     *   - They are equal, according to samsam.identical
     *   - They are both date objects representing the same time
     *   - They are both arrays containing elements that are all deepEqual
     *   - They are objects with the same set of properties, and each property
     *     in ``obj1`` is deepEqual to the corresponding property in ``obj2``
     *
     * Supports cyclic objects.
     */
    function deepEqualCyclic(obj1, obj2) {

        // used for cyclic comparison
        // contain already visited objects
        var objects1 = [],
            objects2 = [],
        // contain pathes (position in the object structure)
        // of the already visited objects
        // indexes same as in objects arrays
            paths1 = [],
            paths2 = [],
        // contains combinations of already compared objects
        // in the manner: { "$1['ref']$2['ref']": true }
            compared = {};

        /**
         * used to check, if the value of a property is an object
         * (cyclic logic is only needed for objects)
         * only needed for cyclic logic
         */
        function isObject(value) {

            if (typeof value === 'object' && value !== null &&
                    !(value instanceof Boolean) &&
                    !(value instanceof Date)    &&
                    !(value instanceof Number)  &&
                    !(value instanceof RegExp)  &&
                    !(value instanceof String)) {

                return true;
            }

            return false;
        }

        /**
         * returns the index of the given object in the
         * given objects array, -1 if not contained
         * only needed for cyclic logic
         */
        function getIndex(objects, obj) {

            var i;
            for (i = 0; i < objects.length; i++) {
                if (objects[i] === obj) {
                    return i;
                }
            }

            return -1;
        }

        // does the recursion for the deep equal check
        return (function deepEqual(obj1, obj2, path1, path2) {
            var type1 = typeof obj1;
            var type2 = typeof obj2;

            // == null also matches undefined
            if (obj1 === obj2 ||
                    isNaN(obj1) || isNaN(obj2) ||
                    obj1 == null || obj2 == null ||
                    type1 !== "object" || type2 !== "object") {

                return identical(obj1, obj2);
            }

            // Elements are only equal if identical(expected, actual)
            if (isElement(obj1) || isElement(obj2)) { return false; }

            var isDate1 = isDate(obj1), isDate2 = isDate(obj2);
            if (isDate1 || isDate2) {
                if (!isDate1 || !isDate2 || obj1.getTime() !== obj2.getTime()) {
                    return false;
                }
            }

            if (obj1 instanceof RegExp && obj2 instanceof RegExp) {
                if (obj1.toString() !== obj2.toString()) { return false; }
            }

            var class1 = getClass(obj1);
            var class2 = getClass(obj2);
            var keys1 = keys(obj1);
            var keys2 = keys(obj2);

            if (isArguments(obj1) || isArguments(obj2)) {
                if (obj1.length !== obj2.length) { return false; }
            } else {
                if (type1 !== type2 || class1 !== class2 ||
                        keys1.length !== keys2.length) {
                    return false;
                }
            }

            var key, i, l,
                // following vars are used for the cyclic logic
                value1, value2,
                isObject1, isObject2,
                index1, index2,
                newPath1, newPath2;

            for (i = 0, l = keys1.length; i < l; i++) {
                key = keys1[i];
                if (!o.hasOwnProperty.call(obj2, key)) {
                    return false;
                }

                // Start of the cyclic logic

                value1 = obj1[key];
                value2 = obj2[key];

                isObject1 = isObject(value1);
                isObject2 = isObject(value2);

                // determine, if the objects were already visited
                // (it's faster to check for isObject first, than to
                // get -1 from getIndex for non objects)
                index1 = isObject1 ? getIndex(objects1, value1) : -1;
                index2 = isObject2 ? getIndex(objects2, value2) : -1;

                // determine the new pathes of the objects
                // - for non cyclic objects the current path will be extended
                //   by current property name
                // - for cyclic objects the stored path is taken
                newPath1 = index1 !== -1
                    ? paths1[index1]
                    : path1 + '[' + JSON.stringify(key) + ']';
                newPath2 = index2 !== -1
                    ? paths2[index2]
                    : path2 + '[' + JSON.stringify(key) + ']';

                // stop recursion if current objects are already compared
                if (compared[newPath1 + newPath2]) {
                    return true;
                }

                // remember the current objects and their pathes
                if (index1 === -1 && isObject1) {
                    objects1.push(value1);
                    paths1.push(newPath1);
                }
                if (index2 === -1 && isObject2) {
                    objects2.push(value2);
                    paths2.push(newPath2);
                }

                // remember that the current objects are already compared
                if (isObject1 && isObject2) {
                    compared[newPath1 + newPath2] = true;
                }

                // End of cyclic logic

                // neither value1 nor value2 is a cycle
                // continue with next level
                if (!deepEqual(value1, value2, newPath1, newPath2)) {
                    return false;
                }
            }

            return true;

        }(obj1, obj2, '$1', '$2'));
    }

    var match;

    function arrayContains(array, subset) {
        if (subset.length === 0) { return true; }
        var i, l, j, k;
        for (i = 0, l = array.length; i < l; ++i) {
            if (match(array[i], subset[0])) {
                for (j = 0, k = subset.length; j < k; ++j) {
                    if (!match(array[i + j], subset[j])) { return false; }
                }
                return true;
            }
        }
        return false;
    }

    /**
     * @name samsam.match
     * @param Object object
     * @param Object matcher
     *
     * Compare arbitrary value ``object`` with matcher.
     */
    match = function match(object, matcher) {
        if (matcher && typeof matcher.test === "function") {
            return matcher.test(object);
        }

        if (typeof matcher === "function") {
            return matcher(object) === true;
        }

        if (typeof matcher === "string") {
            matcher = matcher.toLowerCase();
            var notNull = typeof object === "string" || !!object;
            return notNull &&
                (String(object)).toLowerCase().indexOf(matcher) >= 0;
        }

        if (typeof matcher === "number") {
            return matcher === object;
        }

        if (typeof matcher === "boolean") {
            return matcher === object;
        }

        if (typeof(matcher) === "undefined") {
            return typeof(object) === "undefined";
        }

        if (matcher === null) {
            return object === null;
        }

        if (getClass(object) === "Array" && getClass(matcher) === "Array") {
            return arrayContains(object, matcher);
        }

        if (matcher && typeof matcher === "object") {
            if (matcher === object) {
                return true;
            }
            var prop;
            for (prop in matcher) {
                var value = object[prop];
                if (typeof value === "undefined" &&
                        typeof object.getAttribute === "function") {
                    value = object.getAttribute(prop);
                }
                if (matcher[prop] === null || typeof matcher[prop] === 'undefined') {
                    if (value !== matcher[prop]) {
                        return false;
                    }
                } else if (typeof  value === "undefined" || !match(value, matcher[prop])) {
                    return false;
                }
            }
            return true;
        }

        throw new Error("Matcher was not a string, a number, a " +
                        "function, a boolean or an object");
    };

    return {
        isArguments: isArguments,
        isElement: isElement,
        isDate: isDate,
        isNegZero: isNegZero,
        identical: identical,
        deepEqual: deepEqualCyclic,
        match: match,
        keys: keys
    };
});

},{}],144:[function(require,module,exports){
/**
 * Sinon core utilities. For internal use only.
 *
 * @author Christian Johansen (christian@cjohansen.no)
 * @license BSD
 *
 * Copyright (c) 2010-2013 Christian Johansen
 */
var sinon = (function () { // eslint-disable-line no-unused-vars
    "use strict";

    var sinonModule;
    var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;

    function loadDependencies(require, exports, module) {
        sinonModule = module.exports = require("./sinon/util/core");
        require("./sinon/extend");
        require("./sinon/walk");
        require("./sinon/typeOf");
        require("./sinon/times_in_words");
        require("./sinon/spy");
        require("./sinon/call");
        require("./sinon/behavior");
        require("./sinon/stub");
        require("./sinon/mock");
        require("./sinon/collection");
        require("./sinon/assert");
        require("./sinon/sandbox");
        require("./sinon/test");
        require("./sinon/test_case");
        require("./sinon/match");
        require("./sinon/format");
        require("./sinon/log_error");
    }

    if (isAMD) {
        define(loadDependencies);
    } else if (isNode) {
        loadDependencies(require, module.exports, module);
        sinonModule = module.exports;
    } else {
        sinonModule = {};
    }

    return sinonModule;
}());

},{"./sinon/assert":145,"./sinon/behavior":146,"./sinon/call":147,"./sinon/collection":148,"./sinon/extend":149,"./sinon/format":150,"./sinon/log_error":151,"./sinon/match":152,"./sinon/mock":153,"./sinon/sandbox":154,"./sinon/spy":155,"./sinon/stub":156,"./sinon/test":157,"./sinon/test_case":158,"./sinon/times_in_words":159,"./sinon/typeOf":160,"./sinon/util/core":161,"./sinon/walk":168}],145:[function(require,module,exports){
(function (global){
/**
 * @depend times_in_words.js
 * @depend util/core.js
 * @depend match.js
 * @depend format.js
 */
/**
 * Assertions matching the test spy retrieval interface.
 *
 * @author Christian Johansen (christian@cjohansen.no)
 * @license BSD
 *
 * Copyright (c) 2010-2013 Christian Johansen
 */
(function (sinonGlobal, global) {
    "use strict";

    var slice = Array.prototype.slice;

    function makeApi(sinon) {
        var assert;

        function verifyIsStub() {
            var method;

            for (var i = 0, l = arguments.length; i < l; ++i) {
                method = arguments[i];

                if (!method) {
                    assert.fail("fake is not a spy");
                }

                if (method.proxy && method.proxy.isSinonProxy) {
                    verifyIsStub(method.proxy);
                } else {
                    if (typeof method !== "function") {
                        assert.fail(method + " is not a function");
                    }

                    if (typeof method.getCall !== "function") {
                        assert.fail(method + " is not stubbed");
                    }
                }

            }
        }

        function failAssertion(object, msg) {
            object = object || global;
            var failMethod = object.fail || assert.fail;
            failMethod.call(object, msg);
        }

        function mirrorPropAsAssertion(name, method, message) {
            if (arguments.length === 2) {
                message = method;
                method = name;
            }

            assert[name] = function (fake) {
                verifyIsStub(fake);

                var args = slice.call(arguments, 1);
                var failed = false;

                if (typeof method === "function") {
                    failed = !method(fake);
                } else {
                    failed = typeof fake[method] === "function" ?
                        !fake[method].apply(fake, args) : !fake[method];
                }

                if (failed) {
                    failAssertion(this, (fake.printf || fake.proxy.printf).apply(fake, [message].concat(args)));
                } else {
                    assert.pass(name);
                }
            };
        }

        function exposedName(prefix, prop) {
            return !prefix || /^fail/.test(prop) ? prop :
                prefix + prop.slice(0, 1).toUpperCase() + prop.slice(1);
        }

        assert = {
            failException: "AssertError",

            fail: function fail(message) {
                var error = new Error(message);
                error.name = this.failException || assert.failException;

                throw error;
            },

            pass: function pass() {},

            callOrder: function assertCallOrder() {
                verifyIsStub.apply(null, arguments);
                var expected = "";
                var actual = "";

                if (!sinon.calledInOrder(arguments)) {
                    try {
                        expected = [].join.call(arguments, ", ");
                        var calls = slice.call(arguments);
                        var i = calls.length;
                        while (i) {
                            if (!calls[--i].called) {
                                calls.splice(i, 1);
                            }
                        }
                        actual = sinon.orderByFirstCall(calls).join(", ");
                    } catch (e) {
                        // If this fails, we'll just fall back to the blank string
                    }

                    failAssertion(this, "expected " + expected + " to be " +
                                "called in order but were called as " + actual);
                } else {
                    assert.pass("callOrder");
                }
            },

            callCount: function assertCallCount(method, count) {
                verifyIsStub(method);

                if (method.callCount !== count) {
                    var msg = "expected %n to be called " + sinon.timesInWords(count) +
                        " but was called %c%C";
                    failAssertion(this, method.printf(msg));
                } else {
                    assert.pass("callCount");
                }
            },

            expose: function expose(target, options) {
                if (!target) {
                    throw new TypeError("target is null or undefined");
                }

                var o = options || {};
                var prefix = typeof o.prefix === "undefined" && "assert" || o.prefix;
                var includeFail = typeof o.includeFail === "undefined" || !!o.includeFail;

                for (var method in this) {
                    if (method !== "expose" && (includeFail || !/^(fail)/.test(method))) {
                        target[exposedName(prefix, method)] = this[method];
                    }
                }

                return target;
            },

            match: function match(actual, expectation) {
                var matcher = sinon.match(expectation);
                if (matcher.test(actual)) {
                    assert.pass("match");
                } else {
                    var formatted = [
                        "expected value to match",
                        "    expected = " + sinon.format(expectation),
                        "    actual = " + sinon.format(actual)
                    ];

                    failAssertion(this, formatted.join("\n"));
                }
            }
        };

        mirrorPropAsAssertion("called", "expected %n to have been called at least once but was never called");
        mirrorPropAsAssertion("notCalled", function (spy) {
            return !spy.called;
        }, "expected %n to not have been called but was called %c%C");
        mirrorPropAsAssertion("calledOnce", "expected %n to be called once but was called %c%C");
        mirrorPropAsAssertion("calledTwice", "expected %n to be called twice but was called %c%C");
        mirrorPropAsAssertion("calledThrice", "expected %n to be called thrice but was called %c%C");
        mirrorPropAsAssertion("calledOn", "expected %n to be called with %1 as this but was called with %t");
        mirrorPropAsAssertion(
            "alwaysCalledOn",
            "expected %n to always be called with %1 as this but was called with %t"
        );
        mirrorPropAsAssertion("calledWithNew", "expected %n to be called with new");
        mirrorPropAsAssertion("alwaysCalledWithNew", "expected %n to always be called with new");
        mirrorPropAsAssertion("calledWith", "expected %n to be called with arguments %*%C");
        mirrorPropAsAssertion("calledWithMatch", "expected %n to be called with match %*%C");
        mirrorPropAsAssertion("alwaysCalledWith", "expected %n to always be called with arguments %*%C");
        mirrorPropAsAssertion("alwaysCalledWithMatch", "expected %n to always be called with match %*%C");
        mirrorPropAsAssertion("calledWithExactly", "expected %n to be called with exact arguments %*%C");
        mirrorPropAsAssertion("alwaysCalledWithExactly", "expected %n to always be called with exact arguments %*%C");
        mirrorPropAsAssertion("neverCalledWith", "expected %n to never be called with arguments %*%C");
        mirrorPropAsAssertion("neverCalledWithMatch", "expected %n to never be called with match %*%C");
        mirrorPropAsAssertion("threw", "%n did not throw exception%C");
        mirrorPropAsAssertion("alwaysThrew", "%n did not always throw exception%C");

        sinon.assert = assert;
        return assert;
    }

    var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;

    function loadDependencies(require, exports, module) {
        var sinon = require("./util/core");
        require("./match");
        require("./format");
        module.exports = makeApi(sinon);
    }

    if (isAMD) {
        define(loadDependencies);
        return;
    }

    if (isNode) {
        loadDependencies(require, module.exports, module);
        return;
    }

    if (sinonGlobal) {
        makeApi(sinonGlobal);
    }
}(
    typeof sinon === "object" && sinon, // eslint-disable-line no-undef
    typeof global !== "undefined" ? global : self
));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./format":150,"./match":152,"./util/core":161}],146:[function(require,module,exports){
(function (process){
/**
 * @depend util/core.js
 * @depend extend.js
 */
/**
 * Stub behavior
 *
 * @author Christian Johansen (christian@cjohansen.no)
 * @author Tim Fischbach (mail@timfischbach.de)
 * @license BSD
 *
 * Copyright (c) 2010-2013 Christian Johansen
 */
(function (sinonGlobal) {
    "use strict";

    var slice = Array.prototype.slice;
    var join = Array.prototype.join;
    var useLeftMostCallback = -1;
    var useRightMostCallback = -2;

    var nextTick = (function () {
        if (typeof process === "object" && typeof process.nextTick === "function") {
            return process.nextTick;
        }

        if (typeof setImmediate === "function") {
            return setImmediate;
        }

        return function (callback) {
            setTimeout(callback, 0);
        };
    })();

    function throwsException(error, message) {
        if (typeof error === "string") {
            this.exception = new Error(message || "");
            this.exception.name = error;
        } else if (!error) {
            this.exception = new Error("Error");
        } else {
            this.exception = error;
        }

        return this;
    }

    function getCallback(behavior, args) {
        var callArgAt = behavior.callArgAt;

        if (callArgAt >= 0) {
            return args[callArgAt];
        }

        var argumentList;

        if (callArgAt === useLeftMostCallback) {
            argumentList = args;
        }

        if (callArgAt === useRightMostCallback) {
            argumentList = slice.call(args).reverse();
        }

        var callArgProp = behavior.callArgProp;

        for (var i = 0, l = argumentList.length; i < l; ++i) {
            if (!callArgProp && typeof argumentList[i] === "function") {
                return argumentList[i];
            }

            if (callArgProp && argumentList[i] &&
                typeof argumentList[i][callArgProp] === "function") {
                return argumentList[i][callArgProp];
            }
        }

        return null;
    }

    function makeApi(sinon) {
        function getCallbackError(behavior, func, args) {
            if (behavior.callArgAt < 0) {
                var msg;

                if (behavior.callArgProp) {
                    msg = sinon.functionName(behavior.stub) +
                        " expected to yield to '" + behavior.callArgProp +
                        "', but no object with such a property was passed.";
                } else {
                    msg = sinon.functionName(behavior.stub) +
                        " expected to yield, but no callback was passed.";
                }

                if (args.length > 0) {
                    msg += " Received [" + join.call(args, ", ") + "]";
                }

                return msg;
            }

            return "argument at index " + behavior.callArgAt + " is not a function: " + func;
        }

        function callCallback(behavior, args) {
            if (typeof behavior.callArgAt === "number") {
                var func = getCallback(behavior, args);

                if (typeof func !== "function") {
                    throw new TypeError(getCallbackError(behavior, func, args));
                }

                if (behavior.callbackAsync) {
                    nextTick(function () {
                        func.apply(behavior.callbackContext, behavior.callbackArguments);
                    });
                } else {
                    func.apply(behavior.callbackContext, behavior.callbackArguments);
                }
            }
        }

        var proto = {
            create: function create(stub) {
                var behavior = sinon.extend({}, sinon.behavior);
                delete behavior.create;
                behavior.stub = stub;

                return behavior;
            },

            isPresent: function isPresent() {
                return (typeof this.callArgAt === "number" ||
                        this.exception ||
                        typeof this.returnArgAt === "number" ||
                        this.returnThis ||
                        this.returnValueDefined);
            },

            invoke: function invoke(context, args) {
                callCallback(this, args);

                if (this.exception) {
                    throw this.exception;
                } else if (typeof this.returnArgAt === "number") {
                    return args[this.returnArgAt];
                } else if (this.returnThis) {
                    return context;
                }

                return this.returnValue;
            },

            onCall: function onCall(index) {
                return this.stub.onCall(index);
            },

            onFirstCall: function onFirstCall() {
                return this.stub.onFirstCall();
            },

            onSecondCall: function onSecondCall() {
                return this.stub.onSecondCall();
            },

            onThirdCall: function onThirdCall() {
                return this.stub.onThirdCall();
            },

            withArgs: function withArgs(/* arguments */) {
                throw new Error(
                    "Defining a stub by invoking \"stub.onCall(...).withArgs(...)\" " +
                    "is not supported. Use \"stub.withArgs(...).onCall(...)\" " +
                    "to define sequential behavior for calls with certain arguments."
                );
            },

            callsArg: function callsArg(pos) {
                if (typeof pos !== "number") {
                    throw new TypeError("argument index is not number");
                }

                this.callArgAt = pos;
                this.callbackArguments = [];
                this.callbackContext = undefined;
                this.callArgProp = undefined;
                this.callbackAsync = false;

                return this;
            },

            callsArgOn: function callsArgOn(pos, context) {
                if (typeof pos !== "number") {
                    throw new TypeError("argument index is not number");
                }
                if (typeof context !== "object") {
                    throw new TypeError("argument context is not an object");
                }

                this.callArgAt = pos;
                this.callbackArguments = [];
                this.callbackContext = context;
                this.callArgProp = undefined;
                this.callbackAsync = false;

                return this;
            },

            callsArgWith: function callsArgWith(pos) {
                if (typeof pos !== "number") {
                    throw new TypeError("argument index is not number");
                }

                this.callArgAt = pos;
                this.callbackArguments = slice.call(arguments, 1);
                this.callbackContext = undefined;
                this.callArgProp = undefined;
                this.callbackAsync = false;

                return this;
            },

            callsArgOnWith: function callsArgWith(pos, context) {
                if (typeof pos !== "number") {
                    throw new TypeError("argument index is not number");
                }
                if (typeof context !== "object") {
                    throw new TypeError("argument context is not an object");
                }

                this.callArgAt = pos;
                this.callbackArguments = slice.call(arguments, 2);
                this.callbackContext = context;
                this.callArgProp = undefined;
                this.callbackAsync = false;

                return this;
            },

            yields: function () {
                this.callArgAt = useLeftMostCallback;
                this.callbackArguments = slice.call(arguments, 0);
                this.callbackContext = undefined;
                this.callArgProp = undefined;
                this.callbackAsync = false;

                return this;
            },

            yieldsRight: function () {
                this.callArgAt = useRightMostCallback;
                this.callbackArguments = slice.call(arguments, 0);
                this.callbackContext = undefined;
                this.callArgProp = undefined;
                this.callbackAsync = false;

                return this;
            },

            yieldsOn: function (context) {
                if (typeof context !== "object") {
                    throw new TypeError("argument context is not an object");
                }

                this.callArgAt = useLeftMostCallback;
                this.callbackArguments = slice.call(arguments, 1);
                this.callbackContext = context;
                this.callArgProp = undefined;
                this.callbackAsync = false;

                return this;
            },

            yieldsTo: function (prop) {
                this.callArgAt = useLeftMostCallback;
                this.callbackArguments = slice.call(arguments, 1);
                this.callbackContext = undefined;
                this.callArgProp = prop;
                this.callbackAsync = false;

                return this;
            },

            yieldsToOn: function (prop, context) {
                if (typeof context !== "object") {
                    throw new TypeError("argument context is not an object");
                }

                this.callArgAt = useLeftMostCallback;
                this.callbackArguments = slice.call(arguments, 2);
                this.callbackContext = context;
                this.callArgProp = prop;
                this.callbackAsync = false;

                return this;
            },

            throws: throwsException,
            throwsException: throwsException,

            returns: function returns(value) {
                this.returnValue = value;
                this.returnValueDefined = true;
                this.exception = undefined;

                return this;
            },

            returnsArg: function returnsArg(pos) {
                if (typeof pos !== "number") {
                    throw new TypeError("argument index is not number");
                }

                this.returnArgAt = pos;

                return this;
            },

            returnsThis: function returnsThis() {
                this.returnThis = true;

                return this;
            }
        };

        function createAsyncVersion(syncFnName) {
            return function () {
                var result = this[syncFnName].apply(this, arguments);
                this.callbackAsync = true;
                return result;
            };
        }

        // create asynchronous versions of callsArg* and yields* methods
        for (var method in proto) {
            // need to avoid creating anotherasync versions of the newly added async methods
            if (proto.hasOwnProperty(method) && method.match(/^(callsArg|yields)/) && !method.match(/Async/)) {
                proto[method + "Async"] = createAsyncVersion(method);
            }
        }

        sinon.behavior = proto;
        return proto;
    }

    var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;

    function loadDependencies(require, exports, module) {
        var sinon = require("./util/core");
        require("./extend");
        module.exports = makeApi(sinon);
    }

    if (isAMD) {
        define(loadDependencies);
        return;
    }

    if (isNode) {
        loadDependencies(require, module.exports, module);
        return;
    }

    if (sinonGlobal) {
        makeApi(sinonGlobal);
    }
}(
    typeof sinon === "object" && sinon // eslint-disable-line no-undef
));

}).call(this,require('_process'))
},{"./extend":149,"./util/core":161,"_process":142}],147:[function(require,module,exports){
/**
  * @depend util/core.js
  * @depend match.js
  * @depend format.js
  */
/**
  * Spy calls
  *
  * @author Christian Johansen (christian@cjohansen.no)
  * @author Maximilian Antoni (mail@maxantoni.de)
  * @license BSD
  *
  * Copyright (c) 2010-2013 Christian Johansen
  * Copyright (c) 2013 Maximilian Antoni
  */
(function (sinonGlobal) {
    "use strict";

    var slice = Array.prototype.slice;

    function makeApi(sinon) {
        function throwYieldError(proxy, text, args) {
            var msg = sinon.functionName(proxy) + text;
            if (args.length) {
                msg += " Received [" + slice.call(args).join(", ") + "]";
            }
            throw new Error(msg);
        }

        var callProto = {
            calledOn: function calledOn(thisValue) {
                if (sinon.match && sinon.match.isMatcher(thisValue)) {
                    return thisValue.test(this.thisValue);
                }
                return this.thisValue === thisValue;
            },

            calledWith: function calledWith() {
                var l = arguments.length;
                if (l > this.args.length) {
                    return false;
                }
                for (var i = 0; i < l; i += 1) {
                    if (!sinon.deepEqual(arguments[i], this.args[i])) {
                        return false;
                    }
                }

                return true;
            },

            calledWithMatch: function calledWithMatch() {
                var l = arguments.length;
                if (l > this.args.length) {
                    return false;
                }
                for (var i = 0; i < l; i += 1) {
                    var actual = this.args[i];
                    var expectation = arguments[i];
                    if (!sinon.match || !sinon.match(expectation).test(actual)) {
                        return false;
                    }
                }
                return true;
            },

            calledWithExactly: function calledWithExactly() {
                return arguments.length === this.args.length &&
                    this.calledWith.apply(this, arguments);
            },

            notCalledWith: function notCalledWith() {
                return !this.calledWith.apply(this, arguments);
            },

            notCalledWithMatch: function notCalledWithMatch() {
                return !this.calledWithMatch.apply(this, arguments);
            },

            returned: function returned(value) {
                return sinon.deepEqual(value, this.returnValue);
            },

            threw: function threw(error) {
                if (typeof error === "undefined" || !this.exception) {
                    return !!this.exception;
                }

                return this.exception === error || this.exception.name === error;
            },

            calledWithNew: function calledWithNew() {
                return this.proxy.prototype && this.thisValue instanceof this.proxy;
            },

            calledBefore: function (other) {
                return this.callId < other.callId;
            },

            calledAfter: function (other) {
                return this.callId > other.callId;
            },

            callArg: function (pos) {
                this.args[pos]();
            },

            callArgOn: function (pos, thisValue) {
                this.args[pos].apply(thisValue);
            },

            callArgWith: function (pos) {
                this.callArgOnWith.apply(this, [pos, null].concat(slice.call(arguments, 1)));
            },

            callArgOnWith: function (pos, thisValue) {
                var args = slice.call(arguments, 2);
                this.args[pos].apply(thisValue, args);
            },

            "yield": function () {
                this.yieldOn.apply(this, [null].concat(slice.call(arguments, 0)));
            },

            yieldOn: function (thisValue) {
                var args = this.args;
                for (var i = 0, l = args.length; i < l; ++i) {
                    if (typeof args[i] === "function") {
                        args[i].apply(thisValue, slice.call(arguments, 1));
                        return;
                    }
                }
                throwYieldError(this.proxy, " cannot yield since no callback was passed.", args);
            },

            yieldTo: function (prop) {
                this.yieldToOn.apply(this, [prop, null].concat(slice.call(arguments, 1)));
            },

            yieldToOn: function (prop, thisValue) {
                var args = this.args;
                for (var i = 0, l = args.length; i < l; ++i) {
                    if (args[i] && typeof args[i][prop] === "function") {
                        args[i][prop].apply(thisValue, slice.call(arguments, 2));
                        return;
                    }
                }
                throwYieldError(this.proxy, " cannot yield to '" + prop +
                    "' since no callback was passed.", args);
            },

            getStackFrames: function () {
                // Omit the error message and the two top stack frames in sinon itself:
                return this.stack && this.stack.split("\n").slice(3);
            },

            toString: function () {
                var callStr = this.proxy.toString() + "(";
                var args = [];

                for (var i = 0, l = this.args.length; i < l; ++i) {
                    args.push(sinon.format(this.args[i]));
                }

                callStr = callStr + args.join(", ") + ")";

                if (typeof this.returnValue !== "undefined") {
                    callStr += " => " + sinon.format(this.returnValue);
                }

                if (this.exception) {
                    callStr += " !" + this.exception.name;

                    if (this.exception.message) {
                        callStr += "(" + this.exception.message + ")";
                    }
                }
                if (this.stack) {
                    callStr += this.getStackFrames()[0].replace(/^\s*(?:at\s+|@)?/, " at ");

                }

                return callStr;
            }
        };

        callProto.invokeCallback = callProto.yield;

        function createSpyCall(spy, thisValue, args, returnValue, exception, id, stack) {
            if (typeof id !== "number") {
                throw new TypeError("Call id is not a number");
            }
            var proxyCall = sinon.create(callProto);
            proxyCall.proxy = spy;
            proxyCall.thisValue = thisValue;
            proxyCall.args = args;
            proxyCall.returnValue = returnValue;
            proxyCall.exception = exception;
            proxyCall.callId = id;
            proxyCall.stack = stack;

            return proxyCall;
        }
        createSpyCall.toString = callProto.toString; // used by mocks

        sinon.spyCall = createSpyCall;
        return createSpyCall;
    }

    var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;

    function loadDependencies(require, exports, module) {
        var sinon = require("./util/core");
        require("./match");
        require("./format");
        module.exports = makeApi(sinon);
    }

    if (isAMD) {
        define(loadDependencies);
        return;
    }

    if (isNode) {
        loadDependencies(require, module.exports, module);
        return;
    }

    if (sinonGlobal) {
        makeApi(sinonGlobal);
    }
}(
    typeof sinon === "object" && sinon // eslint-disable-line no-undef
));

},{"./format":150,"./match":152,"./util/core":161}],148:[function(require,module,exports){
/**
 * @depend util/core.js
 * @depend spy.js
 * @depend stub.js
 * @depend mock.js
 */
/**
 * Collections of stubs, spies and mocks.
 *
 * @author Christian Johansen (christian@cjohansen.no)
 * @license BSD
 *
 * Copyright (c) 2010-2013 Christian Johansen
 */
(function (sinonGlobal) {
    "use strict";

    var push = [].push;
    var hasOwnProperty = Object.prototype.hasOwnProperty;

    function getFakes(fakeCollection) {
        if (!fakeCollection.fakes) {
            fakeCollection.fakes = [];
        }

        return fakeCollection.fakes;
    }

    function each(fakeCollection, method) {
        var fakes = getFakes(fakeCollection);

        for (var i = 0, l = fakes.length; i < l; i += 1) {
            if (typeof fakes[i][method] === "function") {
                fakes[i][method]();
            }
        }
    }

    function compact(fakeCollection) {
        var fakes = getFakes(fakeCollection);
        var i = 0;
        while (i < fakes.length) {
            fakes.splice(i, 1);
        }
    }

    function makeApi(sinon) {
        var collection = {
            verify: function resolve() {
                each(this, "verify");
            },

            restore: function restore() {
                each(this, "restore");
                compact(this);
            },

            reset: function restore() {
                each(this, "reset");
            },

            verifyAndRestore: function verifyAndRestore() {
                var exception;

                try {
                    this.verify();
                } catch (e) {
                    exception = e;
                }

                this.restore();

                if (exception) {
                    throw exception;
                }
            },

            add: function add(fake) {
                push.call(getFakes(this), fake);
                return fake;
            },

            spy: function spy() {
                return this.add(sinon.spy.apply(sinon, arguments));
            },

            stub: function stub(object, property, value) {
                if (property) {
                    var original = object[property];

                    if (typeof original !== "function") {
                        if (!hasOwnProperty.call(object, property)) {
                            throw new TypeError("Cannot stub non-existent own property " + property);
                        }

                        object[property] = value;

                        return this.add({
                            restore: function () {
                                object[property] = original;
                            }
                        });
                    }
                }
                if (!property && !!object && typeof object === "object") {
                    var stubbedObj = sinon.stub.apply(sinon, arguments);

                    for (var prop in stubbedObj) {
                        if (typeof stubbedObj[prop] === "function") {
                            this.add(stubbedObj[prop]);
                        }
                    }

                    return stubbedObj;
                }

                return this.add(sinon.stub.apply(sinon, arguments));
            },

            mock: function mock() {
                return this.add(sinon.mock.apply(sinon, arguments));
            },

            inject: function inject(obj) {
                var col = this;

                obj.spy = function () {
                    return col.spy.apply(col, arguments);
                };

                obj.stub = function () {
                    return col.stub.apply(col, arguments);
                };

                obj.mock = function () {
                    return col.mock.apply(col, arguments);
                };

                return obj;
            }
        };

        sinon.collection = collection;
        return collection;
    }

    var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;

    function loadDependencies(require, exports, module) {
        var sinon = require("./util/core");
        require("./mock");
        require("./spy");
        require("./stub");
        module.exports = makeApi(sinon);
    }

    if (isAMD) {
        define(loadDependencies);
        return;
    }

    if (isNode) {
        loadDependencies(require, module.exports, module);
        return;
    }

    if (sinonGlobal) {
        makeApi(sinonGlobal);
    }
}(
    typeof sinon === "object" && sinon // eslint-disable-line no-undef
));

},{"./mock":153,"./spy":155,"./stub":156,"./util/core":161}],149:[function(require,module,exports){
/**
 * @depend util/core.js
 */
(function (sinonGlobal) {
    "use strict";

    function makeApi(sinon) {

        // Adapted from https://developer.mozilla.org/en/docs/ECMAScript_DontEnum_attribute#JScript_DontEnum_Bug
        var hasDontEnumBug = (function () {
            var obj = {
                constructor: function () {
                    return "0";
                },
                toString: function () {
                    return "1";
                },
                valueOf: function () {
                    return "2";
                },
                toLocaleString: function () {
                    return "3";
                },
                prototype: function () {
                    return "4";
                },
                isPrototypeOf: function () {
                    return "5";
                },
                propertyIsEnumerable: function () {
                    return "6";
                },
                hasOwnProperty: function () {
                    return "7";
                },
                length: function () {
                    return "8";
                },
                unique: function () {
                    return "9";
                }
            };

            var result = [];
            for (var prop in obj) {
                if (obj.hasOwnProperty(prop)) {
                    result.push(obj[prop]());
                }
            }
            return result.join("") !== "0123456789";
        })();

        /* Public: Extend target in place with all (own) properties from sources in-order. Thus, last source will
         *         override properties in previous sources.
         *
         * target - The Object to extend
         * sources - Objects to copy properties from.
         *
         * Returns the extended target
         */
        function extend(target /*, sources */) {
            var sources = Array.prototype.slice.call(arguments, 1);
            var source, i, prop;

            for (i = 0; i < sources.length; i++) {
                source = sources[i];

                for (prop in source) {
                    if (source.hasOwnProperty(prop)) {
                        target[prop] = source[prop];
                    }
                }

                // Make sure we copy (own) toString method even when in JScript with DontEnum bug
                // See https://developer.mozilla.org/en/docs/ECMAScript_DontEnum_attribute#JScript_DontEnum_Bug
                if (hasDontEnumBug && source.hasOwnProperty("toString") && source.toString !== target.toString) {
                    target.toString = source.toString;
                }
            }

            return target;
        }

        sinon.extend = extend;
        return sinon.extend;
    }

    function loadDependencies(require, exports, module) {
        var sinon = require("./util/core");
        module.exports = makeApi(sinon);
    }

    var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;

    if (isAMD) {
        define(loadDependencies);
        return;
    }

    if (isNode) {
        loadDependencies(require, module.exports, module);
        return;
    }

    if (sinonGlobal) {
        makeApi(sinonGlobal);
    }
}(
    typeof sinon === "object" && sinon // eslint-disable-line no-undef
));

},{"./util/core":161}],150:[function(require,module,exports){
/**
 * @depend util/core.js
 */
/**
 * Format functions
 *
 * @author Christian Johansen (christian@cjohansen.no)
 * @license BSD
 *
 * Copyright (c) 2010-2014 Christian Johansen
 */
(function (sinonGlobal, formatio) {
    "use strict";

    function makeApi(sinon) {
        function valueFormatter(value) {
            return "" + value;
        }

        function getFormatioFormatter() {
            var formatter = formatio.configure({
                    quoteStrings: false,
                    limitChildrenCount: 250
                });

            function format() {
                return formatter.ascii.apply(formatter, arguments);
            }

            return format;
        }

        function getNodeFormatter() {
            try {
                var util = require("util");
            } catch (e) {
                /* Node, but no util module - would be very old, but better safe than sorry */
            }

            function format(v) {
                var isObjectWithNativeToString = typeof v === "object" && v.toString === Object.prototype.toString;
                return isObjectWithNativeToString ? util.inspect(v) : v;
            }

            return util ? format : valueFormatter;
        }

        var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
        var formatter;

        if (isNode) {
            try {
                formatio = require("formatio");
            }
            catch (e) {} // eslint-disable-line no-empty
        }

        if (formatio) {
            formatter = getFormatioFormatter();
        } else if (isNode) {
            formatter = getNodeFormatter();
        } else {
            formatter = valueFormatter;
        }

        sinon.format = formatter;
        return sinon.format;
    }

    function loadDependencies(require, exports, module) {
        var sinon = require("./util/core");
        module.exports = makeApi(sinon);
    }

    var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;

    if (isAMD) {
        define(loadDependencies);
        return;
    }

    if (isNode) {
        loadDependencies(require, module.exports, module);
        return;
    }

    if (sinonGlobal) {
        makeApi(sinonGlobal);
    }
}(
    typeof sinon === "object" && sinon, // eslint-disable-line no-undef
    typeof formatio === "object" && formatio // eslint-disable-line no-undef
));

},{"./util/core":161,"formatio":139,"util":175}],151:[function(require,module,exports){
/**
 * @depend util/core.js
 */
/**
 * Logs errors
 *
 * @author Christian Johansen (christian@cjohansen.no)
 * @license BSD
 *
 * Copyright (c) 2010-2014 Christian Johansen
 */
(function (sinonGlobal) {
    "use strict";

    // cache a reference to setTimeout, so that our reference won't be stubbed out
    // when using fake timers and errors will still get logged
    // https://github.com/cjohansen/Sinon.JS/issues/381
    var realSetTimeout = setTimeout;

    function makeApi(sinon) {

        function log() {}

        function logError(label, err) {
            var msg = label + " threw exception: ";

            function throwLoggedError() {
                err.message = msg + err.message;
                throw err;
            }

            sinon.log(msg + "[" + err.name + "] " + err.message);

            if (err.stack) {
                sinon.log(err.stack);
            }

            if (logError.useImmediateExceptions) {
                throwLoggedError();
            } else {
                logError.setTimeout(throwLoggedError, 0);
            }
        }

        // When set to true, any errors logged will be thrown immediately;
        // If set to false, the errors will be thrown in separate execution frame.
        logError.useImmediateExceptions = false;

        // wrap realSetTimeout with something we can stub in tests
        logError.setTimeout = function (func, timeout) {
            realSetTimeout(func, timeout);
        };

        var exports = {};
        exports.log = sinon.log = log;
        exports.logError = sinon.logError = logError;

        return exports;
    }

    function loadDependencies(require, exports, module) {
        var sinon = require("./util/core");
        module.exports = makeApi(sinon);
    }

    var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;

    if (isAMD) {
        define(loadDependencies);
        return;
    }

    if (isNode) {
        loadDependencies(require, module.exports, module);
        return;
    }

    if (sinonGlobal) {
        makeApi(sinonGlobal);
    }
}(
    typeof sinon === "object" && sinon // eslint-disable-line no-undef
));

},{"./util/core":161}],152:[function(require,module,exports){
/**
 * @depend util/core.js
 * @depend typeOf.js
 */
/*jslint eqeqeq: false, onevar: false, plusplus: false*/
/*global module, require, sinon*/
/**
 * Match functions
 *
 * @author Maximilian Antoni (mail@maxantoni.de)
 * @license BSD
 *
 * Copyright (c) 2012 Maximilian Antoni
 */
(function (sinonGlobal) {
    "use strict";

    function makeApi(sinon) {
        function assertType(value, type, name) {
            var actual = sinon.typeOf(value);
            if (actual !== type) {
                throw new TypeError("Expected type of " + name + " to be " +
                    type + ", but was " + actual);
            }
        }

        var matcher = {
            toString: function () {
                return this.message;
            }
        };

        function isMatcher(object) {
            return matcher.isPrototypeOf(object);
        }

        function matchObject(expectation, actual) {
            if (actual === null || actual === undefined) {
                return false;
            }
            for (var key in expectation) {
                if (expectation.hasOwnProperty(key)) {
                    var exp = expectation[key];
                    var act = actual[key];
                    if (isMatcher(exp)) {
                        if (!exp.test(act)) {
                            return false;
                        }
                    } else if (sinon.typeOf(exp) === "object") {
                        if (!matchObject(exp, act)) {
                            return false;
                        }
                    } else if (!sinon.deepEqual(exp, act)) {
                        return false;
                    }
                }
            }
            return true;
        }

        function match(expectation, message) {
            var m = sinon.create(matcher);
            var type = sinon.typeOf(expectation);
            switch (type) {
            case "object":
                if (typeof expectation.test === "function") {
                    m.test = function (actual) {
                        return expectation.test(actual) === true;
                    };
                    m.message = "match(" + sinon.functionName(expectation.test) + ")";
                    return m;
                }
                var str = [];
                for (var key in expectation) {
                    if (expectation.hasOwnProperty(key)) {
                        str.push(key + ": " + expectation[key]);
                    }
                }
                m.test = function (actual) {
                    return matchObject(expectation, actual);
                };
                m.message = "match(" + str.join(", ") + ")";
                break;
            case "number":
                m.test = function (actual) {
                    // we need type coercion here
                    return expectation == actual; // eslint-disable-line eqeqeq
                };
                break;
            case "string":
                m.test = function (actual) {
                    if (typeof actual !== "string") {
                        return false;
                    }
                    return actual.indexOf(expectation) !== -1;
                };
                m.message = "match(\"" + expectation + "\")";
                break;
            case "regexp":
                m.test = function (actual) {
                    if (typeof actual !== "string") {
                        return false;
                    }
                    return expectation.test(actual);
                };
                break;
            case "function":
                m.test = expectation;
                if (message) {
                    m.message = message;
                } else {
                    m.message = "match(" + sinon.functionName(expectation) + ")";
                }
                break;
            default:
                m.test = function (actual) {
                    return sinon.deepEqual(expectation, actual);
                };
            }
            if (!m.message) {
                m.message = "match(" + expectation + ")";
            }
            return m;
        }

        matcher.or = function (m2) {
            if (!arguments.length) {
                throw new TypeError("Matcher expected");
            } else if (!isMatcher(m2)) {
                m2 = match(m2);
            }
            var m1 = this;
            var or = sinon.create(matcher);
            or.test = function (actual) {
                return m1.test(actual) || m2.test(actual);
            };
            or.message = m1.message + ".or(" + m2.message + ")";
            return or;
        };

        matcher.and = function (m2) {
            if (!arguments.length) {
                throw new TypeError("Matcher expected");
            } else if (!isMatcher(m2)) {
                m2 = match(m2);
            }
            var m1 = this;
            var and = sinon.create(matcher);
            and.test = function (actual) {
                return m1.test(actual) && m2.test(actual);
            };
            and.message = m1.message + ".and(" + m2.message + ")";
            return and;
        };

        match.isMatcher = isMatcher;

        match.any = match(function () {
            return true;
        }, "any");

        match.defined = match(function (actual) {
            return actual !== null && actual !== undefined;
        }, "defined");

        match.truthy = match(function (actual) {
            return !!actual;
        }, "truthy");

        match.falsy = match(function (actual) {
            return !actual;
        }, "falsy");

        match.same = function (expectation) {
            return match(function (actual) {
                return expectation === actual;
            }, "same(" + expectation + ")");
        };

        match.typeOf = function (type) {
            assertType(type, "string", "type");
            return match(function (actual) {
                return sinon.typeOf(actual) === type;
            }, "typeOf(\"" + type + "\")");
        };

        match.instanceOf = function (type) {
            assertType(type, "function", "type");
            return match(function (actual) {
                return actual instanceof type;
            }, "instanceOf(" + sinon.functionName(type) + ")");
        };

        function createPropertyMatcher(propertyTest, messagePrefix) {
            return function (property, value) {
                assertType(property, "string", "property");
                var onlyProperty = arguments.length === 1;
                var message = messagePrefix + "(\"" + property + "\"";
                if (!onlyProperty) {
                    message += ", " + value;
                }
                message += ")";
                return match(function (actual) {
                    if (actual === undefined || actual === null ||
                            !propertyTest(actual, property)) {
                        return false;
                    }
                    return onlyProperty || sinon.deepEqual(value, actual[property]);
                }, message);
            };
        }

        match.has = createPropertyMatcher(function (actual, property) {
            if (typeof actual === "object") {
                return property in actual;
            }
            return actual[property] !== undefined;
        }, "has");

        match.hasOwn = createPropertyMatcher(function (actual, property) {
            return actual.hasOwnProperty(property);
        }, "hasOwn");

        match.bool = match.typeOf("boolean");
        match.number = match.typeOf("number");
        match.string = match.typeOf("string");
        match.object = match.typeOf("object");
        match.func = match.typeOf("function");
        match.array = match.typeOf("array");
        match.regexp = match.typeOf("regexp");
        match.date = match.typeOf("date");

        sinon.match = match;
        return match;
    }

    var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;

    function loadDependencies(require, exports, module) {
        var sinon = require("./util/core");
        require("./typeOf");
        module.exports = makeApi(sinon);
    }

    if (isAMD) {
        define(loadDependencies);
        return;
    }

    if (isNode) {
        loadDependencies(require, module.exports, module);
        return;
    }

    if (sinonGlobal) {
        makeApi(sinonGlobal);
    }
}(
    typeof sinon === "object" && sinon // eslint-disable-line no-undef
));

},{"./typeOf":160,"./util/core":161}],153:[function(require,module,exports){
/**
 * @depend times_in_words.js
 * @depend util/core.js
 * @depend call.js
 * @depend extend.js
 * @depend match.js
 * @depend spy.js
 * @depend stub.js
 * @depend format.js
 */
/**
 * Mock functions.
 *
 * @author Christian Johansen (christian@cjohansen.no)
 * @license BSD
 *
 * Copyright (c) 2010-2013 Christian Johansen
 */
(function (sinonGlobal) {
    "use strict";

    function makeApi(sinon) {
        var push = [].push;
        var match = sinon.match;

        function mock(object) {
            // if (typeof console !== undefined && console.warn) {
            //     console.warn("mock will be removed from Sinon.JS v2.0");
            // }

            if (!object) {
                return sinon.expectation.create("Anonymous mock");
            }

            return mock.create(object);
        }

        function each(collection, callback) {
            if (!collection) {
                return;
            }

            for (var i = 0, l = collection.length; i < l; i += 1) {
                callback(collection[i]);
            }
        }

        function arrayEquals(arr1, arr2, compareLength) {
            if (compareLength && (arr1.length !== arr2.length)) {
                return false;
            }

            for (var i = 0, l = arr1.length; i < l; i++) {
                if (!sinon.deepEqual(arr1[i], arr2[i])) {
                    return false;
                }
            }
            return true;
        }

        sinon.extend(mock, {
            create: function create(object) {
                if (!object) {
                    throw new TypeError("object is null");
                }

                var mockObject = sinon.extend({}, mock);
                mockObject.object = object;
                delete mockObject.create;

                return mockObject;
            },

            expects: function expects(method) {
                if (!method) {
                    throw new TypeError("method is falsy");
                }

                if (!this.expectations) {
                    this.expectations = {};
                    this.proxies = [];
                }

                if (!this.expectations[method]) {
                    this.expectations[method] = [];
                    var mockObject = this;

                    sinon.wrapMethod(this.object, method, function () {
                        return mockObject.invokeMethod(method, this, arguments);
                    });

                    push.call(this.proxies, method);
                }

                var expectation = sinon.expectation.create(method);
                push.call(this.expectations[method], expectation);

                return expectation;
            },

            restore: function restore() {
                var object = this.object;

                each(this.proxies, function (proxy) {
                    if (typeof object[proxy].restore === "function") {
                        object[proxy].restore();
                    }
                });
            },

            verify: function verify() {
                var expectations = this.expectations || {};
                var messages = [];
                var met = [];

                each(this.proxies, function (proxy) {
                    each(expectations[proxy], function (expectation) {
                        if (!expectation.met()) {
                            push.call(messages, expectation.toString());
                        } else {
                            push.call(met, expectation.toString());
                        }
                    });
                });

                this.restore();

                if (messages.length > 0) {
                    sinon.expectation.fail(messages.concat(met).join("\n"));
                } else if (met.length > 0) {
                    sinon.expectation.pass(messages.concat(met).join("\n"));
                }

                return true;
            },

            invokeMethod: function invokeMethod(method, thisValue, args) {
                var expectations = this.expectations && this.expectations[method] ? this.expectations[method] : [];
                var expectationsWithMatchingArgs = [];
                var currentArgs = args || [];
                var i, available;

                for (i = 0; i < expectations.length; i += 1) {
                    var expectedArgs = expectations[i].expectedArguments || [];
                    if (arrayEquals(expectedArgs, currentArgs, expectations[i].expectsExactArgCount)) {
                        expectationsWithMatchingArgs.push(expectations[i]);
                    }
                }

                for (i = 0; i < expectationsWithMatchingArgs.length; i += 1) {
                    if (!expectationsWithMatchingArgs[i].met() &&
                        expectationsWithMatchingArgs[i].allowsCall(thisValue, args)) {
                        return expectationsWithMatchingArgs[i].apply(thisValue, args);
                    }
                }

                var messages = [];
                var exhausted = 0;

                for (i = 0; i < expectationsWithMatchingArgs.length; i += 1) {
                    if (expectationsWithMatchingArgs[i].allowsCall(thisValue, args)) {
                        available = available || expectationsWithMatchingArgs[i];
                    } else {
                        exhausted += 1;
                    }
                }

                if (available && exhausted === 0) {
                    return available.apply(thisValue, args);
                }

                for (i = 0; i < expectations.length; i += 1) {
                    push.call(messages, "    " + expectations[i].toString());
                }

                messages.unshift("Unexpected call: " + sinon.spyCall.toString.call({
                    proxy: method,
                    args: args
                }));

                sinon.expectation.fail(messages.join("\n"));
            }
        });

        var times = sinon.timesInWords;
        var slice = Array.prototype.slice;

        function callCountInWords(callCount) {
            if (callCount === 0) {
                return "never called";
            }

            return "called " + times(callCount);
        }

        function expectedCallCountInWords(expectation) {
            var min = expectation.minCalls;
            var max = expectation.maxCalls;

            if (typeof min === "number" && typeof max === "number") {
                var str = times(min);

                if (min !== max) {
                    str = "at least " + str + " and at most " + times(max);
                }

                return str;
            }

            if (typeof min === "number") {
                return "at least " + times(min);
            }

            return "at most " + times(max);
        }

        function receivedMinCalls(expectation) {
            var hasMinLimit = typeof expectation.minCalls === "number";
            return !hasMinLimit || expectation.callCount >= expectation.minCalls;
        }

        function receivedMaxCalls(expectation) {
            if (typeof expectation.maxCalls !== "number") {
                return false;
            }

            return expectation.callCount === expectation.maxCalls;
        }

        function verifyMatcher(possibleMatcher, arg) {
            var isMatcher = match && match.isMatcher(possibleMatcher);

            return isMatcher && possibleMatcher.test(arg) || true;
        }

        sinon.expectation = {
            minCalls: 1,
            maxCalls: 1,

            create: function create(methodName) {
                var expectation = sinon.extend(sinon.stub.create(), sinon.expectation);
                delete expectation.create;
                expectation.method = methodName;

                return expectation;
            },

            invoke: function invoke(func, thisValue, args) {
                this.verifyCallAllowed(thisValue, args);

                return sinon.spy.invoke.apply(this, arguments);
            },

            atLeast: function atLeast(num) {
                if (typeof num !== "number") {
                    throw new TypeError("'" + num + "' is not number");
                }

                if (!this.limitsSet) {
                    this.maxCalls = null;
                    this.limitsSet = true;
                }

                this.minCalls = num;

                return this;
            },

            atMost: function atMost(num) {
                if (typeof num !== "number") {
                    throw new TypeError("'" + num + "' is not number");
                }

                if (!this.limitsSet) {
                    this.minCalls = null;
                    this.limitsSet = true;
                }

                this.maxCalls = num;

                return this;
            },

            never: function never() {
                return this.exactly(0);
            },

            once: function once() {
                return this.exactly(1);
            },

            twice: function twice() {
                return this.exactly(2);
            },

            thrice: function thrice() {
                return this.exactly(3);
            },

            exactly: function exactly(num) {
                if (typeof num !== "number") {
                    throw new TypeError("'" + num + "' is not a number");
                }

                this.atLeast(num);
                return this.atMost(num);
            },

            met: function met() {
                return !this.failed && receivedMinCalls(this);
            },

            verifyCallAllowed: function verifyCallAllowed(thisValue, args) {
                if (receivedMaxCalls(this)) {
                    this.failed = true;
                    sinon.expectation.fail(this.method + " already called " + times(this.maxCalls));
                }

                if ("expectedThis" in this && this.expectedThis !== thisValue) {
                    sinon.expectation.fail(this.method + " called with " + thisValue + " as thisValue, expected " +
                        this.expectedThis);
                }

                if (!("expectedArguments" in this)) {
                    return;
                }

                if (!args) {
                    sinon.expectation.fail(this.method + " received no arguments, expected " +
                        sinon.format(this.expectedArguments));
                }

                if (args.length < this.expectedArguments.length) {
                    sinon.expectation.fail(this.method + " received too few arguments (" + sinon.format(args) +
                        "), expected " + sinon.format(this.expectedArguments));
                }

                if (this.expectsExactArgCount &&
                    args.length !== this.expectedArguments.length) {
                    sinon.expectation.fail(this.method + " received too many arguments (" + sinon.format(args) +
                        "), expected " + sinon.format(this.expectedArguments));
                }

                for (var i = 0, l = this.expectedArguments.length; i < l; i += 1) {

                    if (!verifyMatcher(this.expectedArguments[i], args[i])) {
                        sinon.expectation.fail(this.method + " received wrong arguments " + sinon.format(args) +
                            ", didn't match " + this.expectedArguments.toString());
                    }

                    if (!sinon.deepEqual(this.expectedArguments[i], args[i])) {
                        sinon.expectation.fail(this.method + " received wrong arguments " + sinon.format(args) +
                            ", expected " + sinon.format(this.expectedArguments));
                    }
                }
            },

            allowsCall: function allowsCall(thisValue, args) {
                if (this.met() && receivedMaxCalls(this)) {
                    return false;
                }

                if ("expectedThis" in this && this.expectedThis !== thisValue) {
                    return false;
                }

                if (!("expectedArguments" in this)) {
                    return true;
                }

                args = args || [];

                if (args.length < this.expectedArguments.length) {
                    return false;
                }

                if (this.expectsExactArgCount &&
                    args.length !== this.expectedArguments.length) {
                    return false;
                }

                for (var i = 0, l = this.expectedArguments.length; i < l; i += 1) {
                    if (!verifyMatcher(this.expectedArguments[i], args[i])) {
                        return false;
                    }

                    if (!sinon.deepEqual(this.expectedArguments[i], args[i])) {
                        return false;
                    }
                }

                return true;
            },

            withArgs: function withArgs() {
                this.expectedArguments = slice.call(arguments);
                return this;
            },

            withExactArgs: function withExactArgs() {
                this.withArgs.apply(this, arguments);
                this.expectsExactArgCount = true;
                return this;
            },

            on: function on(thisValue) {
                this.expectedThis = thisValue;
                return this;
            },

            toString: function () {
                var args = (this.expectedArguments || []).slice();

                if (!this.expectsExactArgCount) {
                    push.call(args, "[...]");
                }

                var callStr = sinon.spyCall.toString.call({
                    proxy: this.method || "anonymous mock expectation",
                    args: args
                });

                var message = callStr.replace(", [...", "[, ...") + " " +
                    expectedCallCountInWords(this);

                if (this.met()) {
                    return "Expectation met: " + message;
                }

                return "Expected " + message + " (" +
                    callCountInWords(this.callCount) + ")";
            },

            verify: function verify() {
                if (!this.met()) {
                    sinon.expectation.fail(this.toString());
                } else {
                    sinon.expectation.pass(this.toString());
                }

                return true;
            },

            pass: function pass(message) {
                sinon.assert.pass(message);
            },

            fail: function fail(message) {
                var exception = new Error(message);
                exception.name = "ExpectationError";

                throw exception;
            }
        };

        sinon.mock = mock;
        return mock;
    }

    var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;

    function loadDependencies(require, exports, module) {
        var sinon = require("./util/core");
        require("./times_in_words");
        require("./call");
        require("./extend");
        require("./match");
        require("./spy");
        require("./stub");
        require("./format");

        module.exports = makeApi(sinon);
    }

    if (isAMD) {
        define(loadDependencies);
        return;
    }

    if (isNode) {
        loadDependencies(require, module.exports, module);
        return;
    }

    if (sinonGlobal) {
        makeApi(sinonGlobal);
    }
}(
    typeof sinon === "object" && sinon // eslint-disable-line no-undef
));

},{"./call":147,"./extend":149,"./format":150,"./match":152,"./spy":155,"./stub":156,"./times_in_words":159,"./util/core":161}],154:[function(require,module,exports){
/**
 * @depend util/core.js
 * @depend extend.js
 * @depend collection.js
 * @depend util/fake_timers.js
 * @depend util/fake_server_with_clock.js
 */
/**
 * Manages fake collections as well as fake utilities such as Sinon's
 * timers and fake XHR implementation in one convenient object.
 *
 * @author Christian Johansen (christian@cjohansen.no)
 * @license BSD
 *
 * Copyright (c) 2010-2013 Christian Johansen
 */
(function (sinonGlobal) {
    "use strict";

    function makeApi(sinon) {
        var push = [].push;

        function exposeValue(sandbox, config, key, value) {
            if (!value) {
                return;
            }

            if (config.injectInto && !(key in config.injectInto)) {
                config.injectInto[key] = value;
                sandbox.injectedKeys.push(key);
            } else {
                push.call(sandbox.args, value);
            }
        }

        function prepareSandboxFromConfig(config) {
            var sandbox = sinon.create(sinon.sandbox);

            if (config.useFakeServer) {
                if (typeof config.useFakeServer === "object") {
                    sandbox.serverPrototype = config.useFakeServer;
                }

                sandbox.useFakeServer();
            }

            if (config.useFakeTimers) {
                if (typeof config.useFakeTimers === "object") {
                    sandbox.useFakeTimers.apply(sandbox, config.useFakeTimers);
                } else {
                    sandbox.useFakeTimers();
                }
            }

            return sandbox;
        }

        sinon.sandbox = sinon.extend(sinon.create(sinon.collection), {
            useFakeTimers: function useFakeTimers() {
                this.clock = sinon.useFakeTimers.apply(sinon, arguments);

                return this.add(this.clock);
            },

            serverPrototype: sinon.fakeServer,

            useFakeServer: function useFakeServer() {
                var proto = this.serverPrototype || sinon.fakeServer;

                if (!proto || !proto.create) {
                    return null;
                }

                this.server = proto.create();
                return this.add(this.server);
            },

            inject: function (obj) {
                sinon.collection.inject.call(this, obj);

                if (this.clock) {
                    obj.clock = this.clock;
                }

                if (this.server) {
                    obj.server = this.server;
                    obj.requests = this.server.requests;
                }

                obj.match = sinon.match;

                return obj;
            },

            restore: function () {
                sinon.collection.restore.apply(this, arguments);
                this.restoreContext();
            },

            restoreContext: function () {
                if (this.injectedKeys) {
                    for (var i = 0, j = this.injectedKeys.length; i < j; i++) {
                        delete this.injectInto[this.injectedKeys[i]];
                    }
                    this.injectedKeys = [];
                }
            },

            create: function (config) {
                if (!config) {
                    return sinon.create(sinon.sandbox);
                }

                var sandbox = prepareSandboxFromConfig(config);
                sandbox.args = sandbox.args || [];
                sandbox.injectedKeys = [];
                sandbox.injectInto = config.injectInto;
                var prop,
                    value;
                var exposed = sandbox.inject({});

                if (config.properties) {
                    for (var i = 0, l = config.properties.length; i < l; i++) {
                        prop = config.properties[i];
                        value = exposed[prop] || prop === "sandbox" && sandbox;
                        exposeValue(sandbox, config, prop, value);
                    }
                } else {
                    exposeValue(sandbox, config, "sandbox", value);
                }

                return sandbox;
            },

            match: sinon.match
        });

        sinon.sandbox.useFakeXMLHttpRequest = sinon.sandbox.useFakeServer;

        return sinon.sandbox;
    }

    var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;

    function loadDependencies(require, exports, module) {
        var sinon = require("./util/core");
        require("./extend");
        require("./util/fake_server_with_clock");
        require("./util/fake_timers");
        require("./collection");
        module.exports = makeApi(sinon);
    }

    if (isAMD) {
        define(loadDependencies);
        return;
    }

    if (isNode) {
        loadDependencies(require, module.exports, module);
        return;
    }

    if (sinonGlobal) {
        makeApi(sinonGlobal);
    }
}(
    typeof sinon === "object" && sinon // eslint-disable-line no-undef
));

},{"./collection":148,"./extend":149,"./util/core":161,"./util/fake_server_with_clock":164,"./util/fake_timers":165}],155:[function(require,module,exports){
/**
  * @depend times_in_words.js
  * @depend util/core.js
  * @depend extend.js
  * @depend call.js
  * @depend format.js
  */
/**
  * Spy functions
  *
  * @author Christian Johansen (christian@cjohansen.no)
  * @license BSD
  *
  * Copyright (c) 2010-2013 Christian Johansen
  */
(function (sinonGlobal) {
    "use strict";

    function makeApi(sinon) {
        var push = Array.prototype.push;
        var slice = Array.prototype.slice;
        var callId = 0;

        function spy(object, property, types) {
            if (!property && typeof object === "function") {
                return spy.create(object);
            }

            if (!object && !property) {
                return spy.create(function () { });
            }

            if (types) {
                var methodDesc = sinon.getPropertyDescriptor(object, property);
                for (var i = 0; i < types.length; i++) {
                    methodDesc[types[i]] = spy.create(methodDesc[types[i]]);
                }
                return sinon.wrapMethod(object, property, methodDesc);
            }

            return sinon.wrapMethod(object, property, spy.create(object[property]));
        }

        function matchingFake(fakes, args, strict) {
            if (!fakes) {
                return undefined;
            }

            for (var i = 0, l = fakes.length; i < l; i++) {
                if (fakes[i].matches(args, strict)) {
                    return fakes[i];
                }
            }
        }

        function incrementCallCount() {
            this.called = true;
            this.callCount += 1;
            this.notCalled = false;
            this.calledOnce = this.callCount === 1;
            this.calledTwice = this.callCount === 2;
            this.calledThrice = this.callCount === 3;
        }

        function createCallProperties() {
            this.firstCall = this.getCall(0);
            this.secondCall = this.getCall(1);
            this.thirdCall = this.getCall(2);
            this.lastCall = this.getCall(this.callCount - 1);
        }

        var vars = "a,b,c,d,e,f,g,h,i,j,k,l";
        function createProxy(func, proxyLength) {
            // Retain the function length:
            var p;
            if (proxyLength) {
                eval("p = (function proxy(" + vars.substring(0, proxyLength * 2 - 1) + // eslint-disable-line no-eval
                    ") { return p.invoke(func, this, slice.call(arguments)); });");
            } else {
                p = function proxy() {
                    return p.invoke(func, this, slice.call(arguments));
                };
            }
            p.isSinonProxy = true;
            return p;
        }

        var uuid = 0;

        // Public API
        var spyApi = {
            reset: function () {
                if (this.invoking) {
                    var err = new Error("Cannot reset Sinon function while invoking it. " +
                                        "Move the call to .reset outside of the callback.");
                    err.name = "InvalidResetException";
                    throw err;
                }

                this.called = false;
                this.notCalled = true;
                this.calledOnce = false;
                this.calledTwice = false;
                this.calledThrice = false;
                this.callCount = 0;
                this.firstCall = null;
                this.secondCall = null;
                this.thirdCall = null;
                this.lastCall = null;
                this.args = [];
                this.returnValues = [];
                this.thisValues = [];
                this.exceptions = [];
                this.callIds = [];
                this.stacks = [];
                if (this.fakes) {
                    for (var i = 0; i < this.fakes.length; i++) {
                        this.fakes[i].reset();
                    }
                }

                return this;
            },

            create: function create(func, spyLength) {
                var name;

                if (typeof func !== "function") {
                    func = function () { };
                } else {
                    name = sinon.functionName(func);
                }

                if (!spyLength) {
                    spyLength = func.length;
                }

                var proxy = createProxy(func, spyLength);

                sinon.extend(proxy, spy);
                delete proxy.create;
                sinon.extend(proxy, func);

                proxy.reset();
                proxy.prototype = func.prototype;
                proxy.displayName = name || "spy";
                proxy.toString = sinon.functionToString;
                proxy.instantiateFake = sinon.spy.create;
                proxy.id = "spy#" + uuid++;

                return proxy;
            },

            invoke: function invoke(func, thisValue, args) {
                var matching = matchingFake(this.fakes, args);
                var exception, returnValue;

                incrementCallCount.call(this);
                push.call(this.thisValues, thisValue);
                push.call(this.args, args);
                push.call(this.callIds, callId++);

                // Make call properties available from within the spied function:
                createCallProperties.call(this);

                try {
                    this.invoking = true;

                    if (matching) {
                        returnValue = matching.invoke(func, thisValue, args);
                    } else {
                        returnValue = (this.func || func).apply(thisValue, args);
                    }

                    var thisCall = this.getCall(this.callCount - 1);
                    if (thisCall.calledWithNew() && typeof returnValue !== "object") {
                        returnValue = thisValue;
                    }
                } catch (e) {
                    exception = e;
                } finally {
                    delete this.invoking;
                }

                push.call(this.exceptions, exception);
                push.call(this.returnValues, returnValue);
                push.call(this.stacks, new Error().stack);

                // Make return value and exception available in the calls:
                createCallProperties.call(this);

                if (exception !== undefined) {
                    throw exception;
                }

                return returnValue;
            },

            named: function named(name) {
                this.displayName = name;
                return this;
            },

            getCall: function getCall(i) {
                if (i < 0 || i >= this.callCount) {
                    return null;
                }

                return sinon.spyCall(this, this.thisValues[i], this.args[i],
                                        this.returnValues[i], this.exceptions[i],
                                        this.callIds[i], this.stacks[i]);
            },

            getCalls: function () {
                var calls = [];
                var i;

                for (i = 0; i < this.callCount; i++) {
                    calls.push(this.getCall(i));
                }

                return calls;
            },

            calledBefore: function calledBefore(spyFn) {
                if (!this.called) {
                    return false;
                }

                if (!spyFn.called) {
                    return true;
                }

                return this.callIds[0] < spyFn.callIds[spyFn.callIds.length - 1];
            },

            calledAfter: function calledAfter(spyFn) {
                if (!this.called || !spyFn.called) {
                    return false;
                }

                return this.callIds[this.callCount - 1] > spyFn.callIds[spyFn.callCount - 1];
            },

            withArgs: function () {
                var args = slice.call(arguments);

                if (this.fakes) {
                    var match = matchingFake(this.fakes, args, true);

                    if (match) {
                        return match;
                    }
                } else {
                    this.fakes = [];
                }

                var original = this;
                var fake = this.instantiateFake();
                fake.matchingAguments = args;
                fake.parent = this;
                push.call(this.fakes, fake);

                fake.withArgs = function () {
                    return original.withArgs.apply(original, arguments);
                };

                for (var i = 0; i < this.args.length; i++) {
                    if (fake.matches(this.args[i])) {
                        incrementCallCount.call(fake);
                        push.call(fake.thisValues, this.thisValues[i]);
                        push.call(fake.args, this.args[i]);
                        push.call(fake.returnValues, this.returnValues[i]);
                        push.call(fake.exceptions, this.exceptions[i]);
                        push.call(fake.callIds, this.callIds[i]);
                    }
                }
                createCallProperties.call(fake);

                return fake;
            },

            matches: function (args, strict) {
                var margs = this.matchingAguments;

                if (margs.length <= args.length &&
                    sinon.deepEqual(margs, args.slice(0, margs.length))) {
                    return !strict || margs.length === args.length;
                }
            },

            printf: function (format) {
                var spyInstance = this;
                var args = slice.call(arguments, 1);
                var formatter;

                return (format || "").replace(/%(.)/g, function (match, specifyer) {
                    formatter = spyApi.formatters[specifyer];

                    if (typeof formatter === "function") {
                        return formatter.call(null, spyInstance, args);
                    } else if (!isNaN(parseInt(specifyer, 10))) {
                        return sinon.format(args[specifyer - 1]);
                    }

                    return "%" + specifyer;
                });
            }
        };

        function delegateToCalls(method, matchAny, actual, notCalled) {
            spyApi[method] = function () {
                if (!this.called) {
                    if (notCalled) {
                        return notCalled.apply(this, arguments);
                    }
                    return false;
                }

                var currentCall;
                var matches = 0;

                for (var i = 0, l = this.callCount; i < l; i += 1) {
                    currentCall = this.getCall(i);

                    if (currentCall[actual || method].apply(currentCall, arguments)) {
                        matches += 1;

                        if (matchAny) {
                            return true;
                        }
                    }
                }

                return matches === this.callCount;
            };
        }

        delegateToCalls("calledOn", true);
        delegateToCalls("alwaysCalledOn", false, "calledOn");
        delegateToCalls("calledWith", true);
        delegateToCalls("calledWithMatch", true);
        delegateToCalls("alwaysCalledWith", false, "calledWith");
        delegateToCalls("alwaysCalledWithMatch", false, "calledWithMatch");
        delegateToCalls("calledWithExactly", true);
        delegateToCalls("alwaysCalledWithExactly", false, "calledWithExactly");
        delegateToCalls("neverCalledWith", false, "notCalledWith", function () {
            return true;
        });
        delegateToCalls("neverCalledWithMatch", false, "notCalledWithMatch", function () {
            return true;
        });
        delegateToCalls("threw", true);
        delegateToCalls("alwaysThrew", false, "threw");
        delegateToCalls("returned", true);
        delegateToCalls("alwaysReturned", false, "returned");
        delegateToCalls("calledWithNew", true);
        delegateToCalls("alwaysCalledWithNew", false, "calledWithNew");
        delegateToCalls("callArg", false, "callArgWith", function () {
            throw new Error(this.toString() + " cannot call arg since it was not yet invoked.");
        });
        spyApi.callArgWith = spyApi.callArg;
        delegateToCalls("callArgOn", false, "callArgOnWith", function () {
            throw new Error(this.toString() + " cannot call arg since it was not yet invoked.");
        });
        spyApi.callArgOnWith = spyApi.callArgOn;
        delegateToCalls("yield", false, "yield", function () {
            throw new Error(this.toString() + " cannot yield since it was not yet invoked.");
        });
        // "invokeCallback" is an alias for "yield" since "yield" is invalid in strict mode.
        spyApi.invokeCallback = spyApi.yield;
        delegateToCalls("yieldOn", false, "yieldOn", function () {
            throw new Error(this.toString() + " cannot yield since it was not yet invoked.");
        });
        delegateToCalls("yieldTo", false, "yieldTo", function (property) {
            throw new Error(this.toString() + " cannot yield to '" + property +
                "' since it was not yet invoked.");
        });
        delegateToCalls("yieldToOn", false, "yieldToOn", function (property) {
            throw new Error(this.toString() + " cannot yield to '" + property +
                "' since it was not yet invoked.");
        });

        spyApi.formatters = {
            c: function (spyInstance) {
                return sinon.timesInWords(spyInstance.callCount);
            },

            n: function (spyInstance) {
                return spyInstance.toString();
            },

            C: function (spyInstance) {
                var calls = [];

                for (var i = 0, l = spyInstance.callCount; i < l; ++i) {
                    var stringifiedCall = "    " + spyInstance.getCall(i).toString();
                    if (/\n/.test(calls[i - 1])) {
                        stringifiedCall = "\n" + stringifiedCall;
                    }
                    push.call(calls, stringifiedCall);
                }

                return calls.length > 0 ? "\n" + calls.join("\n") : "";
            },

            t: function (spyInstance) {
                var objects = [];

                for (var i = 0, l = spyInstance.callCount; i < l; ++i) {
                    push.call(objects, sinon.format(spyInstance.thisValues[i]));
                }

                return objects.join(", ");
            },

            "*": function (spyInstance, args) {
                var formatted = [];

                for (var i = 0, l = args.length; i < l; ++i) {
                    push.call(formatted, sinon.format(args[i]));
                }

                return formatted.join(", ");
            }
        };

        sinon.extend(spy, spyApi);

        spy.spyCall = sinon.spyCall;
        sinon.spy = spy;

        return spy;
    }

    var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;

    function loadDependencies(require, exports, module) {
        var core = require("./util/core");
        require("./call");
        require("./extend");
        require("./times_in_words");
        require("./format");
        module.exports = makeApi(core);
    }

    if (isAMD) {
        define(loadDependencies);
        return;
    }

    if (isNode) {
        loadDependencies(require, module.exports, module);
        return;
    }

    if (sinonGlobal) {
        makeApi(sinonGlobal);
    }
}(
    typeof sinon === "object" && sinon // eslint-disable-line no-undef
));

},{"./call":147,"./extend":149,"./format":150,"./times_in_words":159,"./util/core":161}],156:[function(require,module,exports){
/**
 * @depend util/core.js
 * @depend extend.js
 * @depend spy.js
 * @depend behavior.js
 * @depend walk.js
 */
/**
 * Stub functions
 *
 * @author Christian Johansen (christian@cjohansen.no)
 * @license BSD
 *
 * Copyright (c) 2010-2013 Christian Johansen
 */
(function (sinonGlobal) {
    "use strict";

    function makeApi(sinon) {
        function stub(object, property, func) {
            if (!!func && typeof func !== "function" && typeof func !== "object") {
                throw new TypeError("Custom stub should be a function or a property descriptor");
            }

            var wrapper;

            if (func) {
                if (typeof func === "function") {
                    wrapper = sinon.spy && sinon.spy.create ? sinon.spy.create(func) : func;
                } else {
                    wrapper = func;
                    if (sinon.spy && sinon.spy.create) {
                        var types = sinon.objectKeys(wrapper);
                        for (var i = 0; i < types.length; i++) {
                            wrapper[types[i]] = sinon.spy.create(wrapper[types[i]]);
                        }
                    }
                }
            } else {
                var stubLength = 0;
                if (typeof object === "object" && typeof object[property] === "function") {
                    stubLength = object[property].length;
                }
                wrapper = stub.create(stubLength);
            }

            if (!object && typeof property === "undefined") {
                return sinon.stub.create();
            }

            if (typeof property === "undefined" && typeof object === "object") {
                sinon.walk(object || {}, function (value, prop, propOwner) {
                    // we don't want to stub things like toString(), valueOf(), etc. so we only stub if the object
                    // is not Object.prototype
                    if (
                        propOwner !== Object.prototype &&
                        prop !== "constructor" &&
                        typeof sinon.getPropertyDescriptor(propOwner, prop).value === "function"
                    ) {
                        stub(object, prop);
                    }
                });

                return object;
            }

            return sinon.wrapMethod(object, property, wrapper);
        }


        /*eslint-disable no-use-before-define*/
        function getParentBehaviour(stubInstance) {
            return (stubInstance.parent && getCurrentBehavior(stubInstance.parent));
        }

        function getDefaultBehavior(stubInstance) {
            return stubInstance.defaultBehavior ||
                    getParentBehaviour(stubInstance) ||
                    sinon.behavior.create(stubInstance);
        }

        function getCurrentBehavior(stubInstance) {
            var behavior = stubInstance.behaviors[stubInstance.callCount - 1];
            return behavior && behavior.isPresent() ? behavior : getDefaultBehavior(stubInstance);
        }
        /*eslint-enable no-use-before-define*/

        var uuid = 0;

        var proto = {
            create: function create(stubLength) {
                var functionStub = function () {
                    return getCurrentBehavior(functionStub).invoke(this, arguments);
                };

                functionStub.id = "stub#" + uuid++;
                var orig = functionStub;
                functionStub = sinon.spy.create(functionStub, stubLength);
                functionStub.func = orig;

                sinon.extend(functionStub, stub);
                functionStub.instantiateFake = sinon.stub.create;
                functionStub.displayName = "stub";
                functionStub.toString = sinon.functionToString;

                functionStub.defaultBehavior = null;
                functionStub.behaviors = [];

                return functionStub;
            },

            resetBehavior: function () {
                var i;

                this.defaultBehavior = null;
                this.behaviors = [];

                delete this.returnValue;
                delete this.returnArgAt;
                this.returnThis = false;

                if (this.fakes) {
                    for (i = 0; i < this.fakes.length; i++) {
                        this.fakes[i].resetBehavior();
                    }
                }
            },

            onCall: function onCall(index) {
                if (!this.behaviors[index]) {
                    this.behaviors[index] = sinon.behavior.create(this);
                }

                return this.behaviors[index];
            },

            onFirstCall: function onFirstCall() {
                return this.onCall(0);
            },

            onSecondCall: function onSecondCall() {
                return this.onCall(1);
            },

            onThirdCall: function onThirdCall() {
                return this.onCall(2);
            }
        };

        function createBehavior(behaviorMethod) {
            return function () {
                this.defaultBehavior = this.defaultBehavior || sinon.behavior.create(this);
                this.defaultBehavior[behaviorMethod].apply(this.defaultBehavior, arguments);
                return this;
            };
        }

        for (var method in sinon.behavior) {
            if (sinon.behavior.hasOwnProperty(method) &&
                !proto.hasOwnProperty(method) &&
                method !== "create" &&
                method !== "withArgs" &&
                method !== "invoke") {
                proto[method] = createBehavior(method);
            }
        }

        sinon.extend(stub, proto);
        sinon.stub = stub;

        return stub;
    }

    var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;

    function loadDependencies(require, exports, module) {
        var core = require("./util/core");
        require("./behavior");
        require("./spy");
        require("./extend");
        module.exports = makeApi(core);
    }

    if (isAMD) {
        define(loadDependencies);
        return;
    }

    if (isNode) {
        loadDependencies(require, module.exports, module);
        return;
    }

    if (sinonGlobal) {
        makeApi(sinonGlobal);
    }
}(
    typeof sinon === "object" && sinon // eslint-disable-line no-undef
));

},{"./behavior":146,"./extend":149,"./spy":155,"./util/core":161}],157:[function(require,module,exports){
/**
 * @depend util/core.js
 * @depend sandbox.js
 */
/**
 * Test function, sandboxes fakes
 *
 * @author Christian Johansen (christian@cjohansen.no)
 * @license BSD
 *
 * Copyright (c) 2010-2013 Christian Johansen
 */
(function (sinonGlobal) {
    "use strict";

    function makeApi(sinon) {
        var slice = Array.prototype.slice;

        function test(callback) {
            var type = typeof callback;

            if (type !== "function") {
                throw new TypeError("sinon.test needs to wrap a test function, got " + type);
            }

            function sinonSandboxedTest() {
                var config = sinon.getConfig(sinon.config);
                config.injectInto = config.injectIntoThis && this || config.injectInto;
                var sandbox = sinon.sandbox.create(config);
                var args = slice.call(arguments);
                var oldDone = args.length && args[args.length - 1];
                var exception, result;

                if (typeof oldDone === "function") {
                    args[args.length - 1] = function sinonDone(res) {
                        if (res) {
                            sandbox.restore();
                        } else {
                            sandbox.verifyAndRestore();
                        }
                        oldDone(res);
                    };
                }

                try {
                    result = callback.apply(this, args.concat(sandbox.args));
                } catch (e) {
                    exception = e;
                }

                if (typeof oldDone !== "function") {
                    if (typeof exception !== "undefined") {
                        sandbox.restore();
                        throw exception;
                    } else {
                        sandbox.verifyAndRestore();
                    }
                }

                return result;
            }

            if (callback.length) {
                return function sinonAsyncSandboxedTest(done) { // eslint-disable-line no-unused-vars
                    return sinonSandboxedTest.apply(this, arguments);
                };
            }

            return sinonSandboxedTest;
        }

        test.config = {
            injectIntoThis: true,
            injectInto: null,
            properties: ["spy", "stub", "mock", "clock", "server", "requests"],
            useFakeTimers: true,
            useFakeServer: true
        };

        sinon.test = test;
        return test;
    }

    var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;

    function loadDependencies(require, exports, module) {
        var core = require("./util/core");
        require("./sandbox");
        module.exports = makeApi(core);
    }

    if (isAMD) {
        define(loadDependencies);
    } else if (isNode) {
        loadDependencies(require, module.exports, module);
    } else if (sinonGlobal) {
        makeApi(sinonGlobal);
    }
}(typeof sinon === "object" && sinon || null)); // eslint-disable-line no-undef

},{"./sandbox":154,"./util/core":161}],158:[function(require,module,exports){
/**
 * @depend util/core.js
 * @depend test.js
 */
/**
 * Test case, sandboxes all test functions
 *
 * @author Christian Johansen (christian@cjohansen.no)
 * @license BSD
 *
 * Copyright (c) 2010-2013 Christian Johansen
 */
(function (sinonGlobal) {
    "use strict";

    function createTest(property, setUp, tearDown) {
        return function () {
            if (setUp) {
                setUp.apply(this, arguments);
            }

            var exception, result;

            try {
                result = property.apply(this, arguments);
            } catch (e) {
                exception = e;
            }

            if (tearDown) {
                tearDown.apply(this, arguments);
            }

            if (exception) {
                throw exception;
            }

            return result;
        };
    }

    function makeApi(sinon) {
        function testCase(tests, prefix) {
            if (!tests || typeof tests !== "object") {
                throw new TypeError("sinon.testCase needs an object with test functions");
            }

            prefix = prefix || "test";
            var rPrefix = new RegExp("^" + prefix);
            var methods = {};
            var setUp = tests.setUp;
            var tearDown = tests.tearDown;
            var testName,
                property,
                method;

            for (testName in tests) {
                if (tests.hasOwnProperty(testName) && !/^(setUp|tearDown)$/.test(testName)) {
                    property = tests[testName];

                    if (typeof property === "function" && rPrefix.test(testName)) {
                        method = property;

                        if (setUp || tearDown) {
                            method = createTest(property, setUp, tearDown);
                        }

                        methods[testName] = sinon.test(method);
                    } else {
                        methods[testName] = tests[testName];
                    }
                }
            }

            return methods;
        }

        sinon.testCase = testCase;
        return testCase;
    }

    var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;

    function loadDependencies(require, exports, module) {
        var core = require("./util/core");
        require("./test");
        module.exports = makeApi(core);
    }

    if (isAMD) {
        define(loadDependencies);
        return;
    }

    if (isNode) {
        loadDependencies(require, module.exports, module);
        return;
    }

    if (sinonGlobal) {
        makeApi(sinonGlobal);
    }
}(
    typeof sinon === "object" && sinon // eslint-disable-line no-undef
));

},{"./test":157,"./util/core":161}],159:[function(require,module,exports){
/**
 * @depend util/core.js
 */
(function (sinonGlobal) {
    "use strict";

    function makeApi(sinon) {

        function timesInWords(count) {
            switch (count) {
                case 1:
                    return "once";
                case 2:
                    return "twice";
                case 3:
                    return "thrice";
                default:
                    return (count || 0) + " times";
            }
        }

        sinon.timesInWords = timesInWords;
        return sinon.timesInWords;
    }

    function loadDependencies(require, exports, module) {
        var core = require("./util/core");
        module.exports = makeApi(core);
    }

    var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;

    if (isAMD) {
        define(loadDependencies);
        return;
    }

    if (isNode) {
        loadDependencies(require, module.exports, module);
        return;
    }

    if (sinonGlobal) {
        makeApi(sinonGlobal);
    }
}(
    typeof sinon === "object" && sinon // eslint-disable-line no-undef
));

},{"./util/core":161}],160:[function(require,module,exports){
/**
 * @depend util/core.js
 */
/**
 * Format functions
 *
 * @author Christian Johansen (christian@cjohansen.no)
 * @license BSD
 *
 * Copyright (c) 2010-2014 Christian Johansen
 */
(function (sinonGlobal) {
    "use strict";

    function makeApi(sinon) {
        function typeOf(value) {
            if (value === null) {
                return "null";
            } else if (value === undefined) {
                return "undefined";
            }
            var string = Object.prototype.toString.call(value);
            return string.substring(8, string.length - 1).toLowerCase();
        }

        sinon.typeOf = typeOf;
        return sinon.typeOf;
    }

    function loadDependencies(require, exports, module) {
        var core = require("./util/core");
        module.exports = makeApi(core);
    }

    var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;

    if (isAMD) {
        define(loadDependencies);
        return;
    }

    if (isNode) {
        loadDependencies(require, module.exports, module);
        return;
    }

    if (sinonGlobal) {
        makeApi(sinonGlobal);
    }
}(
    typeof sinon === "object" && sinon // eslint-disable-line no-undef
));

},{"./util/core":161}],161:[function(require,module,exports){
/**
 * @depend ../../sinon.js
 */
/**
 * Sinon core utilities. For internal use only.
 *
 * @author Christian Johansen (christian@cjohansen.no)
 * @license BSD
 *
 * Copyright (c) 2010-2013 Christian Johansen
 */
(function (sinonGlobal) {
    "use strict";

    var div = typeof document !== "undefined" && document.createElement("div");
    var hasOwn = Object.prototype.hasOwnProperty;

    function isDOMNode(obj) {
        var success = false;

        try {
            obj.appendChild(div);
            success = div.parentNode === obj;
        } catch (e) {
            return false;
        } finally {
            try {
                obj.removeChild(div);
            } catch (e) {
                // Remove failed, not much we can do about that
            }
        }

        return success;
    }

    function isElement(obj) {
        return div && obj && obj.nodeType === 1 && isDOMNode(obj);
    }

    function isFunction(obj) {
        return typeof obj === "function" || !!(obj && obj.constructor && obj.call && obj.apply);
    }

    function isReallyNaN(val) {
        return typeof val === "number" && isNaN(val);
    }

    function mirrorProperties(target, source) {
        for (var prop in source) {
            if (!hasOwn.call(target, prop)) {
                target[prop] = source[prop];
            }
        }
    }

    function isRestorable(obj) {
        return typeof obj === "function" && typeof obj.restore === "function" && obj.restore.sinon;
    }

    // Cheap way to detect if we have ES5 support.
    var hasES5Support = "keys" in Object;

    function makeApi(sinon) {
        sinon.wrapMethod = function wrapMethod(object, property, method) {
            if (!object) {
                throw new TypeError("Should wrap property of object");
            }

            if (typeof method !== "function" && typeof method !== "object") {
                throw new TypeError("Method wrapper should be a function or a property descriptor");
            }

            function checkWrappedMethod(wrappedMethod) {
                var error;

                if (!isFunction(wrappedMethod)) {
                    error = new TypeError("Attempted to wrap " + (typeof wrappedMethod) + " property " +
                                        property + " as function");
                } else if (wrappedMethod.restore && wrappedMethod.restore.sinon) {
                    error = new TypeError("Attempted to wrap " + property + " which is already wrapped");
                } else if (wrappedMethod.calledBefore) {
                    var verb = wrappedMethod.returns ? "stubbed" : "spied on";
                    error = new TypeError("Attempted to wrap " + property + " which is already " + verb);
                }

                if (error) {
                    if (wrappedMethod && wrappedMethod.stackTrace) {
                        error.stack += "\n--------------\n" + wrappedMethod.stackTrace;
                    }
                    throw error;
                }
            }

            var error, wrappedMethod, i;

            // IE 8 does not support hasOwnProperty on the window object and Firefox has a problem
            // when using hasOwn.call on objects from other frames.
            var owned = object.hasOwnProperty ? object.hasOwnProperty(property) : hasOwn.call(object, property);

            if (hasES5Support) {
                var methodDesc = (typeof method === "function") ? {value: method} : method;
                var wrappedMethodDesc = sinon.getPropertyDescriptor(object, property);

                if (!wrappedMethodDesc) {
                    error = new TypeError("Attempted to wrap " + (typeof wrappedMethod) + " property " +
                                        property + " as function");
                } else if (wrappedMethodDesc.restore && wrappedMethodDesc.restore.sinon) {
                    error = new TypeError("Attempted to wrap " + property + " which is already wrapped");
                }
                if (error) {
                    if (wrappedMethodDesc && wrappedMethodDesc.stackTrace) {
                        error.stack += "\n--------------\n" + wrappedMethodDesc.stackTrace;
                    }
                    throw error;
                }

                var types = sinon.objectKeys(methodDesc);
                for (i = 0; i < types.length; i++) {
                    wrappedMethod = wrappedMethodDesc[types[i]];
                    checkWrappedMethod(wrappedMethod);
                }

                mirrorProperties(methodDesc, wrappedMethodDesc);
                for (i = 0; i < types.length; i++) {
                    mirrorProperties(methodDesc[types[i]], wrappedMethodDesc[types[i]]);
                }
                Object.defineProperty(object, property, methodDesc);
            } else {
                wrappedMethod = object[property];
                checkWrappedMethod(wrappedMethod);
                object[property] = method;
                method.displayName = property;
            }

            method.displayName = property;

            // Set up a stack trace which can be used later to find what line of
            // code the original method was created on.
            method.stackTrace = (new Error("Stack Trace for original")).stack;

            method.restore = function () {
                // For prototype properties try to reset by delete first.
                // If this fails (ex: localStorage on mobile safari) then force a reset
                // via direct assignment.
                if (!owned) {
                    // In some cases `delete` may throw an error
                    try {
                        delete object[property];
                    } catch (e) {} // eslint-disable-line no-empty
                    // For native code functions `delete` fails without throwing an error
                    // on Chrome < 43, PhantomJS, etc.
                } else if (hasES5Support) {
                    Object.defineProperty(object, property, wrappedMethodDesc);
                }

                // Use strict equality comparison to check failures then force a reset
                // via direct assignment.
                if (object[property] === method) {
                    object[property] = wrappedMethod;
                }
            };

            method.restore.sinon = true;

            if (!hasES5Support) {
                mirrorProperties(method, wrappedMethod);
            }

            return method;
        };

        sinon.create = function create(proto) {
            var F = function () {};
            F.prototype = proto;
            return new F();
        };

        sinon.deepEqual = function deepEqual(a, b) {
            if (sinon.match && sinon.match.isMatcher(a)) {
                return a.test(b);
            }

            if (typeof a !== "object" || typeof b !== "object") {
                return isReallyNaN(a) && isReallyNaN(b) || a === b;
            }

            if (isElement(a) || isElement(b)) {
                return a === b;
            }

            if (a === b) {
                return true;
            }

            if ((a === null && b !== null) || (a !== null && b === null)) {
                return false;
            }

            if (a instanceof RegExp && b instanceof RegExp) {
                return (a.source === b.source) && (a.global === b.global) &&
                    (a.ignoreCase === b.ignoreCase) && (a.multiline === b.multiline);
            }

            var aString = Object.prototype.toString.call(a);
            if (aString !== Object.prototype.toString.call(b)) {
                return false;
            }

            if (aString === "[object Date]") {
                return a.valueOf() === b.valueOf();
            }

            var prop;
            var aLength = 0;
            var bLength = 0;

            if (aString === "[object Array]" && a.length !== b.length) {
                return false;
            }

            for (prop in a) {
                if (a.hasOwnProperty(prop)) {
                    aLength += 1;

                    if (!(prop in b)) {
                        return false;
                    }

                    if (!deepEqual(a[prop], b[prop])) {
                        return false;
                    }
                }
            }

            for (prop in b) {
                if (b.hasOwnProperty(prop)) {
                    bLength += 1;
                }
            }

            return aLength === bLength;
        };

        sinon.functionName = function functionName(func) {
            var name = func.displayName || func.name;

            // Use function decomposition as a last resort to get function
            // name. Does not rely on function decomposition to work - if it
            // doesn't debugging will be slightly less informative
            // (i.e. toString will say 'spy' rather than 'myFunc').
            if (!name) {
                var matches = func.toString().match(/function ([^\s\(]+)/);
                name = matches && matches[1];
            }

            return name;
        };

        sinon.functionToString = function toString() {
            if (this.getCall && this.callCount) {
                var thisValue,
                    prop;
                var i = this.callCount;

                while (i--) {
                    thisValue = this.getCall(i).thisValue;

                    for (prop in thisValue) {
                        if (thisValue[prop] === this) {
                            return prop;
                        }
                    }
                }
            }

            return this.displayName || "sinon fake";
        };

        sinon.objectKeys = function objectKeys(obj) {
            if (obj !== Object(obj)) {
                throw new TypeError("sinon.objectKeys called on a non-object");
            }

            var keys = [];
            var key;
            for (key in obj) {
                if (hasOwn.call(obj, key)) {
                    keys.push(key);
                }
            }

            return keys;
        };

        sinon.getPropertyDescriptor = function getPropertyDescriptor(object, property) {
            var proto = object;
            var descriptor;

            while (proto && !(descriptor = Object.getOwnPropertyDescriptor(proto, property))) {
                proto = Object.getPrototypeOf(proto);
            }
            return descriptor;
        };

        sinon.getConfig = function (custom) {
            var config = {};
            custom = custom || {};
            var defaults = sinon.defaultConfig;

            for (var prop in defaults) {
                if (defaults.hasOwnProperty(prop)) {
                    config[prop] = custom.hasOwnProperty(prop) ? custom[prop] : defaults[prop];
                }
            }

            return config;
        };

        sinon.defaultConfig = {
            injectIntoThis: true,
            injectInto: null,
            properties: ["spy", "stub", "mock", "clock", "server", "requests"],
            useFakeTimers: true,
            useFakeServer: true
        };

        sinon.timesInWords = function timesInWords(count) {
            return count === 1 && "once" ||
                count === 2 && "twice" ||
                count === 3 && "thrice" ||
                (count || 0) + " times";
        };

        sinon.calledInOrder = function (spies) {
            for (var i = 1, l = spies.length; i < l; i++) {
                if (!spies[i - 1].calledBefore(spies[i]) || !spies[i].called) {
                    return false;
                }
            }

            return true;
        };

        sinon.orderByFirstCall = function (spies) {
            return spies.sort(function (a, b) {
                // uuid, won't ever be equal
                var aCall = a.getCall(0);
                var bCall = b.getCall(0);
                var aId = aCall && aCall.callId || -1;
                var bId = bCall && bCall.callId || -1;

                return aId < bId ? -1 : 1;
            });
        };

        sinon.createStubInstance = function (constructor) {
            if (typeof constructor !== "function") {
                throw new TypeError("The constructor should be a function.");
            }
            return sinon.stub(sinon.create(constructor.prototype));
        };

        sinon.restore = function (object) {
            if (object !== null && typeof object === "object") {
                for (var prop in object) {
                    if (isRestorable(object[prop])) {
                        object[prop].restore();
                    }
                }
            } else if (isRestorable(object)) {
                object.restore();
            }
        };

        return sinon;
    }

    var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;

    function loadDependencies(require, exports) {
        makeApi(exports);
    }

    if (isAMD) {
        define(loadDependencies);
        return;
    }

    if (isNode) {
        loadDependencies(require, module.exports, module);
        return;
    }

    if (sinonGlobal) {
        makeApi(sinonGlobal);
    }
}(
    typeof sinon === "object" && sinon // eslint-disable-line no-undef
));

},{}],162:[function(require,module,exports){
/**
 * Minimal Event interface implementation
 *
 * Original implementation by Sven Fuchs: https://gist.github.com/995028
 * Modifications and tests by Christian Johansen.
 *
 * @author Sven Fuchs (svenfuchs@artweb-design.de)
 * @author Christian Johansen (christian@cjohansen.no)
 * @license BSD
 *
 * Copyright (c) 2011 Sven Fuchs, Christian Johansen
 */
if (typeof sinon === "undefined") {
    this.sinon = {};
}

(function () {
    "use strict";

    var push = [].push;

    function makeApi(sinon) {
        sinon.Event = function Event(type, bubbles, cancelable, target) {
            this.initEvent(type, bubbles, cancelable, target);
        };

        sinon.Event.prototype = {
            initEvent: function (type, bubbles, cancelable, target) {
                this.type = type;
                this.bubbles = bubbles;
                this.cancelable = cancelable;
                this.target = target;
            },

            stopPropagation: function () {},

            preventDefault: function () {
                this.defaultPrevented = true;
            }
        };

        sinon.ProgressEvent = function ProgressEvent(type, progressEventRaw, target) {
            this.initEvent(type, false, false, target);
            this.loaded = progressEventRaw.loaded || null;
            this.total = progressEventRaw.total || null;
            this.lengthComputable = !!progressEventRaw.total;
        };

        sinon.ProgressEvent.prototype = new sinon.Event();

        sinon.ProgressEvent.prototype.constructor = sinon.ProgressEvent;

        sinon.CustomEvent = function CustomEvent(type, customData, target) {
            this.initEvent(type, false, false, target);
            this.detail = customData.detail || null;
        };

        sinon.CustomEvent.prototype = new sinon.Event();

        sinon.CustomEvent.prototype.constructor = sinon.CustomEvent;

        sinon.EventTarget = {
            addEventListener: function addEventListener(event, listener) {
                this.eventListeners = this.eventListeners || {};
                this.eventListeners[event] = this.eventListeners[event] || [];
                push.call(this.eventListeners[event], listener);
            },

            removeEventListener: function removeEventListener(event, listener) {
                var listeners = this.eventListeners && this.eventListeners[event] || [];

                for (var i = 0, l = listeners.length; i < l; ++i) {
                    if (listeners[i] === listener) {
                        return listeners.splice(i, 1);
                    }
                }
            },

            dispatchEvent: function dispatchEvent(event) {
                var type = event.type;
                var listeners = this.eventListeners && this.eventListeners[type] || [];

                for (var i = 0; i < listeners.length; i++) {
                    if (typeof listeners[i] === "function") {
                        listeners[i].call(this, event);
                    } else {
                        listeners[i].handleEvent(event);
                    }
                }

                return !!event.defaultPrevented;
            }
        };
    }

    var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;

    function loadDependencies(require) {
        var sinon = require("./core");
        makeApi(sinon);
    }

    if (isAMD) {
        define(loadDependencies);
    } else if (isNode) {
        loadDependencies(require);
    } else {
        makeApi(sinon); // eslint-disable-line no-undef
    }
}());

},{"./core":161}],163:[function(require,module,exports){
/**
 * @depend fake_xdomain_request.js
 * @depend fake_xml_http_request.js
 * @depend ../format.js
 * @depend ../log_error.js
 */
/**
 * The Sinon "server" mimics a web server that receives requests from
 * sinon.FakeXMLHttpRequest and provides an API to respond to those requests,
 * both synchronously and asynchronously. To respond synchronuously, canned
 * answers have to be provided upfront.
 *
 * @author Christian Johansen (christian@cjohansen.no)
 * @license BSD
 *
 * Copyright (c) 2010-2013 Christian Johansen
 */
(function () {
    "use strict";

    var push = [].push;

    function responseArray(handler) {
        var response = handler;

        if (Object.prototype.toString.call(handler) !== "[object Array]") {
            response = [200, {}, handler];
        }

        if (typeof response[2] !== "string") {
            throw new TypeError("Fake server response body should be string, but was " +
                                typeof response[2]);
        }

        return response;
    }

    var wloc = typeof window !== "undefined" ? window.location : {};
    var rCurrLoc = new RegExp("^" + wloc.protocol + "//" + wloc.host);

    function matchOne(response, reqMethod, reqUrl) {
        var rmeth = response.method;
        var matchMethod = !rmeth || rmeth.toLowerCase() === reqMethod.toLowerCase();
        var url = response.url;
        var matchUrl = !url || url === reqUrl || (typeof url.test === "function" && url.test(reqUrl));

        return matchMethod && matchUrl;
    }

    function match(response, request) {
        var requestUrl = request.url;

        if (!/^https?:\/\//.test(requestUrl) || rCurrLoc.test(requestUrl)) {
            requestUrl = requestUrl.replace(rCurrLoc, "");
        }

        if (matchOne(response, this.getHTTPMethod(request), requestUrl)) {
            if (typeof response.response === "function") {
                var ru = response.url;
                var args = [request].concat(ru && typeof ru.exec === "function" ? ru.exec(requestUrl).slice(1) : []);
                return response.response.apply(response, args);
            }

            return true;
        }

        return false;
    }

    function makeApi(sinon) {
        sinon.fakeServer = {
            create: function (config) {
                var server = sinon.create(this);
                server.configure(config);
                if (!sinon.xhr.supportsCORS) {
                    this.xhr = sinon.useFakeXDomainRequest();
                } else {
                    this.xhr = sinon.useFakeXMLHttpRequest();
                }
                server.requests = [];

                this.xhr.onCreate = function (xhrObj) {
                    server.addRequest(xhrObj);
                };

                return server;
            },
            configure: function (config) {
                var whitelist = {
                    "autoRespond": true,
                    "autoRespondAfter": true,
                    "respondImmediately": true,
                    "fakeHTTPMethods": true
                };
                var setting;

                config = config || {};
                for (setting in config) {
                    if (whitelist.hasOwnProperty(setting) && config.hasOwnProperty(setting)) {
                        this[setting] = config[setting];
                    }
                }
            },
            addRequest: function addRequest(xhrObj) {
                var server = this;
                push.call(this.requests, xhrObj);

                xhrObj.onSend = function () {
                    server.handleRequest(this);

                    if (server.respondImmediately) {
                        server.respond();
                    } else if (server.autoRespond && !server.responding) {
                        setTimeout(function () {
                            server.responding = false;
                            server.respond();
                        }, server.autoRespondAfter || 10);

                        server.responding = true;
                    }
                };
            },

            getHTTPMethod: function getHTTPMethod(request) {
                if (this.fakeHTTPMethods && /post/i.test(request.method)) {
                    var matches = (request.requestBody || "").match(/_method=([^\b;]+)/);
                    return matches ? matches[1] : request.method;
                }

                return request.method;
            },

            handleRequest: function handleRequest(xhr) {
                if (xhr.async) {
                    if (!this.queue) {
                        this.queue = [];
                    }

                    push.call(this.queue, xhr);
                } else {
                    this.processRequest(xhr);
                }
            },

            log: function log(response, request) {
                var str;

                str = "Request:\n" + sinon.format(request) + "\n\n";
                str += "Response:\n" + sinon.format(response) + "\n\n";

                sinon.log(str);
            },

            respondWith: function respondWith(method, url, body) {
                if (arguments.length === 1 && typeof method !== "function") {
                    this.response = responseArray(method);
                    return;
                }

                if (!this.responses) {
                    this.responses = [];
                }

                if (arguments.length === 1) {
                    body = method;
                    url = method = null;
                }

                if (arguments.length === 2) {
                    body = url;
                    url = method;
                    method = null;
                }

                push.call(this.responses, {
                    method: method,
                    url: url,
                    response: typeof body === "function" ? body : responseArray(body)
                });
            },

            respond: function respond() {
                if (arguments.length > 0) {
                    this.respondWith.apply(this, arguments);
                }

                var queue = this.queue || [];
                var requests = queue.splice(0, queue.length);

                for (var i = 0; i < requests.length; i++) {
                    this.processRequest(requests[i]);
                }
            },

            processRequest: function processRequest(request) {
                try {
                    if (request.aborted) {
                        return;
                    }

                    var response = this.response || [404, {}, ""];

                    if (this.responses) {
                        for (var l = this.responses.length, i = l - 1; i >= 0; i--) {
                            if (match.call(this, this.responses[i], request)) {
                                response = this.responses[i].response;
                                break;
                            }
                        }
                    }

                    if (request.readyState !== 4) {
                        this.log(response, request);

                        request.respond(response[0], response[1], response[2]);
                    }
                } catch (e) {
                    sinon.logError("Fake server request processing", e);
                }
            },

            restore: function restore() {
                return this.xhr.restore && this.xhr.restore.apply(this.xhr, arguments);
            }
        };
    }

    var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;

    function loadDependencies(require, exports, module) {
        var sinon = require("./core");
        require("./fake_xdomain_request");
        require("./fake_xml_http_request");
        require("../format");
        makeApi(sinon);
        module.exports = sinon;
    }

    if (isAMD) {
        define(loadDependencies);
    } else if (isNode) {
        loadDependencies(require, module.exports, module);
    } else {
        makeApi(sinon); // eslint-disable-line no-undef
    }
}());

},{"../format":150,"./core":161,"./fake_xdomain_request":166,"./fake_xml_http_request":167}],164:[function(require,module,exports){
/**
 * @depend fake_server.js
 * @depend fake_timers.js
 */
/**
 * Add-on for sinon.fakeServer that automatically handles a fake timer along with
 * the FakeXMLHttpRequest. The direct inspiration for this add-on is jQuery
 * 1.3.x, which does not use xhr object's onreadystatehandler at all - instead,
 * it polls the object for completion with setInterval. Dispite the direct
 * motivation, there is nothing jQuery-specific in this file, so it can be used
 * in any environment where the ajax implementation depends on setInterval or
 * setTimeout.
 *
 * @author Christian Johansen (christian@cjohansen.no)
 * @license BSD
 *
 * Copyright (c) 2010-2013 Christian Johansen
 */
(function () {
    "use strict";

    function makeApi(sinon) {
        function Server() {}
        Server.prototype = sinon.fakeServer;

        sinon.fakeServerWithClock = new Server();

        sinon.fakeServerWithClock.addRequest = function addRequest(xhr) {
            if (xhr.async) {
                if (typeof setTimeout.clock === "object") {
                    this.clock = setTimeout.clock;
                } else {
                    this.clock = sinon.useFakeTimers();
                    this.resetClock = true;
                }

                if (!this.longestTimeout) {
                    var clockSetTimeout = this.clock.setTimeout;
                    var clockSetInterval = this.clock.setInterval;
                    var server = this;

                    this.clock.setTimeout = function (fn, timeout) {
                        server.longestTimeout = Math.max(timeout, server.longestTimeout || 0);

                        return clockSetTimeout.apply(this, arguments);
                    };

                    this.clock.setInterval = function (fn, timeout) {
                        server.longestTimeout = Math.max(timeout, server.longestTimeout || 0);

                        return clockSetInterval.apply(this, arguments);
                    };
                }
            }

            return sinon.fakeServer.addRequest.call(this, xhr);
        };

        sinon.fakeServerWithClock.respond = function respond() {
            var returnVal = sinon.fakeServer.respond.apply(this, arguments);

            if (this.clock) {
                this.clock.tick(this.longestTimeout || 0);
                this.longestTimeout = 0;

                if (this.resetClock) {
                    this.clock.restore();
                    this.resetClock = false;
                }
            }

            return returnVal;
        };

        sinon.fakeServerWithClock.restore = function restore() {
            if (this.clock) {
                this.clock.restore();
            }

            return sinon.fakeServer.restore.apply(this, arguments);
        };
    }

    var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;

    function loadDependencies(require) {
        var sinon = require("./core");
        require("./fake_server");
        require("./fake_timers");
        makeApi(sinon);
    }

    if (isAMD) {
        define(loadDependencies);
    } else if (isNode) {
        loadDependencies(require);
    } else {
        makeApi(sinon); // eslint-disable-line no-undef
    }
}());

},{"./core":161,"./fake_server":163,"./fake_timers":165}],165:[function(require,module,exports){
/**
 * Fake timer API
 * setTimeout
 * setInterval
 * clearTimeout
 * clearInterval
 * tick
 * reset
 * Date
 *
 * Inspired by jsUnitMockTimeOut from JsUnit
 *
 * @author Christian Johansen (christian@cjohansen.no)
 * @license BSD
 *
 * Copyright (c) 2010-2013 Christian Johansen
 */
(function () {
    "use strict";

    function makeApi(s, lol) {
        /*global lolex */
        var llx = typeof lolex !== "undefined" ? lolex : lol;

        s.useFakeTimers = function () {
            var now;
            var methods = Array.prototype.slice.call(arguments);

            if (typeof methods[0] === "string") {
                now = 0;
            } else {
                now = methods.shift();
            }

            var clock = llx.install(now || 0, methods);
            clock.restore = clock.uninstall;
            return clock;
        };

        s.clock = {
            create: function (now) {
                return llx.createClock(now);
            }
        };

        s.timers = {
            setTimeout: setTimeout,
            clearTimeout: clearTimeout,
            setImmediate: (typeof setImmediate !== "undefined" ? setImmediate : undefined),
            clearImmediate: (typeof clearImmediate !== "undefined" ? clearImmediate : undefined),
            setInterval: setInterval,
            clearInterval: clearInterval,
            Date: Date
        };
    }

    var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;

    function loadDependencies(require, epxorts, module, lolex) {
        var core = require("./core");
        makeApi(core, lolex);
        module.exports = core;
    }

    if (isAMD) {
        define(loadDependencies);
    } else if (isNode) {
        loadDependencies(require, module.exports, module, require("lolex"));
    } else {
        makeApi(sinon); // eslint-disable-line no-undef
    }
}());

},{"./core":161,"lolex":141}],166:[function(require,module,exports){
(function (global){
/**
 * @depend core.js
 * @depend ../extend.js
 * @depend event.js
 * @depend ../log_error.js
 */
/**
 * Fake XDomainRequest object
 */
if (typeof sinon === "undefined") {
    this.sinon = {};
}

// wrapper for global
(function (global) {
    "use strict";

    var xdr = { XDomainRequest: global.XDomainRequest };
    xdr.GlobalXDomainRequest = global.XDomainRequest;
    xdr.supportsXDR = typeof xdr.GlobalXDomainRequest !== "undefined";
    xdr.workingXDR = xdr.supportsXDR ? xdr.GlobalXDomainRequest : false;

    function makeApi(sinon) {
        sinon.xdr = xdr;

        function FakeXDomainRequest() {
            this.readyState = FakeXDomainRequest.UNSENT;
            this.requestBody = null;
            this.requestHeaders = {};
            this.status = 0;
            this.timeout = null;

            if (typeof FakeXDomainRequest.onCreate === "function") {
                FakeXDomainRequest.onCreate(this);
            }
        }

        function verifyState(x) {
            if (x.readyState !== FakeXDomainRequest.OPENED) {
                throw new Error("INVALID_STATE_ERR");
            }

            if (x.sendFlag) {
                throw new Error("INVALID_STATE_ERR");
            }
        }

        function verifyRequestSent(x) {
            if (x.readyState === FakeXDomainRequest.UNSENT) {
                throw new Error("Request not sent");
            }
            if (x.readyState === FakeXDomainRequest.DONE) {
                throw new Error("Request done");
            }
        }

        function verifyResponseBodyType(body) {
            if (typeof body !== "string") {
                var error = new Error("Attempted to respond to fake XDomainRequest with " +
                                    body + ", which is not a string.");
                error.name = "InvalidBodyException";
                throw error;
            }
        }

        sinon.extend(FakeXDomainRequest.prototype, sinon.EventTarget, {
            open: function open(method, url) {
                this.method = method;
                this.url = url;

                this.responseText = null;
                this.sendFlag = false;

                this.readyStateChange(FakeXDomainRequest.OPENED);
            },

            readyStateChange: function readyStateChange(state) {
                this.readyState = state;
                var eventName = "";
                switch (this.readyState) {
                case FakeXDomainRequest.UNSENT:
                    break;
                case FakeXDomainRequest.OPENED:
                    break;
                case FakeXDomainRequest.LOADING:
                    if (this.sendFlag) {
                        //raise the progress event
                        eventName = "onprogress";
                    }
                    break;
                case FakeXDomainRequest.DONE:
                    if (this.isTimeout) {
                        eventName = "ontimeout";
                    } else if (this.errorFlag || (this.status < 200 || this.status > 299)) {
                        eventName = "onerror";
                    } else {
                        eventName = "onload";
                    }
                    break;
                }

                // raising event (if defined)
                if (eventName) {
                    if (typeof this[eventName] === "function") {
                        try {
                            this[eventName]();
                        } catch (e) {
                            sinon.logError("Fake XHR " + eventName + " handler", e);
                        }
                    }
                }
            },

            send: function send(data) {
                verifyState(this);

                if (!/^(get|head)$/i.test(this.method)) {
                    this.requestBody = data;
                }
                this.requestHeaders["Content-Type"] = "text/plain;charset=utf-8";

                this.errorFlag = false;
                this.sendFlag = true;
                this.readyStateChange(FakeXDomainRequest.OPENED);

                if (typeof this.onSend === "function") {
                    this.onSend(this);
                }
            },

            abort: function abort() {
                this.aborted = true;
                this.responseText = null;
                this.errorFlag = true;

                if (this.readyState > sinon.FakeXDomainRequest.UNSENT && this.sendFlag) {
                    this.readyStateChange(sinon.FakeXDomainRequest.DONE);
                    this.sendFlag = false;
                }
            },

            setResponseBody: function setResponseBody(body) {
                verifyRequestSent(this);
                verifyResponseBodyType(body);

                var chunkSize = this.chunkSize || 10;
                var index = 0;
                this.responseText = "";

                do {
                    this.readyStateChange(FakeXDomainRequest.LOADING);
                    this.responseText += body.substring(index, index + chunkSize);
                    index += chunkSize;
                } while (index < body.length);

                this.readyStateChange(FakeXDomainRequest.DONE);
            },

            respond: function respond(status, contentType, body) {
                // content-type ignored, since XDomainRequest does not carry this
                // we keep the same syntax for respond(...) as for FakeXMLHttpRequest to ease
                // test integration across browsers
                this.status = typeof status === "number" ? status : 200;
                this.setResponseBody(body || "");
            },

            simulatetimeout: function simulatetimeout() {
                this.status = 0;
                this.isTimeout = true;
                // Access to this should actually throw an error
                this.responseText = undefined;
                this.readyStateChange(FakeXDomainRequest.DONE);
            }
        });

        sinon.extend(FakeXDomainRequest, {
            UNSENT: 0,
            OPENED: 1,
            LOADING: 3,
            DONE: 4
        });

        sinon.useFakeXDomainRequest = function useFakeXDomainRequest() {
            sinon.FakeXDomainRequest.restore = function restore(keepOnCreate) {
                if (xdr.supportsXDR) {
                    global.XDomainRequest = xdr.GlobalXDomainRequest;
                }

                delete sinon.FakeXDomainRequest.restore;

                if (keepOnCreate !== true) {
                    delete sinon.FakeXDomainRequest.onCreate;
                }
            };
            if (xdr.supportsXDR) {
                global.XDomainRequest = sinon.FakeXDomainRequest;
            }
            return sinon.FakeXDomainRequest;
        };

        sinon.FakeXDomainRequest = FakeXDomainRequest;
    }

    var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;

    function loadDependencies(require, exports, module) {
        var sinon = require("./core");
        require("../extend");
        require("./event");
        require("../log_error");
        makeApi(sinon);
        module.exports = sinon;
    }

    if (isAMD) {
        define(loadDependencies);
    } else if (isNode) {
        loadDependencies(require, module.exports, module);
    } else {
        makeApi(sinon); // eslint-disable-line no-undef
    }
})(typeof global !== "undefined" ? global : self);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../extend":149,"../log_error":151,"./core":161,"./event":162}],167:[function(require,module,exports){
(function (global){
/**
 * @depend core.js
 * @depend ../extend.js
 * @depend event.js
 * @depend ../log_error.js
 */
/**
 * Fake XMLHttpRequest object
 *
 * @author Christian Johansen (christian@cjohansen.no)
 * @license BSD
 *
 * Copyright (c) 2010-2013 Christian Johansen
 */
(function (sinonGlobal, global) {
    "use strict";

    function getWorkingXHR(globalScope) {
        var supportsXHR = typeof globalScope.XMLHttpRequest !== "undefined";
        if (supportsXHR) {
            return globalScope.XMLHttpRequest;
        }

        var supportsActiveX = typeof globalScope.ActiveXObject !== "undefined";
        if (supportsActiveX) {
            return function () {
                return new globalScope.ActiveXObject("MSXML2.XMLHTTP.3.0");
            };
        }

        return false;
    }

    var supportsProgress = typeof ProgressEvent !== "undefined";
    var supportsCustomEvent = typeof CustomEvent !== "undefined";
    var supportsFormData = typeof FormData !== "undefined";
    var supportsArrayBuffer = typeof ArrayBuffer !== "undefined";
    var supportsBlob = typeof Blob === "function";
    var sinonXhr = { XMLHttpRequest: global.XMLHttpRequest };
    sinonXhr.GlobalXMLHttpRequest = global.XMLHttpRequest;
    sinonXhr.GlobalActiveXObject = global.ActiveXObject;
    sinonXhr.supportsActiveX = typeof sinonXhr.GlobalActiveXObject !== "undefined";
    sinonXhr.supportsXHR = typeof sinonXhr.GlobalXMLHttpRequest !== "undefined";
    sinonXhr.workingXHR = getWorkingXHR(global);
    sinonXhr.supportsCORS = sinonXhr.supportsXHR && "withCredentials" in (new sinonXhr.GlobalXMLHttpRequest());

    var unsafeHeaders = {
        "Accept-Charset": true,
        "Accept-Encoding": true,
        Connection: true,
        "Content-Length": true,
        Cookie: true,
        Cookie2: true,
        "Content-Transfer-Encoding": true,
        Date: true,
        Expect: true,
        Host: true,
        "Keep-Alive": true,
        Referer: true,
        TE: true,
        Trailer: true,
        "Transfer-Encoding": true,
        Upgrade: true,
        "User-Agent": true,
        Via: true
    };

    // An upload object is created for each
    // FakeXMLHttpRequest and allows upload
    // events to be simulated using uploadProgress
    // and uploadError.
    function UploadProgress() {
        this.eventListeners = {
            progress: [],
            load: [],
            abort: [],
            error: []
        };
    }

    UploadProgress.prototype.addEventListener = function addEventListener(event, listener) {
        this.eventListeners[event].push(listener);
    };

    UploadProgress.prototype.removeEventListener = function removeEventListener(event, listener) {
        var listeners = this.eventListeners[event] || [];

        for (var i = 0, l = listeners.length; i < l; ++i) {
            if (listeners[i] === listener) {
                return listeners.splice(i, 1);
            }
        }
    };

    UploadProgress.prototype.dispatchEvent = function dispatchEvent(event) {
        var listeners = this.eventListeners[event.type] || [];

        for (var i = 0, listener; (listener = listeners[i]) != null; i++) {
            listener(event);
        }
    };

    // Note that for FakeXMLHttpRequest to work pre ES5
    // we lose some of the alignment with the spec.
    // To ensure as close a match as possible,
    // set responseType before calling open, send or respond;
    function FakeXMLHttpRequest() {
        this.readyState = FakeXMLHttpRequest.UNSENT;
        this.requestHeaders = {};
        this.requestBody = null;
        this.status = 0;
        this.statusText = "";
        this.upload = new UploadProgress();
        this.responseType = "";
        this.response = "";
        if (sinonXhr.supportsCORS) {
            this.withCredentials = false;
        }

        var xhr = this;
        var events = ["loadstart", "load", "abort", "loadend"];

        function addEventListener(eventName) {
            xhr.addEventListener(eventName, function (event) {
                var listener = xhr["on" + eventName];

                if (listener && typeof listener === "function") {
                    listener.call(this, event);
                }
            });
        }

        for (var i = events.length - 1; i >= 0; i--) {
            addEventListener(events[i]);
        }

        if (typeof FakeXMLHttpRequest.onCreate === "function") {
            FakeXMLHttpRequest.onCreate(this);
        }
    }

    function verifyState(xhr) {
        if (xhr.readyState !== FakeXMLHttpRequest.OPENED) {
            throw new Error("INVALID_STATE_ERR");
        }

        if (xhr.sendFlag) {
            throw new Error("INVALID_STATE_ERR");
        }
    }

    function getHeader(headers, header) {
        header = header.toLowerCase();

        for (var h in headers) {
            if (h.toLowerCase() === header) {
                return h;
            }
        }

        return null;
    }

    // filtering to enable a white-list version of Sinon FakeXhr,
    // where whitelisted requests are passed through to real XHR
    function each(collection, callback) {
        if (!collection) {
            return;
        }

        for (var i = 0, l = collection.length; i < l; i += 1) {
            callback(collection[i]);
        }
    }
    function some(collection, callback) {
        for (var index = 0; index < collection.length; index++) {
            if (callback(collection[index]) === true) {
                return true;
            }
        }
        return false;
    }
    // largest arity in XHR is 5 - XHR#open
    var apply = function (obj, method, args) {
        switch (args.length) {
        case 0: return obj[method]();
        case 1: return obj[method](args[0]);
        case 2: return obj[method](args[0], args[1]);
        case 3: return obj[method](args[0], args[1], args[2]);
        case 4: return obj[method](args[0], args[1], args[2], args[3]);
        case 5: return obj[method](args[0], args[1], args[2], args[3], args[4]);
        }
    };

    FakeXMLHttpRequest.filters = [];
    FakeXMLHttpRequest.addFilter = function addFilter(fn) {
        this.filters.push(fn);
    };
    var IE6Re = /MSIE 6/;
    FakeXMLHttpRequest.defake = function defake(fakeXhr, xhrArgs) {
        var xhr = new sinonXhr.workingXHR(); // eslint-disable-line new-cap

        each([
            "open",
            "setRequestHeader",
            "send",
            "abort",
            "getResponseHeader",
            "getAllResponseHeaders",
            "addEventListener",
            "overrideMimeType",
            "removeEventListener"
        ], function (method) {
            fakeXhr[method] = function () {
                return apply(xhr, method, arguments);
            };
        });

        var copyAttrs = function (args) {
            each(args, function (attr) {
                try {
                    fakeXhr[attr] = xhr[attr];
                } catch (e) {
                    if (!IE6Re.test(navigator.userAgent)) {
                        throw e;
                    }
                }
            });
        };

        var stateChange = function stateChange() {
            fakeXhr.readyState = xhr.readyState;
            if (xhr.readyState >= FakeXMLHttpRequest.HEADERS_RECEIVED) {
                copyAttrs(["status", "statusText"]);
            }
            if (xhr.readyState >= FakeXMLHttpRequest.LOADING) {
                copyAttrs(["responseText", "response"]);
            }
            if (xhr.readyState === FakeXMLHttpRequest.DONE) {
                copyAttrs(["responseXML"]);
            }
            if (fakeXhr.onreadystatechange) {
                fakeXhr.onreadystatechange.call(fakeXhr, { target: fakeXhr });
            }
        };

        if (xhr.addEventListener) {
            for (var event in fakeXhr.eventListeners) {
                if (fakeXhr.eventListeners.hasOwnProperty(event)) {

                    /*eslint-disable no-loop-func*/
                    each(fakeXhr.eventListeners[event], function (handler) {
                        xhr.addEventListener(event, handler);
                    });
                    /*eslint-enable no-loop-func*/
                }
            }
            xhr.addEventListener("readystatechange", stateChange);
        } else {
            xhr.onreadystatechange = stateChange;
        }
        apply(xhr, "open", xhrArgs);
    };
    FakeXMLHttpRequest.useFilters = false;

    function verifyRequestOpened(xhr) {
        if (xhr.readyState !== FakeXMLHttpRequest.OPENED) {
            throw new Error("INVALID_STATE_ERR - " + xhr.readyState);
        }
    }

    function verifyRequestSent(xhr) {
        if (xhr.readyState === FakeXMLHttpRequest.DONE) {
            throw new Error("Request done");
        }
    }

    function verifyHeadersReceived(xhr) {
        if (xhr.async && xhr.readyState !== FakeXMLHttpRequest.HEADERS_RECEIVED) {
            throw new Error("No headers received");
        }
    }

    function verifyResponseBodyType(body) {
        if (typeof body !== "string") {
            var error = new Error("Attempted to respond to fake XMLHttpRequest with " +
                                 body + ", which is not a string.");
            error.name = "InvalidBodyException";
            throw error;
        }
    }

    function convertToArrayBuffer(body) {
        var buffer = new ArrayBuffer(body.length);
        var view = new Uint8Array(buffer);
        for (var i = 0; i < body.length; i++) {
            var charCode = body.charCodeAt(i);
            if (charCode >= 256) {
                throw new TypeError("arraybuffer or blob responseTypes require binary string, " +
                                    "invalid character " + body[i] + " found.");
            }
            view[i] = charCode;
        }
        return buffer;
    }

    function isXmlContentType(contentType) {
        return !contentType || /(text\/xml)|(application\/xml)|(\+xml)/.test(contentType);
    }

    function convertResponseBody(responseType, contentType, body) {
        if (responseType === "" || responseType === "text") {
            return body;
        } else if (supportsArrayBuffer && responseType === "arraybuffer") {
            return convertToArrayBuffer(body);
        } else if (responseType === "json") {
            try {
                return JSON.parse(body);
            } catch (e) {
                // Return parsing failure as null
                return null;
            }
        } else if (supportsBlob && responseType === "blob") {
            var blobOptions = {};
            if (contentType) {
                blobOptions.type = contentType;
            }
            return new Blob([convertToArrayBuffer(body)], blobOptions);
        } else if (responseType === "document") {
            if (isXmlContentType(contentType)) {
                return FakeXMLHttpRequest.parseXML(body);
            }
            return null;
        }
        throw new Error("Invalid responseType " + responseType);
    }

    function clearResponse(xhr) {
        if (xhr.responseType === "" || xhr.responseType === "text") {
            xhr.response = xhr.responseText = "";
        } else {
            xhr.response = xhr.responseText = null;
        }
        xhr.responseXML = null;
    }

    FakeXMLHttpRequest.parseXML = function parseXML(text) {
        // Treat empty string as parsing failure
        if (text !== "") {
            try {
                if (typeof DOMParser !== "undefined") {
                    var parser = new DOMParser();
                    return parser.parseFromString(text, "text/xml");
                }
                var xmlDoc = new window.ActiveXObject("Microsoft.XMLDOM");
                xmlDoc.async = "false";
                xmlDoc.loadXML(text);
                return xmlDoc;
            } catch (e) {
                // Unable to parse XML - no biggie
            }
        }

        return null;
    };

    FakeXMLHttpRequest.statusCodes = {
        100: "Continue",
        101: "Switching Protocols",
        200: "OK",
        201: "Created",
        202: "Accepted",
        203: "Non-Authoritative Information",
        204: "No Content",
        205: "Reset Content",
        206: "Partial Content",
        207: "Multi-Status",
        300: "Multiple Choice",
        301: "Moved Permanently",
        302: "Found",
        303: "See Other",
        304: "Not Modified",
        305: "Use Proxy",
        307: "Temporary Redirect",
        400: "Bad Request",
        401: "Unauthorized",
        402: "Payment Required",
        403: "Forbidden",
        404: "Not Found",
        405: "Method Not Allowed",
        406: "Not Acceptable",
        407: "Proxy Authentication Required",
        408: "Request Timeout",
        409: "Conflict",
        410: "Gone",
        411: "Length Required",
        412: "Precondition Failed",
        413: "Request Entity Too Large",
        414: "Request-URI Too Long",
        415: "Unsupported Media Type",
        416: "Requested Range Not Satisfiable",
        417: "Expectation Failed",
        422: "Unprocessable Entity",
        500: "Internal Server Error",
        501: "Not Implemented",
        502: "Bad Gateway",
        503: "Service Unavailable",
        504: "Gateway Timeout",
        505: "HTTP Version Not Supported"
    };

    function makeApi(sinon) {
        sinon.xhr = sinonXhr;

        sinon.extend(FakeXMLHttpRequest.prototype, sinon.EventTarget, {
            async: true,

            open: function open(method, url, async, username, password) {
                this.method = method;
                this.url = url;
                this.async = typeof async === "boolean" ? async : true;
                this.username = username;
                this.password = password;
                clearResponse(this);
                this.requestHeaders = {};
                this.sendFlag = false;

                if (FakeXMLHttpRequest.useFilters === true) {
                    var xhrArgs = arguments;
                    var defake = some(FakeXMLHttpRequest.filters, function (filter) {
                        return filter.apply(this, xhrArgs);
                    });
                    if (defake) {
                        return FakeXMLHttpRequest.defake(this, arguments);
                    }
                }
                this.readyStateChange(FakeXMLHttpRequest.OPENED);
            },

            readyStateChange: function readyStateChange(state) {
                this.readyState = state;

                var readyStateChangeEvent = new sinon.Event("readystatechange", false, false, this);

                if (typeof this.onreadystatechange === "function") {
                    try {
                        this.onreadystatechange(readyStateChangeEvent);
                    } catch (e) {
                        sinon.logError("Fake XHR onreadystatechange handler", e);
                    }
                }

                switch (this.readyState) {
                    case FakeXMLHttpRequest.DONE:
                        if (supportsProgress) {
                            this.upload.dispatchEvent(new sinon.ProgressEvent("progress", {loaded: 100, total: 100}));
                            this.dispatchEvent(new sinon.ProgressEvent("progress", {loaded: 100, total: 100}));
                        }
                        this.upload.dispatchEvent(new sinon.Event("load", false, false, this));
                        this.dispatchEvent(new sinon.Event("load", false, false, this));
                        this.dispatchEvent(new sinon.Event("loadend", false, false, this));
                        break;
                }

                this.dispatchEvent(readyStateChangeEvent);
            },

            setRequestHeader: function setRequestHeader(header, value) {
                verifyState(this);

                if (unsafeHeaders[header] || /^(Sec-|Proxy-)/.test(header)) {
                    throw new Error("Refused to set unsafe header \"" + header + "\"");
                }

                if (this.requestHeaders[header]) {
                    this.requestHeaders[header] += "," + value;
                } else {
                    this.requestHeaders[header] = value;
                }
            },

            // Helps testing
            setResponseHeaders: function setResponseHeaders(headers) {
                verifyRequestOpened(this);
                this.responseHeaders = {};

                for (var header in headers) {
                    if (headers.hasOwnProperty(header)) {
                        this.responseHeaders[header] = headers[header];
                    }
                }

                if (this.async) {
                    this.readyStateChange(FakeXMLHttpRequest.HEADERS_RECEIVED);
                } else {
                    this.readyState = FakeXMLHttpRequest.HEADERS_RECEIVED;
                }
            },

            // Currently treats ALL data as a DOMString (i.e. no Document)
            send: function send(data) {
                verifyState(this);

                if (!/^(get|head)$/i.test(this.method)) {
                    var contentType = getHeader(this.requestHeaders, "Content-Type");
                    if (this.requestHeaders[contentType]) {
                        var value = this.requestHeaders[contentType].split(";");
                        this.requestHeaders[contentType] = value[0] + ";charset=utf-8";
                    } else if (supportsFormData && !(data instanceof FormData)) {
                        this.requestHeaders["Content-Type"] = "text/plain;charset=utf-8";
                    }

                    this.requestBody = data;
                }

                this.errorFlag = false;
                this.sendFlag = this.async;
                clearResponse(this);
                this.readyStateChange(FakeXMLHttpRequest.OPENED);

                if (typeof this.onSend === "function") {
                    this.onSend(this);
                }

                this.dispatchEvent(new sinon.Event("loadstart", false, false, this));
            },

            abort: function abort() {
                this.aborted = true;
                clearResponse(this);
                this.errorFlag = true;
                this.requestHeaders = {};
                this.responseHeaders = {};

                if (this.readyState > FakeXMLHttpRequest.UNSENT && this.sendFlag) {
                    this.readyStateChange(FakeXMLHttpRequest.DONE);
                    this.sendFlag = false;
                }

                this.readyState = FakeXMLHttpRequest.UNSENT;

                this.dispatchEvent(new sinon.Event("abort", false, false, this));

                this.upload.dispatchEvent(new sinon.Event("abort", false, false, this));

                if (typeof this.onerror === "function") {
                    this.onerror();
                }
            },

            getResponseHeader: function getResponseHeader(header) {
                if (this.readyState < FakeXMLHttpRequest.HEADERS_RECEIVED) {
                    return null;
                }

                if (/^Set-Cookie2?$/i.test(header)) {
                    return null;
                }

                header = getHeader(this.responseHeaders, header);

                return this.responseHeaders[header] || null;
            },

            getAllResponseHeaders: function getAllResponseHeaders() {
                if (this.readyState < FakeXMLHttpRequest.HEADERS_RECEIVED) {
                    return "";
                }

                var headers = "";

                for (var header in this.responseHeaders) {
                    if (this.responseHeaders.hasOwnProperty(header) &&
                        !/^Set-Cookie2?$/i.test(header)) {
                        headers += header + ": " + this.responseHeaders[header] + "\r\n";
                    }
                }

                return headers;
            },

            setResponseBody: function setResponseBody(body) {
                verifyRequestSent(this);
                verifyHeadersReceived(this);
                verifyResponseBodyType(body);
                var contentType = this.getResponseHeader("Content-Type");

                var isTextResponse = this.responseType === "" || this.responseType === "text";
                clearResponse(this);
                if (this.async) {
                    var chunkSize = this.chunkSize || 10;
                    var index = 0;

                    do {
                        this.readyStateChange(FakeXMLHttpRequest.LOADING);

                        if (isTextResponse) {
                            this.responseText = this.response += body.substring(index, index + chunkSize);
                        }
                        index += chunkSize;
                    } while (index < body.length);
                }

                this.response = convertResponseBody(this.responseType, contentType, body);
                if (isTextResponse) {
                    this.responseText = this.response;
                }

                if (this.responseType === "document") {
                    this.responseXML = this.response;
                } else if (this.responseType === "" && isXmlContentType(contentType)) {
                    this.responseXML = FakeXMLHttpRequest.parseXML(this.responseText);
                }
                this.readyStateChange(FakeXMLHttpRequest.DONE);
            },

            respond: function respond(status, headers, body) {
                this.status = typeof status === "number" ? status : 200;
                this.statusText = FakeXMLHttpRequest.statusCodes[this.status];
                this.setResponseHeaders(headers || {});
                this.setResponseBody(body || "");
            },

            uploadProgress: function uploadProgress(progressEventRaw) {
                if (supportsProgress) {
                    this.upload.dispatchEvent(new sinon.ProgressEvent("progress", progressEventRaw));
                }
            },

            downloadProgress: function downloadProgress(progressEventRaw) {
                if (supportsProgress) {
                    this.dispatchEvent(new sinon.ProgressEvent("progress", progressEventRaw));
                }
            },

            uploadError: function uploadError(error) {
                if (supportsCustomEvent) {
                    this.upload.dispatchEvent(new sinon.CustomEvent("error", {detail: error}));
                }
            }
        });

        sinon.extend(FakeXMLHttpRequest, {
            UNSENT: 0,
            OPENED: 1,
            HEADERS_RECEIVED: 2,
            LOADING: 3,
            DONE: 4
        });

        sinon.useFakeXMLHttpRequest = function () {
            FakeXMLHttpRequest.restore = function restore(keepOnCreate) {
                if (sinonXhr.supportsXHR) {
                    global.XMLHttpRequest = sinonXhr.GlobalXMLHttpRequest;
                }

                if (sinonXhr.supportsActiveX) {
                    global.ActiveXObject = sinonXhr.GlobalActiveXObject;
                }

                delete FakeXMLHttpRequest.restore;

                if (keepOnCreate !== true) {
                    delete FakeXMLHttpRequest.onCreate;
                }
            };
            if (sinonXhr.supportsXHR) {
                global.XMLHttpRequest = FakeXMLHttpRequest;
            }

            if (sinonXhr.supportsActiveX) {
                global.ActiveXObject = function ActiveXObject(objId) {
                    if (objId === "Microsoft.XMLHTTP" || /^Msxml2\.XMLHTTP/i.test(objId)) {

                        return new FakeXMLHttpRequest();
                    }

                    return new sinonXhr.GlobalActiveXObject(objId);
                };
            }

            return FakeXMLHttpRequest;
        };

        sinon.FakeXMLHttpRequest = FakeXMLHttpRequest;
    }

    var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;

    function loadDependencies(require, exports, module) {
        var sinon = require("./core");
        require("../extend");
        require("./event");
        require("../log_error");
        makeApi(sinon);
        module.exports = sinon;
    }

    if (isAMD) {
        define(loadDependencies);
        return;
    }

    if (isNode) {
        loadDependencies(require, module.exports, module);
        return;
    }

    if (sinonGlobal) {
        makeApi(sinonGlobal);
    }
}(
    typeof sinon === "object" && sinon, // eslint-disable-line no-undef
    typeof global !== "undefined" ? global : self
));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../extend":149,"../log_error":151,"./core":161,"./event":162}],168:[function(require,module,exports){
/**
 * @depend util/core.js
 */
(function (sinonGlobal) {
    "use strict";

    function makeApi(sinon) {
        function walkInternal(obj, iterator, context, originalObj) {
            var proto, prop;

            if (typeof Object.getOwnPropertyNames !== "function") {
                // We explicitly want to enumerate through all of the prototype's properties
                // in this case, therefore we deliberately leave out an own property check.
                /* eslint-disable guard-for-in */
                for (prop in obj) {
                    iterator.call(context, obj[prop], prop, obj);
                }
                /* eslint-enable guard-for-in */

                return;
            }

            Object.getOwnPropertyNames(obj).forEach(function (k) {
                var target = typeof Object.getOwnPropertyDescriptor(obj, k).get === "function" ?
                    originalObj : obj;
                iterator.call(context, target[k], k, target);
            });

            proto = Object.getPrototypeOf(obj);
            if (proto) {
                walkInternal(proto, iterator, context, originalObj);
            }
        }

        /* Public: walks the prototype chain of an object and iterates over every own property
         * name encountered. The iterator is called in the same fashion that Array.prototype.forEach
         * works, where it is passed the value, key, and own object as the 1st, 2nd, and 3rd positional
         * argument, respectively. In cases where Object.getOwnPropertyNames is not available, walk will
         * default to using a simple for..in loop.
         *
         * obj - The object to walk the prototype chain for.
         * iterator - The function to be called on each pass of the walk.
         * context - (Optional) When given, the iterator will be called with this object as the receiver.
         */
        function walk(obj, iterator, context) {
            return walkInternal(obj, iterator, context, obj);
        }

        sinon.walk = walk;
        return sinon.walk;
    }

    function loadDependencies(require, exports, module) {
        var sinon = require("./util/core");
        module.exports = makeApi(sinon);
    }

    var isNode = typeof module !== "undefined" && module.exports && typeof require === "function";
    var isAMD = typeof define === "function" && typeof define.amd === "object" && define.amd;

    if (isAMD) {
        define(loadDependencies);
        return;
    }

    if (isNode) {
        loadDependencies(require, module.exports, module);
        return;
    }

    if (sinonGlobal) {
        makeApi(sinonGlobal);
    }
}(
    typeof sinon === "object" && sinon // eslint-disable-line no-undef
));

},{"./util/core":161}],169:[function(require,module,exports){
module.exports = require('./lib/index');

},{"./lib/index":170}],170:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _ponyfill = require('./ponyfill');

var _ponyfill2 = _interopRequireDefault(_ponyfill);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var root = undefined; /* global window */

if (typeof global !== 'undefined') {
	root = global;
} else if (typeof window !== 'undefined') {
	root = window;
}

var result = (0, _ponyfill2['default'])(root);
exports['default'] = result;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./ponyfill":171}],171:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports['default'] = symbolObservablePonyfill;
function symbolObservablePonyfill(root) {
	var result;
	var _Symbol = root.Symbol;

	if (typeof _Symbol === 'function') {
		if (_Symbol.observable) {
			result = _Symbol.observable;
		} else {
			result = _Symbol('observable');
			_Symbol.observable = result;
		}
	} else {
		result = '@@observable';
	}

	return result;
};
},{}],172:[function(require,module,exports){
// transducers-js 0.4.175
// http://github.com/cognitect-labs/transducers-js
// 
// Copyright 2014-2015 Cognitect. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License..
var COMPILED = !0, goog = goog || {};
goog.global = this;
goog.isDef = function(a) {
  return void 0 !== a;
};
goog.exportPath_ = function(a, b, c) {
  a = a.split(".");
  c = c || goog.global;
  a[0] in c || !c.execScript || c.execScript("var " + a[0]);
  for (var d;a.length && (d = a.shift());) {
    !a.length && goog.isDef(b) ? c[d] = b : c = c[d] ? c[d] : c[d] = {};
  }
};
goog.define = function(a, b) {
  var c = b;
  COMPILED || (goog.global.CLOSURE_UNCOMPILED_DEFINES && Object.prototype.hasOwnProperty.call(goog.global.CLOSURE_UNCOMPILED_DEFINES, a) ? c = goog.global.CLOSURE_UNCOMPILED_DEFINES[a] : goog.global.CLOSURE_DEFINES && Object.prototype.hasOwnProperty.call(goog.global.CLOSURE_DEFINES, a) && (c = goog.global.CLOSURE_DEFINES[a]));
  goog.exportPath_(a, c);
};
goog.DEBUG = !0;
goog.LOCALE = "en";
goog.TRUSTED_SITE = !0;
goog.STRICT_MODE_COMPATIBLE = !1;
goog.DISALLOW_TEST_ONLY_CODE = COMPILED && !goog.DEBUG;
goog.provide = function(a) {
  if (!COMPILED && goog.isProvided_(a)) {
    throw Error('Namespace "' + a + '" already declared.');
  }
  goog.constructNamespace_(a);
};
goog.constructNamespace_ = function(a, b) {
  if (!COMPILED) {
    delete goog.implicitNamespaces_[a];
    for (var c = a;(c = c.substring(0, c.lastIndexOf("."))) && !goog.getObjectByName(c);) {
      goog.implicitNamespaces_[c] = !0;
    }
  }
  goog.exportPath_(a, b);
};
goog.VALID_MODULE_RE_ = /^[a-zA-Z_$][a-zA-Z0-9._$]*$/;
goog.module = function(a) {
  if (!goog.isString(a) || !a || -1 == a.search(goog.VALID_MODULE_RE_)) {
    throw Error("Invalid module identifier");
  }
  if (!goog.isInModuleLoader_()) {
    throw Error("Module " + a + " has been loaded incorrectly.");
  }
  if (goog.moduleLoaderState_.moduleName) {
    throw Error("goog.module may only be called once per module.");
  }
  goog.moduleLoaderState_.moduleName = a;
  if (!COMPILED) {
    if (goog.isProvided_(a)) {
      throw Error('Namespace "' + a + '" already declared.');
    }
    delete goog.implicitNamespaces_[a];
  }
};
goog.module.get = function(a) {
  return goog.module.getInternal_(a);
};
goog.module.getInternal_ = function(a) {
  if (!COMPILED) {
    return goog.isProvided_(a) ? a in goog.loadedModules_ ? goog.loadedModules_[a] : goog.getObjectByName(a) : null;
  }
};
goog.moduleLoaderState_ = null;
goog.isInModuleLoader_ = function() {
  return null != goog.moduleLoaderState_;
};
goog.module.declareTestMethods = function() {
  if (!goog.isInModuleLoader_()) {
    throw Error("goog.module.declareTestMethods must be called from within a goog.module");
  }
  goog.moduleLoaderState_.declareTestMethods = !0;
};
goog.module.declareLegacyNamespace = function() {
  if (!COMPILED && !goog.isInModuleLoader_()) {
    throw Error("goog.module.declareLegacyNamespace must be called from within a goog.module");
  }
  if (!COMPILED && !goog.moduleLoaderState_.moduleName) {
    throw Error("goog.module must be called prior to goog.module.declareLegacyNamespace.");
  }
  goog.moduleLoaderState_.declareLegacyNamespace = !0;
};
goog.setTestOnly = function(a) {
  if (goog.DISALLOW_TEST_ONLY_CODE) {
    throw a = a || "", Error("Importing test-only code into non-debug environment" + (a ? ": " + a : "."));
  }
};
goog.forwardDeclare = function(a) {
};
COMPILED || (goog.isProvided_ = function(a) {
  return a in goog.loadedModules_ || !goog.implicitNamespaces_[a] && goog.isDefAndNotNull(goog.getObjectByName(a));
}, goog.implicitNamespaces_ = {"goog.module":!0});
goog.getObjectByName = function(a, b) {
  for (var c = a.split("."), d = b || goog.global, e;e = c.shift();) {
    if (goog.isDefAndNotNull(d[e])) {
      d = d[e];
    } else {
      return null;
    }
  }
  return d;
};
goog.globalize = function(a, b) {
  var c = b || goog.global, d;
  for (d in a) {
    c[d] = a[d];
  }
};
goog.addDependency = function(a, b, c, d) {
  if (goog.DEPENDENCIES_ENABLED) {
    var e;
    a = a.replace(/\\/g, "/");
    for (var f = goog.dependencies_, g = 0;e = b[g];g++) {
      f.nameToPath[e] = a, f.pathIsModule[a] = !!d;
    }
    for (d = 0;b = c[d];d++) {
      a in f.requires || (f.requires[a] = {}), f.requires[a][b] = !0;
    }
  }
};
goog.ENABLE_DEBUG_LOADER = !0;
goog.logToConsole_ = function(a) {
  goog.global.console && goog.global.console.error(a);
};
goog.require = function(a) {
  if (!COMPILED) {
    goog.ENABLE_DEBUG_LOADER && goog.IS_OLD_IE_ && goog.maybeProcessDeferredDep_(a);
    if (goog.isProvided_(a)) {
      return goog.isInModuleLoader_() ? goog.module.getInternal_(a) : null;
    }
    if (goog.ENABLE_DEBUG_LOADER) {
      var b = goog.getPathFromDeps_(a);
      if (b) {
        return goog.included_[b] = !0, goog.writeScripts_(), null;
      }
    }
    a = "goog.require could not find: " + a;
    goog.logToConsole_(a);
    throw Error(a);
  }
};
goog.basePath = "";
goog.nullFunction = function() {
};
goog.identityFunction = function(a, b) {
  return a;
};
goog.abstractMethod = function() {
  throw Error("unimplemented abstract method");
};
goog.addSingletonGetter = function(a) {
  a.getInstance = function() {
    if (a.instance_) {
      return a.instance_;
    }
    goog.DEBUG && (goog.instantiatedSingletons_[goog.instantiatedSingletons_.length] = a);
    return a.instance_ = new a;
  };
};
goog.instantiatedSingletons_ = [];
goog.LOAD_MODULE_USING_EVAL = !0;
goog.SEAL_MODULE_EXPORTS = goog.DEBUG;
goog.loadedModules_ = {};
goog.DEPENDENCIES_ENABLED = !COMPILED && goog.ENABLE_DEBUG_LOADER;
goog.DEPENDENCIES_ENABLED && (goog.included_ = {}, goog.dependencies_ = {pathIsModule:{}, nameToPath:{}, requires:{}, visited:{}, written:{}, deferred:{}}, goog.inHtmlDocument_ = function() {
  var a = goog.global.document;
  return "undefined" != typeof a && "write" in a;
}, goog.findBasePath_ = function() {
  if (goog.isDef(goog.global.CLOSURE_BASE_PATH)) {
    goog.basePath = goog.global.CLOSURE_BASE_PATH;
  } else {
    if (goog.inHtmlDocument_()) {
      for (var a = goog.global.document.getElementsByTagName("SCRIPT"), b = a.length - 1;0 <= b;--b) {
        var c = a[b].src, d = c.lastIndexOf("?"), d = -1 == d ? c.length : d;
        if ("base.js" == c.substr(d - 7, 7)) {
          goog.basePath = c.substr(0, d - 7);
          break;
        }
      }
    }
  }
}, goog.importScript_ = function(a, b) {
  (goog.global.CLOSURE_IMPORT_SCRIPT || goog.writeScriptTag_)(a, b) && (goog.dependencies_.written[a] = !0);
}, goog.IS_OLD_IE_ = !(goog.global.atob || !goog.global.document || !goog.global.document.all), goog.importModule_ = function(a) {
  goog.importScript_("", 'goog.retrieveAndExecModule_("' + a + '");') && (goog.dependencies_.written[a] = !0);
}, goog.queuedModules_ = [], goog.wrapModule_ = function(a, b) {
  return goog.LOAD_MODULE_USING_EVAL && goog.isDef(goog.global.JSON) ? "goog.loadModule(" + goog.global.JSON.stringify(b + "\n//# sourceURL=" + a + "\n") + ");" : 'goog.loadModule(function(exports) {"use strict";' + b + "\n;return exports});\n//# sourceURL=" + a + "\n";
}, goog.loadQueuedModules_ = function() {
  var a = goog.queuedModules_.length;
  if (0 < a) {
    var b = goog.queuedModules_;
    goog.queuedModules_ = [];
    for (var c = 0;c < a;c++) {
      goog.maybeProcessDeferredPath_(b[c]);
    }
  }
}, goog.maybeProcessDeferredDep_ = function(a) {
  goog.isDeferredModule_(a) && goog.allDepsAreAvailable_(a) && (a = goog.getPathFromDeps_(a), goog.maybeProcessDeferredPath_(goog.basePath + a));
}, goog.isDeferredModule_ = function(a) {
  return (a = goog.getPathFromDeps_(a)) && goog.dependencies_.pathIsModule[a] ? goog.basePath + a in goog.dependencies_.deferred : !1;
}, goog.allDepsAreAvailable_ = function(a) {
  if ((a = goog.getPathFromDeps_(a)) && a in goog.dependencies_.requires) {
    for (var b in goog.dependencies_.requires[a]) {
      if (!goog.isProvided_(b) && !goog.isDeferredModule_(b)) {
        return !1;
      }
    }
  }
  return !0;
}, goog.maybeProcessDeferredPath_ = function(a) {
  if (a in goog.dependencies_.deferred) {
    var b = goog.dependencies_.deferred[a];
    delete goog.dependencies_.deferred[a];
    goog.globalEval(b);
  }
}, goog.loadModule = function(a) {
  var b = goog.moduleLoaderState_;
  try {
    goog.moduleLoaderState_ = {moduleName:void 0, declareTestMethods:!1};
    var c;
    if (goog.isFunction(a)) {
      c = a.call(goog.global, {});
    } else {
      if (goog.isString(a)) {
        c = goog.loadModuleFromSource_.call(goog.global, a);
      } else {
        throw Error("Invalid module definition");
      }
    }
    var d = goog.moduleLoaderState_.moduleName;
    if (!goog.isString(d) || !d) {
      throw Error('Invalid module name "' + d + '"');
    }
    goog.moduleLoaderState_.declareLegacyNamespace ? goog.constructNamespace_(d, c) : goog.SEAL_MODULE_EXPORTS && Object.seal && Object.seal(c);
    goog.loadedModules_[d] = c;
    if (goog.moduleLoaderState_.declareTestMethods) {
      for (var e in c) {
        if (0 === e.indexOf("test", 0) || "tearDown" == e || "setUp" == e || "setUpPage" == e || "tearDownPage" == e) {
          goog.global[e] = c[e];
        }
      }
    }
  } finally {
    goog.moduleLoaderState_ = b;
  }
}, goog.loadModuleFromSource_ = function(a) {
  eval(a);
  return {};
}, goog.writeScriptTag_ = function(a, b) {
  if (goog.inHtmlDocument_()) {
    var c = goog.global.document;
    if ("complete" == c.readyState) {
      if (/\bdeps.js$/.test(a)) {
        return !1;
      }
      throw Error('Cannot write "' + a + '" after document load');
    }
    var d = goog.IS_OLD_IE_;
    void 0 === b ? d ? (d = " onreadystatechange='goog.onScriptLoad_(this, " + ++goog.lastNonModuleScriptIndex_ + ")' ", c.write('<script type="text/javascript" src="' + a + '"' + d + ">\x3c/script>")) : c.write('<script type="text/javascript" src="' + a + '">\x3c/script>') : c.write('<script type="text/javascript">' + b + "\x3c/script>");
    return !0;
  }
  return !1;
}, goog.lastNonModuleScriptIndex_ = 0, goog.onScriptLoad_ = function(a, b) {
  "complete" == a.readyState && goog.lastNonModuleScriptIndex_ == b && goog.loadQueuedModules_();
  return !0;
}, goog.writeScripts_ = function() {
  function a(e) {
    if (!(e in d.written)) {
      if (!(e in d.visited) && (d.visited[e] = !0, e in d.requires)) {
        for (var f in d.requires[e]) {
          if (!goog.isProvided_(f)) {
            if (f in d.nameToPath) {
              a(d.nameToPath[f]);
            } else {
              throw Error("Undefined nameToPath for " + f);
            }
          }
        }
      }
      e in c || (c[e] = !0, b.push(e));
    }
  }
  var b = [], c = {}, d = goog.dependencies_, e;
  for (e in goog.included_) {
    d.written[e] || a(e);
  }
  for (var f = 0;f < b.length;f++) {
    e = b[f], goog.dependencies_.written[e] = !0;
  }
  var g = goog.moduleLoaderState_;
  goog.moduleLoaderState_ = null;
  for (f = 0;f < b.length;f++) {
    if (e = b[f]) {
      d.pathIsModule[e] ? goog.importModule_(goog.basePath + e) : goog.importScript_(goog.basePath + e);
    } else {
      throw goog.moduleLoaderState_ = g, Error("Undefined script input");
    }
  }
  goog.moduleLoaderState_ = g;
}, goog.getPathFromDeps_ = function(a) {
  return a in goog.dependencies_.nameToPath ? goog.dependencies_.nameToPath[a] : null;
}, goog.findBasePath_(), goog.global.CLOSURE_NO_DEPS || goog.importScript_(goog.basePath + "deps.js"));
goog.normalizePath_ = function(a) {
  a = a.split("/");
  for (var b = 0;b < a.length;) {
    "." == a[b] ? a.splice(b, 1) : b && ".." == a[b] && a[b - 1] && ".." != a[b - 1] ? a.splice(--b, 2) : b++;
  }
  return a.join("/");
};
goog.retrieveAndExecModule_ = function(a) {
  if (!COMPILED) {
    var b = a;
    a = goog.normalizePath_(a);
    var c = goog.global.CLOSURE_IMPORT_SCRIPT || goog.writeScriptTag_, d = null, e = new goog.global.XMLHttpRequest;
    e.onload = function() {
      d = this.responseText;
    };
    e.open("get", a, !1);
    e.send();
    d = e.responseText;
    if (null != d) {
      e = goog.wrapModule_(a, d), goog.IS_OLD_IE_ ? (goog.dependencies_.deferred[b] = e, goog.queuedModules_.push(b)) : c(a, e);
    } else {
      throw Error("load of " + a + "failed");
    }
  }
};
goog.typeOf = function(a) {
  var b = typeof a;
  if ("object" == b) {
    if (a) {
      if (a instanceof Array) {
        return "array";
      }
      if (a instanceof Object) {
        return b;
      }
      var c = Object.prototype.toString.call(a);
      if ("[object Window]" == c) {
        return "object";
      }
      if ("[object Array]" == c || "number" == typeof a.length && "undefined" != typeof a.splice && "undefined" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable("splice")) {
        return "array";
      }
      if ("[object Function]" == c || "undefined" != typeof a.call && "undefined" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable("call")) {
        return "function";
      }
    } else {
      return "null";
    }
  } else {
    if ("function" == b && "undefined" == typeof a.call) {
      return "object";
    }
  }
  return b;
};
goog.isNull = function(a) {
  return null === a;
};
goog.isDefAndNotNull = function(a) {
  return null != a;
};
goog.isArray = function(a) {
  return "array" == goog.typeOf(a);
};
goog.isArrayLike = function(a) {
  var b = goog.typeOf(a);
  return "array" == b || "object" == b && "number" == typeof a.length;
};
goog.isDateLike = function(a) {
  return goog.isObject(a) && "function" == typeof a.getFullYear;
};
goog.isString = function(a) {
  return "string" == typeof a;
};
goog.isBoolean = function(a) {
  return "boolean" == typeof a;
};
goog.isNumber = function(a) {
  return "number" == typeof a;
};
goog.isFunction = function(a) {
  return "function" == goog.typeOf(a);
};
goog.isObject = function(a) {
  var b = typeof a;
  return "object" == b && null != a || "function" == b;
};
goog.getUid = function(a) {
  return a[goog.UID_PROPERTY_] || (a[goog.UID_PROPERTY_] = ++goog.uidCounter_);
};
goog.hasUid = function(a) {
  return !!a[goog.UID_PROPERTY_];
};
goog.removeUid = function(a) {
  "removeAttribute" in a && a.removeAttribute(goog.UID_PROPERTY_);
  try {
    delete a[goog.UID_PROPERTY_];
  } catch (b) {
  }
};
goog.UID_PROPERTY_ = "closure_uid_" + (1E9 * Math.random() >>> 0);
goog.uidCounter_ = 0;
goog.getHashCode = goog.getUid;
goog.removeHashCode = goog.removeUid;
goog.cloneObject = function(a) {
  var b = goog.typeOf(a);
  if ("object" == b || "array" == b) {
    if (a.clone) {
      return a.clone();
    }
    var b = "array" == b ? [] : {}, c;
    for (c in a) {
      b[c] = goog.cloneObject(a[c]);
    }
    return b;
  }
  return a;
};
goog.bindNative_ = function(a, b, c) {
  return a.call.apply(a.bind, arguments);
};
goog.bindJs_ = function(a, b, c) {
  if (!a) {
    throw Error();
  }
  if (2 < arguments.length) {
    var d = Array.prototype.slice.call(arguments, 2);
    return function() {
      var c = Array.prototype.slice.call(arguments);
      Array.prototype.unshift.apply(c, d);
      return a.apply(b, c);
    };
  }
  return function() {
    return a.apply(b, arguments);
  };
};
goog.bind = function(a, b, c) {
  Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? goog.bind = goog.bindNative_ : goog.bind = goog.bindJs_;
  return goog.bind.apply(null, arguments);
};
goog.partial = function(a, b) {
  var c = Array.prototype.slice.call(arguments, 1);
  return function() {
    var b = c.slice();
    b.push.apply(b, arguments);
    return a.apply(this, b);
  };
};
goog.mixin = function(a, b) {
  for (var c in b) {
    a[c] = b[c];
  }
};
goog.now = goog.TRUSTED_SITE && Date.now || function() {
  return +new Date;
};
goog.globalEval = function(a) {
  if (goog.global.execScript) {
    goog.global.execScript(a, "JavaScript");
  } else {
    if (goog.global.eval) {
      if (null == goog.evalWorksForGlobals_ && (goog.global.eval("var _et_ = 1;"), "undefined" != typeof goog.global._et_ ? (delete goog.global._et_, goog.evalWorksForGlobals_ = !0) : goog.evalWorksForGlobals_ = !1), goog.evalWorksForGlobals_) {
        goog.global.eval(a);
      } else {
        var b = goog.global.document, c = b.createElement("SCRIPT");
        c.type = "text/javascript";
        c.defer = !1;
        c.appendChild(b.createTextNode(a));
        b.body.appendChild(c);
        b.body.removeChild(c);
      }
    } else {
      throw Error("goog.globalEval not available");
    }
  }
};
goog.evalWorksForGlobals_ = null;
goog.getCssName = function(a, b) {
  var c = function(a) {
    return goog.cssNameMapping_[a] || a;
  }, d = function(a) {
    a = a.split("-");
    for (var b = [], d = 0;d < a.length;d++) {
      b.push(c(a[d]));
    }
    return b.join("-");
  }, d = goog.cssNameMapping_ ? "BY_WHOLE" == goog.cssNameMappingStyle_ ? c : d : function(a) {
    return a;
  };
  return b ? a + "-" + d(b) : d(a);
};
goog.setCssNameMapping = function(a, b) {
  goog.cssNameMapping_ = a;
  goog.cssNameMappingStyle_ = b;
};
!COMPILED && goog.global.CLOSURE_CSS_NAME_MAPPING && (goog.cssNameMapping_ = goog.global.CLOSURE_CSS_NAME_MAPPING);
goog.getMsg = function(a, b) {
  b && (a = a.replace(/\{\$([^}]+)}/g, function(a, d) {
    return d in b ? b[d] : a;
  }));
  return a;
};
goog.getMsgWithFallback = function(a, b) {
  return a;
};
goog.exportSymbol = function(a, b, c) {
  goog.exportPath_(a, b, c);
};
goog.exportProperty = function(a, b, c) {
  a[b] = c;
};
goog.inherits = function(a, b) {
  function c() {
  }
  c.prototype = b.prototype;
  a.superClass_ = b.prototype;
  a.prototype = new c;
  a.prototype.constructor = a;
  a.base = function(a, c, f) {
    for (var g = Array(arguments.length - 2), h = 2;h < arguments.length;h++) {
      g[h - 2] = arguments[h];
    }
    return b.prototype[c].apply(a, g);
  };
};
goog.base = function(a, b, c) {
  var d = arguments.callee.caller;
  if (goog.STRICT_MODE_COMPATIBLE || goog.DEBUG && !d) {
    throw Error("arguments.caller not defined.  goog.base() cannot be used with strict mode code. See http://www.ecma-international.org/ecma-262/5.1/#sec-C");
  }
  if (d.superClass_) {
    for (var e = Array(arguments.length - 1), f = 1;f < arguments.length;f++) {
      e[f - 1] = arguments[f];
    }
    return d.superClass_.constructor.apply(a, e);
  }
  e = Array(arguments.length - 2);
  for (f = 2;f < arguments.length;f++) {
    e[f - 2] = arguments[f];
  }
  for (var f = !1, g = a.constructor;g;g = g.superClass_ && g.superClass_.constructor) {
    if (g.prototype[b] === d) {
      f = !0;
    } else {
      if (f) {
        return g.prototype[b].apply(a, e);
      }
    }
  }
  if (a[b] === d) {
    return a.constructor.prototype[b].apply(a, e);
  }
  throw Error("goog.base called from a method of one name to a method of a different name");
};
goog.scope = function(a) {
  a.call(goog.global);
};
COMPILED || (goog.global.COMPILED = COMPILED);
goog.defineClass = function(a, b) {
  var c = b.constructor, d = b.statics;
  c && c != Object.prototype.constructor || (c = function() {
    throw Error("cannot instantiate an interface (no constructor defined).");
  });
  c = goog.defineClass.createSealingConstructor_(c, a);
  a && goog.inherits(c, a);
  delete b.constructor;
  delete b.statics;
  goog.defineClass.applyProperties_(c.prototype, b);
  null != d && (d instanceof Function ? d(c) : goog.defineClass.applyProperties_(c, d));
  return c;
};
goog.defineClass.SEAL_CLASS_INSTANCES = goog.DEBUG;
goog.defineClass.createSealingConstructor_ = function(a, b) {
  if (goog.defineClass.SEAL_CLASS_INSTANCES && Object.seal instanceof Function) {
    if (b && b.prototype && b.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_]) {
      return a;
    }
    var c = function() {
      var b = a.apply(this, arguments) || this;
      b[goog.UID_PROPERTY_] = b[goog.UID_PROPERTY_];
      this.constructor === c && Object.seal(b);
      return b;
    };
    return c;
  }
  return a;
};
goog.defineClass.OBJECT_PROTOTYPE_FIELDS_ = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
goog.defineClass.applyProperties_ = function(a, b) {
  for (var c in b) {
    Object.prototype.hasOwnProperty.call(b, c) && (a[c] = b[c]);
  }
  for (var d = 0;d < goog.defineClass.OBJECT_PROTOTYPE_FIELDS_.length;d++) {
    c = goog.defineClass.OBJECT_PROTOTYPE_FIELDS_[d], Object.prototype.hasOwnProperty.call(b, c) && (a[c] = b[c]);
  }
};
goog.tagUnsealableClass = function(a) {
  !COMPILED && goog.defineClass.SEAL_CLASS_INSTANCES && (a.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_] = !0);
};
goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_ = "goog_defineClass_legacy_unsealable";
var com = {cognitect:{}};
com.cognitect.transducers = {};
var TRANSDUCERS_DEV = !0, TRANSDUCERS_NODE_TARGET = !0, TRANSDUCERS_BROWSER_TARGET = !1, TRANSDUCERS_BROWSER_AMD_TARGET = !1;
com.cognitect.transducers.ITER_SYMBOL = "undefined" != typeof Symbol ? Symbol.iterator : "@@iterator";
com.cognitect.transducers.ITransformer = function() {
};
com.cognitect.transducers.ITransformer.prototype["@@transducer/init"] = function() {
};
com.cognitect.transducers.ITransformer.prototype["@@transducer/result"] = function(a) {
};
com.cognitect.transducers.ITransformer.prototype["@@transducer/step"] = function(a, b) {
};
com.cognitect.transducers.IReduced = function() {
};
com.cognitect.transducers.isString = function(a) {
  return "string" == typeof a;
};
com.cognitect.transducers.isArray = "undefined" != typeof Array.isArray ? function(a) {
  return Array.isArray(a);
} : function(a) {
  return "array" == goog.typeOf(a);
};
com.cognitect.transducers.isObject = function(a) {
  return "object" == goog.typeOf(a);
};
com.cognitect.transducers.isIterable = function(a) {
  return a[com.cognitect.transducers.ITER_SYMBOL] || a.next;
};
com.cognitect.transducers.slice = function(a, b, c) {
  return null == c ? Array.prototype.slice.call(a, b) : Array.prototype.slice.call(a, b, c);
};
com.cognitect.transducers.complement = function(a) {
  return function(b) {
    return !a.apply(null, com.cognitect.transducers.slice(arguments, 0));
  };
};
com.cognitect.transducers.Wrap = function(a) {
  this.stepFn = a;
};
com.cognitect.transducers.Wrap.prototype["@@transducer/init"] = function() {
  throw Error("init not implemented");
};
com.cognitect.transducers.Wrap.prototype["@@transducer/result"] = function(a) {
  return a;
};
com.cognitect.transducers.Wrap.prototype["@@transducer/step"] = function(a, b) {
  return this.stepFn(a, b);
};
com.cognitect.transducers.wrap = function(a) {
  return "function" == typeof a ? new com.cognitect.transducers.Wrap(a) : a;
};
com.cognitect.transducers.Reduced = function(a) {
  this["@@transducer/reduced"] = !0;
  this["@@transducer/value"] = a;
};
com.cognitect.transducers.reduced = function(a) {
  return new com.cognitect.transducers.Reduced(a);
};
com.cognitect.transducers.isReduced = function(a) {
  return a instanceof com.cognitect.transducers.Reduced || a && a["@@transducer/reduced"];
};
com.cognitect.transducers.ensureReduced = function(a) {
  return com.cognitect.transducers.isReduced(a) ? a : com.cognitect.transducers.reduced(a);
};
com.cognitect.transducers.deref = function(a) {
  return a["@@transducer/value"];
};
com.cognitect.transducers.unreduced = function(a) {
  return com.cognitect.transducers.isReduced(a) ? com.cognitect.transducers.deref(a) : a;
};
com.cognitect.transducers.identity = function(a) {
  return a;
};
com.cognitect.transducers.comp = function(a) {
  var b = arguments.length;
  if (2 == b) {
    var c = arguments[0], d = arguments[1];
    return function(a) {
      return c(d.apply(null, com.cognitect.transducers.slice(arguments, 0)));
    };
  }
  if (2 < b) {
    return com.cognitect.transducers.reduce(com.cognitect.transducers.comp, arguments[0], com.cognitect.transducers.slice(arguments, 1));
  }
  if (TRANSDUCERS_DEV) {
    throw Error("comp must given at least 2 arguments");
  }
};
com.cognitect.transducers.Map = function(a, b) {
  this.f = a;
  this.xf = b;
};
com.cognitect.transducers.Map.prototype["@@transducer/init"] = function() {
  return this.xf["@@transducer/init"]();
};
com.cognitect.transducers.Map.prototype["@@transducer/result"] = function(a) {
  return this.xf["@@transducer/result"](a);
};
com.cognitect.transducers.Map.prototype["@@transducer/step"] = function(a, b) {
  return this.xf["@@transducer/step"](a, this.f(b));
};
com.cognitect.transducers.map = function(a) {
  if (TRANSDUCERS_DEV && null == a) {
    throw Error("At least one argument must be supplied to map");
  }
  return function(b) {
    return new com.cognitect.transducers.Map(a, b);
  };
};
com.cognitect.transducers.Filter = function(a, b) {
  this.pred = a;
  this.xf = b;
};
com.cognitect.transducers.Filter.prototype["@@transducer/init"] = function() {
  return this.xf["@@transducer/init"]();
};
com.cognitect.transducers.Filter.prototype["@@transducer/result"] = function(a) {
  return this.xf["@@transducer/result"](a);
};
com.cognitect.transducers.Filter.prototype["@@transducer/step"] = function(a, b) {
  return this.pred(b) ? this.xf["@@transducer/step"](a, b) : a;
};
com.cognitect.transducers.filter = function(a) {
  if (TRANSDUCERS_DEV && "function" != typeof a) {
    throw Error("filter must be given a function");
  }
  return function(b) {
    return new com.cognitect.transducers.Filter(a, b);
  };
};
com.cognitect.transducers.remove = function(a) {
  if (TRANSDUCERS_DEV && "function" != typeof a) {
    throw Error("remove must be given a function");
  }
  return com.cognitect.transducers.filter(com.cognitect.transducers.complement(a));
};
com.cognitect.transducers.Take = function(a, b) {
  this.n = a;
  this.xf = b;
};
com.cognitect.transducers.Take.prototype["@@transducer/init"] = function() {
  return this.xf["@@transducer/init"]();
};
com.cognitect.transducers.Take.prototype["@@transducer/result"] = function(a) {
  return this.xf["@@transducer/result"](a);
};
com.cognitect.transducers.Take.prototype["@@transducer/step"] = function(a, b) {
  a = 0 < this.n ? this.xf["@@transducer/step"](a, b) : com.cognitect.transducers.ensureReduced(a);
  this.n--;
  return a;
};
com.cognitect.transducers.take = function(a) {
  if (TRANSDUCERS_DEV && "number" != typeof a) {
    throw Error("take must be given an integer");
  }
  return function(b) {
    return new com.cognitect.transducers.Take(a, b);
  };
};
com.cognitect.transducers.TakeWhile = function(a, b) {
  this.pred = a;
  this.xf = b;
};
com.cognitect.transducers.TakeWhile.prototype["@@transducer/init"] = function() {
  return this.xf["@@transducer/init"]();
};
com.cognitect.transducers.TakeWhile.prototype["@@transducer/result"] = function(a) {
  return this.xf["@@transducer/result"](a);
};
com.cognitect.transducers.TakeWhile.prototype["@@transducer/step"] = function(a, b) {
  return this.pred(b) ? this.xf["@@transducer/step"](a, b) : com.cognitect.transducers.reduced(a);
};
com.cognitect.transducers.takeWhile = function(a) {
  if (TRANSDUCERS_DEV && "function" != typeof a) {
    throw Error("takeWhile must given a function");
  }
  return function(b) {
    return new com.cognitect.transducers.TakeWhile(a, b);
  };
};
com.cognitect.transducers.TakeNth = function(a, b) {
  this.i = -1;
  this.n = a;
  this.xf = b;
};
com.cognitect.transducers.TakeNth.prototype["@@transducer/init"] = function() {
  return this.xf["@@transducer/init"]();
};
com.cognitect.transducers.TakeNth.prototype["@@transducer/result"] = function(a) {
  return this.xf["@@transducer/result"](a);
};
com.cognitect.transducers.TakeNth.prototype["@@transducer/step"] = function(a, b) {
  this.i++;
  return 0 == this.i % this.n ? this.xf["@@transducer/step"](a, b) : a;
};
com.cognitect.transducers.takeNth = function(a) {
  if (TRANSDUCERS_DEV && "number" != typeof a) {
    throw Error("takeNth must be given a number");
  }
  return function(b) {
    return new com.cognitect.transducers.TakeNth(a, b);
  };
};
com.cognitect.transducers.Drop = function(a, b) {
  this.n = a;
  this.xf = b;
};
com.cognitect.transducers.Drop.prototype["@@transducer/init"] = function() {
  return this.xf["@@transducer/init"]();
};
com.cognitect.transducers.Drop.prototype["@@transducer/result"] = function(a) {
  return this.xf["@@transducer/result"](a);
};
com.cognitect.transducers.Drop.prototype["@@transducer/step"] = function(a, b) {
  return 0 < this.n ? (this.n--, a) : this.xf["@@transducer/step"](a, b);
};
com.cognitect.transducers.drop = function(a) {
  if (TRANSDUCERS_DEV && "number" !== typeof a) {
    throw Error("drop must be given an integer");
  }
  return function(b) {
    return new com.cognitect.transducers.Drop(a, b);
  };
};
com.cognitect.transducers.DropWhile = function(a, b) {
  this.drop = !0;
  this.pred = a;
  this.xf = b;
};
com.cognitect.transducers.DropWhile.prototype["@@transducer/init"] = function() {
  return this.xf["@@transducer/init"]();
};
com.cognitect.transducers.DropWhile.prototype["@@transducer/result"] = function(a) {
  return this.xf["@@transducer/result"](a);
};
com.cognitect.transducers.DropWhile.prototype["@@transducer/step"] = function(a, b) {
  if (this.drop && this.pred(b)) {
    return a;
  }
  this.drop && (this.drop = !1);
  return this.xf["@@transducer/step"](a, b);
};
com.cognitect.transducers.dropWhile = function(a) {
  if (TRANSDUCERS_DEV && "function" != typeof a) {
    throw Error("dropWhile must be given a function");
  }
  return function(b) {
    return new com.cognitect.transducers.DropWhile(a, b);
  };
};
com.cognitect.transducers.NONE = {};
com.cognitect.transducers.PartitionBy = function(a, b) {
  this.f = a;
  this.xf = b;
  this.a = [];
  this.pval = com.cognitect.transducers.NONE;
};
com.cognitect.transducers.PartitionBy.prototype["@@transducer/init"] = function() {
  return this.xf["@@transducer/init"]();
};
com.cognitect.transducers.PartitionBy.prototype["@@transducer/result"] = function(a) {
  0 < this.a.length && (a = com.cognitect.transducers.unreduced(this.xf["@@transducer/step"](a, this.a)), this.a = []);
  return this.xf["@@transducer/result"](a);
};
com.cognitect.transducers.PartitionBy.prototype["@@transducer/step"] = function(a, b) {
  var c = this.pval, d = this.f(b);
  this.pval = d;
  if (c == com.cognitect.transducers.NONE || c == d) {
    return this.a.push(b), a;
  }
  c = this.xf["@@transducer/step"](a, this.a);
  this.a = [];
  com.cognitect.transducers.isReduced(c) || this.a.push(b);
  return c;
};
com.cognitect.transducers.partitionBy = function(a) {
  if (TRANSDUCERS_DEV && "function" != typeof a) {
    throw Error("partitionBy must be given an function");
  }
  return function(b) {
    return new com.cognitect.transducers.PartitionBy(a, b);
  };
};
com.cognitect.transducers.PartitionAll = function(a, b) {
  this.n = a;
  this.xf = b;
  this.a = [];
};
com.cognitect.transducers.PartitionAll.prototype["@@transducer/init"] = function() {
  return this.xf["@@transducer/init"]();
};
com.cognitect.transducers.PartitionAll.prototype["@@transducer/result"] = function(a) {
  0 < this.a.length && (a = com.cognitect.transducers.unreduced(this.xf["@@transducer/step"](a, this.a)), this.a = []);
  return this.xf["@@transducer/result"](a);
};
com.cognitect.transducers.PartitionAll.prototype["@@transducer/step"] = function(a, b) {
  this.a.push(b);
  if (this.n == this.a.length) {
    var c = this.a;
    this.a = [];
    return this.xf["@@transducer/step"](a, c);
  }
  return a;
};
com.cognitect.transducers.partitionAll = function(a) {
  if (TRANSDUCERS_DEV && "number" != typeof a) {
    throw Error("partitionAll must be given a number");
  }
  return function(b) {
    return new com.cognitect.transducers.PartitionAll(a, b);
  };
};
com.cognitect.transducers.Keep = function(a, b) {
  this.f = a;
  this.xf = b;
};
com.cognitect.transducers.Keep.prototype["@@transducer/init"] = function() {
  return this.xf["@@transducer/init"]();
};
com.cognitect.transducers.Keep.prototype["@@transducer/result"] = function(a) {
  return this.xf["@@transducer/result"](a);
};
com.cognitect.transducers.Keep.prototype["@@transducer/step"] = function(a, b) {
  return null == this.f(b) ? a : this.xf["@@transducer/step"](a, b);
};
com.cognitect.transducers.keep = function(a) {
  if (TRANSDUCERS_DEV && "function" != typeof a) {
    throw Error("keep must be given a function");
  }
  return function(b) {
    return new com.cognitect.transducers.Keep(a, b);
  };
};
com.cognitect.transducers.KeepIndexed = function(a, b) {
  this.i = -1;
  this.f = a;
  this.xf = b;
};
com.cognitect.transducers.KeepIndexed.prototype["@@transducer/init"] = function() {
  return this.xf["@@transducer/init"]();
};
com.cognitect.transducers.KeepIndexed.prototype["@@transducer/result"] = function(a) {
  return this.xf["@@transducer/result"](a);
};
com.cognitect.transducers.KeepIndexed.prototype["@@transducer/step"] = function(a, b) {
  this.i++;
  return null == this.f(this.i, b) ? a : this.xf["@@transducer/step"](a, b);
};
com.cognitect.transducers.keepIndexed = function(a) {
  if (TRANSDUCERS_DEV && "function" != typeof a) {
    throw Error("keepIndexed must be given a function");
  }
  return function(b) {
    return new com.cognitect.transducers.KeepIndexed(a, b);
  };
};
com.cognitect.transducers.preservingReduced = function(a) {
  return {"@@transducer/init":function() {
    return a["@@transducer/init"]();
  }, "@@transducer/result":function(a) {
    return a;
  }, "@@transducer/step":function(b, c) {
    var d = a["@@transducer/step"](b, c);
    return com.cognitect.transducers.isReduced(d) ? com.cognitect.transducers.reduced(d) : d;
  }};
};
com.cognitect.transducers.cat = function(a) {
  var b = com.cognitect.transducers.preservingReduced(a);
  return {"@@transducer/init":function() {
    return a["@@transducer/init"]();
  }, "@@transducer/result":function(b) {
    return a["@@transducer/result"](b);
  }, "@@transducer/step":function(a, d) {
    return com.cognitect.transducers.reduce(b, a, d);
  }};
};
com.cognitect.transducers.mapcat = function(a) {
  return com.cognitect.transducers.comp(com.cognitect.transducers.map(a), com.cognitect.transducers.cat);
};
com.cognitect.transducers.stringReduce = function(a, b, c) {
  for (var d = 0;d < c.length;d++) {
    if (b = a["@@transducer/step"](b, c.charAt(d)), com.cognitect.transducers.isReduced(b)) {
      b = com.cognitect.transducers.deref(b);
      break;
    }
  }
  return a["@@transducer/result"](b);
};
com.cognitect.transducers.arrayReduce = function(a, b, c) {
  for (var d = 0;d < c.length;d++) {
    if (b = a["@@transducer/step"](b, c[d]), com.cognitect.transducers.isReduced(b)) {
      b = com.cognitect.transducers.deref(b);
      break;
    }
  }
  return a["@@transducer/result"](b);
};
com.cognitect.transducers.objectReduce = function(a, b, c) {
  for (var d in c) {
    if (c.hasOwnProperty(d) && (b = a["@@transducer/step"](b, [d, c[d]]), com.cognitect.transducers.isReduced(b))) {
      b = com.cognitect.transducers.deref(b);
      break;
    }
  }
  return a["@@transducer/result"](b);
};
com.cognitect.transducers.iterableReduce = function(a, b, c) {
  c[com.cognitect.transducers.ITER_SYMBOL] && (c = c[com.cognitect.transducers.ITER_SYMBOL]());
  for (var d = c.next();!d.done;) {
    b = a["@@transducer/step"](b, d.value);
    if (com.cognitect.transducers.isReduced(b)) {
      b = com.cognitect.transducers.deref(b);
      break;
    }
    d = c.next();
  }
  return a["@@transducer/result"](b);
};
com.cognitect.transducers.reduce = function(a, b, c) {
  if (c) {
    a = "function" == typeof a ? com.cognitect.transducers.wrap(a) : a;
    if (com.cognitect.transducers.isString(c)) {
      return com.cognitect.transducers.stringReduce(a, b, c);
    }
    if (com.cognitect.transducers.isArray(c)) {
      return com.cognitect.transducers.arrayReduce(a, b, c);
    }
    if (com.cognitect.transducers.isIterable(c)) {
      return com.cognitect.transducers.iterableReduce(a, b, c);
    }
    if (com.cognitect.transducers.isObject(c)) {
      return com.cognitect.transducers.objectReduce(a, b, c);
    }
    throw Error("Cannot reduce instance of " + c.constructor.name);
  }
};
com.cognitect.transducers.transduce = function(a, b, c, d) {
  if (3 == arguments.length) {
    d = c;
    if ("function" == typeof b) {
      throw Error("If given only three arguments f must satisfy the ITransformer interface.");
    }
    c = b["@@transducer/init"]();
  }
  b = "function" == typeof b ? com.cognitect.transducers.wrap(b) : b;
  a = a(b);
  return com.cognitect.transducers.reduce(a, c, d);
};
com.cognitect.transducers.stringAppend = function(a, b) {
  return a + b;
};
com.cognitect.transducers.arrayPush = function(a, b) {
  a.push(b);
  return a;
};
com.cognitect.transducers.addEntry = function(a, b) {
  a[b[0]] = b[1];
  return a;
};
com.cognitect.transducers.into = function(a, b, c) {
  if (com.cognitect.transducers.isString(a)) {
    return com.cognitect.transducers.transduce(b, com.cognitect.transducers.stringAppend, a, c);
  }
  if (com.cognitect.transducers.isArray(a)) {
    return com.cognitect.transducers.transduce(b, com.cognitect.transducers.arrayPush, a, c);
  }
  if (com.cognitect.transducers.isObject(a)) {
    return com.cognitect.transducers.transduce(b, com.cognitect.transducers.addEntry, a, c);
  }
};
com.cognitect.transducers.Completing = function(a, b) {
  this.cf = a;
  this.xf = b;
};
com.cognitect.transducers.Completing.prototype["@@transducer/init"] = function() {
  return this.xf["@@transducer/init"]();
};
com.cognitect.transducers.Completing.prototype["@@transducer/result"] = function(a) {
  return this.cf(a);
};
com.cognitect.transducers.Completing.prototype["@@transducer/step"] = function(a, b) {
  return this.xf["@@transducer/step"](a, b);
};
com.cognitect.transducers.completing = function(a, b) {
  a = "function" == typeof a ? com.cognitect.transducers.wrap(a) : a;
  b = b || com.cognitect.transducers.identity;
  if (TRANSDUCERS_DEV && null != a && !com.cognitect.transducers.isObject(a)) {
    throw Error("completing must be given a transducer as first argument");
  }
  return new com.cognitect.transducers.Completing(b, a);
};
com.cognitect.transducers.toFn = function(a, b) {
  "function" == typeof b && (b = com.cognitect.transducers.wrap(b));
  var c = a(b);
  return c["@@transducer/step"].bind(c);
};
com.cognitect.transducers.first = com.cognitect.transducers.wrap(function(a, b) {
  return com.cognitect.transducers.reduced(b);
});
TRANSDUCERS_BROWSER_TARGET && (goog.exportSymbol("transducers.reduced", com.cognitect.transducers.reduced), goog.exportSymbol("transducers.isReduced", com.cognitect.transducers.isReduced), goog.exportSymbol("transducers.comp", com.cognitect.transducers.comp), goog.exportSymbol("transducers.complement", com.cognitect.transducers.complement), goog.exportSymbol("transducers.identity", com.cognitect.transducers.identity), goog.exportSymbol("transducers.transduce", com.cognitect.transducers.transduce), 
goog.exportSymbol("transducers.reduce", com.cognitect.transducers.reduce), goog.exportSymbol("transducers.map", com.cognitect.transducers.map), goog.exportSymbol("transducers.Map", com.cognitect.transducers.Map), goog.exportSymbol("transducers.filter", com.cognitect.transducers.filter), goog.exportSymbol("transducers.Filter", com.cognitect.transducers.Filter), goog.exportSymbol("transducers.remove", com.cognitect.transducers.remove), goog.exportSymbol("transducers.Remove", com.cognitect.transducers.Remove), 
goog.exportSymbol("transducers.keep", com.cognitect.transducers.keep), goog.exportSymbol("transducers.Keep", com.cognitect.transducers.Keep), goog.exportSymbol("transducers.keepIndexed", com.cognitect.transducers.keepIndexed), goog.exportSymbol("transducers.KeepIndexed", com.cognitect.transducers.KeepIndexed), goog.exportSymbol("transducers.take", com.cognitect.transducers.take), goog.exportSymbol("transducers.Take", com.cognitect.transducers.Take), goog.exportSymbol("transducers.takeWhile", com.cognitect.transducers.takeWhile), 
goog.exportSymbol("transducers.TakeWhile", com.cognitect.transducers.TakeWhile), goog.exportSymbol("transducers.takeNth", com.cognitect.transducers.takeNth), goog.exportSymbol("transducers.TakeNth", com.cognitect.transducers.TakeNth), goog.exportSymbol("transducers.drop", com.cognitect.transducers.drop), goog.exportSymbol("transducers.Drop", com.cognitect.transducers.Drop), goog.exportSymbol("transducers.dropWhile", com.cognitect.transducers.dropWhile), goog.exportSymbol("transducers.DropWhile", 
com.cognitect.transducers.DropWhile), goog.exportSymbol("transducers.partitionBy", com.cognitect.transducers.partitionBy), goog.exportSymbol("transducers.PartitionBy", com.cognitect.transducers.PartitionBy), goog.exportSymbol("transducers.partitionAll", com.cognitect.transducers.partitionAll), goog.exportSymbol("transducers.PartitionAll", com.cognitect.transducers.PartitionAll), goog.exportSymbol("transducers.completing", com.cognitect.transducers.completing), goog.exportSymbol("transducers.Completing", 
com.cognitect.transducers.Completing), goog.exportSymbol("transducers.wrap", com.cognitect.transducers.wrap), goog.exportSymbol("transducers.Wrap", com.cognitect.transducers.Wrap), goog.exportSymbol("transducers.cat", com.cognitect.transducers.cat), goog.exportSymbol("transducers.mapcat", com.cognitect.transducers.mapcat), goog.exportSymbol("transducers.into", com.cognitect.transducers.into), goog.exportSymbol("transducers.toFn", com.cognitect.transducers.toFn), goog.exportSymbol("transducers.first", 
com.cognitect.transducers.first), goog.exportSymbol("transducers.ensureReduced", com.cognitect.transducers.ensureReduced), goog.exportSymbol("transducers.unreduced", com.cognitect.transducers.unreduced), goog.exportSymbol("transducers.deref", com.cognitect.transducers.deref));
TRANSDUCERS_NODE_TARGET && (module.exports = {reduced:com.cognitect.transducers.reduced, isReduced:com.cognitect.transducers.isReduced, comp:com.cognitect.transducers.comp, complement:com.cognitect.transducers.complement, identity:com.cognitect.transducers.identity, map:com.cognitect.transducers.map, Map:com.cognitect.transducers.Map, filter:com.cognitect.transducers.filter, Filter:com.cognitect.transducers.Filter, remove:com.cognitect.transducers.remove, Remove:com.cognitect.transducers.Remove, 
keep:com.cognitect.transducers.keep, Kemove:com.cognitect.transducers.Keep, keepIndexed:com.cognitect.transducers.keepIndexed, KeepIndexed:com.cognitect.transducers.KeepIndexed, take:com.cognitect.transducers.take, Take:com.cognitect.transducers.Take, takeWhile:com.cognitect.transducers.takeWhile, TakeWhile:com.cognitect.transducers.TakeWhile, takeNth:com.cognitect.transducers.takeNth, TakeNth:com.cognitect.transducers.TakeNth, drop:com.cognitect.transducers.drop, Drop:com.cognitect.transducers.Drop, 
dropWhile:com.cognitect.transducers.dropWhile, DropWhile:com.cognitect.transducers.DropWhile, partitionBy:com.cognitect.transducers.partitionBy, PartitionBy:com.cognitect.transducers.PartitionBy, partitionAll:com.cognitect.transducers.partitionAll, PartitionAll:com.cognitect.transducers.PartitionAll, completing:com.cognitect.transducers.completing, Completing:com.cognitect.transducers.Completing, wrap:com.cognitect.transducers.wrap, Wrap:com.cognitect.transducers.Wrap, cat:com.cognitect.transducers.cat, 
mapcat:com.cognitect.transducers.mapcat, transduce:com.cognitect.transducers.transduce, reduce:com.cognitect.transducers.reduce, into:com.cognitect.transducers.into, toFn:com.cognitect.transducers.toFn, first:com.cognitect.transducers.first, ensureReduced:com.cognitect.transducers.ensureReduced, unreduced:com.cognitect.transducers.unreduced, deref:com.cognitect.transducers.deref});


},{}],173:[function(require,module,exports){

// basic protocol helpers

var symbolExists = typeof Symbol !== 'undefined';

var protocols = {
  iterator: symbolExists ? Symbol.iterator : '@@iterator'
};

function throwProtocolError(name, coll) {
  throw new Error("don't know how to " + name + " collection: " +
                  coll);
}

function fulfillsProtocol(obj, name) {
  if(name === 'iterator') {
    // Accept ill-formed iterators that don't conform to the
    // protocol by accepting just next()
    return obj[protocols.iterator] || obj.next;
  }

  return obj[protocols[name]];
}

function getProtocolProperty(obj, name) {
  return obj[protocols[name]];
}

function iterator(coll) {
  var iter = getProtocolProperty(coll, 'iterator');
  if(iter) {
    return iter.call(coll);
  }
  else if(coll.next) {
    // Basic duck typing to accept an ill-formed iterator that doesn't
    // conform to the iterator protocol (all iterators should have the
    // @@iterator method and return themselves, but some engines don't
    // have that on generators like older v8)
    return coll;
  }
  else if(isArray(coll)) {
    return new ArrayIterator(coll);
  }
  else if(isObject(coll)) {
    return new ObjectIterator(coll);
  }
}

function ArrayIterator(arr) {
  this.arr = arr;
  this.index = 0;
}

ArrayIterator.prototype.next = function() {
  if(this.index < this.arr.length) {
    return {
      value: this.arr[this.index++],
      done: false
    };
  }
  return {
    done: true
  }
};

function ObjectIterator(obj) {
  this.obj = obj;
  this.keys = Object.keys(obj);
  this.index = 0;
}

ObjectIterator.prototype.next = function() {
  if(this.index < this.keys.length) {
    var k = this.keys[this.index++];
    return {
      value: [k, this.obj[k]],
      done: false
    };
  }
  return {
    done: true
  }
};

// helpers

var toString = Object.prototype.toString;
var isArray = typeof Array.isArray === 'function' ? Array.isArray : function(obj) {
  return toString.call(obj) == '[object Array]';
};

function isFunction(x) {
  return typeof x === 'function';
}

function isObject(x) {
  return x instanceof Object &&
    Object.getPrototypeOf(x) === Object.getPrototypeOf({});
}

function isNumber(x) {
  return typeof x === 'number';
}

function Reduced(value) {
  this['@@transducer/reduced'] = true;
  this['@@transducer/value'] = value;
}

function isReduced(x) {
  return (x instanceof Reduced) || (x && x['@@transducer/reduced']);
}

function deref(x) {
  return x['@@transducer/value'];
}

/**
 * This is for transforms that may call their nested transforms before
 * Reduced-wrapping the result (e.g. "take"), to avoid nested Reduced.
 */
function ensureReduced(val) {
  if(isReduced(val)) {
    return val;
  } else {
    return new Reduced(val);
  }
}

/**
 * This is for tranforms that call their nested transforms when
 * performing completion (like "partition"), to avoid signaling
 * termination after already completing.
 */
function ensureUnreduced(v) {
  if(isReduced(v)) {
    return deref(v);
  } else {
    return v;
  }
}

function reduce(coll, xform, init) {
  if(isArray(coll)) {
    var result = init;
    var index = -1;
    var len = coll.length;
    while(++index < len) {
      result = xform['@@transducer/step'](result, coll[index]);
      if(isReduced(result)) {
        result = deref(result);
        break;
      }
    }
    return xform['@@transducer/result'](result);
  }
  else if(isObject(coll) || fulfillsProtocol(coll, 'iterator')) {
    var result = init;
    var iter = iterator(coll);
    var val = iter.next();
    while(!val.done) {
      result = xform['@@transducer/step'](result, val.value);
      if(isReduced(result)) {
        result = deref(result);
        break;
      }
      val = iter.next();
    }
    return xform['@@transducer/result'](result);
  }
  throwProtocolError('iterate', coll);
}

function transduce(coll, xform, reducer, init) {
  xform = xform(reducer);
  if(init === undefined) {
    init = xform['@@transducer/init']();
  }
  return reduce(coll, xform, init);
}

function compose() {
  var funcs = Array.prototype.slice.call(arguments);
  return function(r) {
    var value = r;
    for(var i=funcs.length-1; i>=0; i--) {
      value = funcs[i](value);
    }
    return value;
  }
}

// transformations

function transformer(f) {
  var t = {};
  t['@@transducer/init'] = function() {
    throw new Error('init value unavailable');
  };
  t['@@transducer/result'] = function(v) {
    return v;
  };
  t['@@transducer/step'] = f;
  return t;
}

function bound(f, ctx, count) {
  count = count != null ? count : 1;

  if(!ctx) {
    return f;
  }
  else {
    switch(count) {
    case 1:
      return function(x) {
        return f.call(ctx, x);
      }
    case 2:
      return function(x, y) {
        return f.call(ctx, x, y);
      }
    default:
      return f.bind(ctx);
    }
  }
}

function arrayMap(arr, f, ctx) {
  var index = -1;
  var length = arr.length;
  var result = Array(length);
  f = bound(f, ctx, 2);

  while (++index < length) {
    result[index] = f(arr[index], index);
  }
  return result;
}

function arrayFilter(arr, f, ctx) {
  var len = arr.length;
  var result = [];
  f = bound(f, ctx, 2);

  for(var i=0; i<len; i++) {
    if(f(arr[i], i)) {
      result.push(arr[i]);
    }
  }
  return result;
}

function Map(f, xform) {
  this.xform = xform;
  this.f = f;
}

Map.prototype['@@transducer/init'] = function() {
  return this.xform['@@transducer/init']();
};

Map.prototype['@@transducer/result'] = function(v) {
  return this.xform['@@transducer/result'](v);
};

Map.prototype['@@transducer/step'] = function(res, input) {
  return this.xform['@@transducer/step'](res, this.f(input));
};

function map(coll, f, ctx) {
  if(isFunction(coll)) { ctx = f; f = coll; coll = null; }
  f = bound(f, ctx);

  if(coll) {
    if(isArray(coll)) {
      return arrayMap(coll, f, ctx);
    }
    return seq(coll, map(f));
  }

  return function(xform) {
    return new Map(f, xform);
  }
}

function Filter(f, xform) {
  this.xform = xform;
  this.f = f;
}

Filter.prototype['@@transducer/init'] = function() {
  return this.xform['@@transducer/init']();
};

Filter.prototype['@@transducer/result'] = function(v) {
  return this.xform['@@transducer/result'](v);
};

Filter.prototype['@@transducer/step'] = function(res, input) {
  if(this.f(input)) {
    return this.xform['@@transducer/step'](res, input);
  }
  return res;
};

function filter(coll, f, ctx) {
  if(isFunction(coll)) { ctx = f; f = coll; coll = null; }
  f = bound(f, ctx);

  if(coll) {
    if(isArray(coll)) {
      return arrayFilter(coll, f, ctx);
    }
    return seq(coll, filter(f));
  }

  return function(xform) {
    return new Filter(f, xform);
  };
}

function remove(coll, f, ctx) {
  if(isFunction(coll)) { ctx = f; f = coll; coll = null; }
  f = bound(f, ctx);
  return filter(coll, function(x) { return !f(x); });
}

function keep(coll) {
  return filter(coll, function(x) { return x != null });
}

function Dedupe(xform) {
  this.xform = xform;
  this.last = undefined;
}

Dedupe.prototype['@@transducer/init'] = function() {
  return this.xform['@@transducer/init']();
};

Dedupe.prototype['@@transducer/result'] = function(v) {
  return this.xform['@@transducer/result'](v);
};

Dedupe.prototype['@@transducer/step'] = function(result, input) {
  if(input !== this.last) {
    this.last = input;
    return this.xform['@@transducer/step'](result, input);
  }
  return result;
};

function dedupe(coll) {
  if(coll) {
    return seq(coll, dedupe());
  }

  return function(xform) {
    return new Dedupe(xform);
  }
}

function TakeWhile(f, xform) {
  this.xform = xform;
  this.f = f;
}

TakeWhile.prototype['@@transducer/init'] = function() {
  return this.xform['@@transducer/init']();
};

TakeWhile.prototype['@@transducer/result'] = function(v) {
  return this.xform['@@transducer/result'](v);
};

TakeWhile.prototype['@@transducer/step'] = function(result, input) {
  if(this.f(input)) {
    return this.xform['@@transducer/step'](result, input);
  }
  return new Reduced(result);
};

function takeWhile(coll, f, ctx) {
  if(isFunction(coll)) { ctx = f; f = coll; coll = null; }
  f = bound(f, ctx);

  if(coll) {
    return seq(coll, takeWhile(f));
  }

  return function(xform) {
    return new TakeWhile(f, xform);
  }
}

function Take(n, xform) {
  this.n = n;
  this.i = 0;
  this.xform = xform;
}

Take.prototype['@@transducer/init'] = function() {
  return this.xform['@@transducer/init']();
};

Take.prototype['@@transducer/result'] = function(v) {
  return this.xform['@@transducer/result'](v);
};

Take.prototype['@@transducer/step'] = function(result, input) {
  if (this.i < this.n) {
    result = this.xform['@@transducer/step'](result, input);
    if(this.i + 1 >= this.n) {
      // Finish reducing on the same step as the final value. TODO:
      // double-check that this doesn't break any semantics
      result = ensureReduced(result);
    }
  }
  this.i++;
  return result;
};

function take(coll, n) {
  if(isNumber(coll)) { n = coll; coll = null }

  if(coll) {
    return seq(coll, take(n));
  }

  return function(xform) {
    return new Take(n, xform);
  }
}

function Drop(n, xform) {
  this.n = n;
  this.i = 0;
  this.xform = xform;
}

Drop.prototype['@@transducer/init'] = function() {
  return this.xform['@@transducer/init']();
};

Drop.prototype['@@transducer/result'] = function(v) {
  return this.xform['@@transducer/result'](v);
};

Drop.prototype['@@transducer/step'] = function(result, input) {
  if(this.i++ < this.n) {
    return result;
  }
  return this.xform['@@transducer/step'](result, input);
};

function drop(coll, n) {
  if(isNumber(coll)) { n = coll; coll = null }

  if(coll) {
    return seq(coll, drop(n));
  }

  return function(xform) {
    return new Drop(n, xform);
  }
}

function DropWhile(f, xform) {
  this.xform = xform;
  this.f = f;
  this.dropping = true;
}

DropWhile.prototype['@@transducer/init'] = function() {
  return this.xform['@@transducer/init']();
};

DropWhile.prototype['@@transducer/result'] = function(v) {
  return this.xform['@@transducer/result'](v);
};

DropWhile.prototype['@@transducer/step'] = function(result, input) {
  if(this.dropping) {
    if(this.f(input)) {
      return result;
    }
    else {
      this.dropping = false;
    }
  }
  return this.xform['@@transducer/step'](result, input);
};

function dropWhile(coll, f, ctx) {
  if(isFunction(coll)) { ctx = f; f = coll; coll = null; }
  f = bound(f, ctx);

  if(coll) {
    return seq(coll, dropWhile(f));
  }

  return function(xform) {
    return new DropWhile(f, xform);
  }
}

function Partition(n, xform) {
  this.n = n;
  this.i = 0;
  this.xform = xform;
  this.part = new Array(n);
}

Partition.prototype['@@transducer/init'] = function() {
  return this.xform['@@transducer/init']();
};

Partition.prototype['@@transducer/result'] = function(v) {
  if (this.i > 0) {
    return ensureUnreduced(this.xform['@@transducer/step'](v, this.part.slice(0, this.i)));
  }
  return this.xform['@@transducer/result'](v);
};

Partition.prototype['@@transducer/step'] = function(result, input) {
  this.part[this.i] = input;
  this.i += 1;
  if (this.i === this.n) {
    var out = this.part.slice(0, this.n);
    this.part = new Array(this.n);
    this.i = 0;
    return this.xform['@@transducer/step'](result, out);
  }
  return result;
};

function partition(coll, n) {
  if (isNumber(coll)) {
    n = coll; coll = null;
  }

  if (coll) {
    return seq(coll, partition(n));
  }

  return function(xform) {
    return new Partition(n, xform);
  };
}

var NOTHING = {};

function PartitionBy(f, xform) {
  // TODO: take an "opts" object that allows the user to specify
  // equality
  this.f = f;
  this.xform = xform;
  this.part = [];
  this.last = NOTHING;
}

PartitionBy.prototype['@@transducer/init'] = function() {
  return this.xform['@@transducer/init']();
};

PartitionBy.prototype['@@transducer/result'] = function(v) {
  var l = this.part.length;
  if (l > 0) {
    return ensureUnreduced(this.xform['@@transducer/step'](v, this.part.slice(0, l)));
  }
  return this.xform['@@transducer/result'](v);
};

PartitionBy.prototype['@@transducer/step'] = function(result, input) {
  var current = this.f(input);
  if (current === this.last || this.last === NOTHING) {
    this.part.push(input);
  } else {
    result = this.xform['@@transducer/step'](result, this.part);
    this.part = [input];
  }
  this.last = current;
  return result;
};

function partitionBy(coll, f, ctx) {
  if (isFunction(coll)) { ctx = f; f = coll; coll = null; }
  f = bound(f, ctx);

  if (coll) {
    return seq(coll, partitionBy(f));
  }

  return function(xform) {
    return new PartitionBy(f, xform);
  };
}

function Interpose(sep, xform) {
  this.sep = sep;
  this.xform = xform;
  this.started = false;
}

Interpose.prototype['@@transducer/init'] = function() {
  return this.xform['@@transducer/init']();
};

Interpose.prototype['@@transducer/result'] = function(v) {
  return this.xform['@@transducer/result'](v);
};

Interpose.prototype['@@transducer/step'] = function(result, input) {
  if (this.started) {
    var withSep = this.xform['@@transducer/step'](result, this.sep);
    if (isReduced(withSep)) {
      return withSep;
    } else {
      return this.xform['@@transducer/step'](withSep, input);
    }
  } else {
    this.started = true;
    return this.xform['@@transducer/step'](result, input);
  }
};

/**
 * Returns a new collection containing elements of the given
 * collection, separated by the specified separator. Returns a
 * transducer if a collection is not provided.
 */
function interpose(coll, separator) {
  if (arguments.length === 1) {
    separator = coll;
    return function(xform) {
      return new Interpose(separator, xform);
    };
  }
  return seq(coll, interpose(separator));
}

function Repeat(n, xform) {
  this.xform = xform;
  this.n = n;
}

Repeat.prototype['@@transducer/init'] = function() {
  return this.xform['@@transducer/init']();
};

Repeat.prototype['@@transducer/result'] = function(v) {
  return this.xform['@@transducer/result'](v);
};

Repeat.prototype['@@transducer/step'] = function(result, input) {
  var n = this.n;
  var r = result;
  for (var i = 0; i < n; i++) {
    r = this.xform['@@transducer/step'](r, input);
    if (isReduced(r)) {
      break;
    }
  }
  return r;
};

/**
 * Returns a new collection containing elements of the given
 * collection, each repeated n times. Returns a transducer if a
 * collection is not provided.
 */
function repeat(coll, n) {
  if (arguments.length === 1) {
    n = coll;
    return function(xform) {
      return new Repeat(n, xform);
    };
  }
  return seq(coll, repeat(n));
}

function TakeNth(n, xform) {
  this.xform = xform;
  this.n = n;
  this.i = -1;
}

TakeNth.prototype['@@transducer/init'] = function() {
  return this.xform['@@transducer/init']();
};

TakeNth.prototype['@@transducer/result'] = function(v) {
  return this.xform['@@transducer/result'](v);
};

TakeNth.prototype['@@transducer/step'] = function(result, input) {
  this.i += 1;
  if (this.i % this.n === 0) {
    return this.xform['@@transducer/step'](result, input);
  }
  return result;
};

/**
 * Returns a new collection of every nth element of the given
 * collection. Returns a transducer if a collection is not provided.
 */
function takeNth(coll, nth) {
  if (arguments.length === 1) {
    nth = coll;
    return function(xform) {
      return new TakeNth(nth, xform);
    };
  }
  return seq(coll, takeNth(nth));
}

// pure transducers (cannot take collections)

function Cat(xform) {
  this.xform = xform;
}

Cat.prototype['@@transducer/init'] = function() {
  return this.xform['@@transducer/init']();
};

Cat.prototype['@@transducer/result'] = function(v) {
  return this.xform['@@transducer/result'](v);
};

Cat.prototype['@@transducer/step'] = function(result, input) {
  var xform = this.xform;
  var newxform = {};
  newxform['@@transducer/init'] = function() {
    return xform['@@transducer/init']();
  };
  newxform['@@transducer/result'] = function(v) {
    return v;
  };
  newxform['@@transducer/step'] = function(result, input) {
    var val = xform['@@transducer/step'](result, input);
    return isReduced(val) ? deref(val) : val;
  };

  return reduce(input, newxform, result);
};

function cat(xform) {
  return new Cat(xform);
}

function mapcat(f, ctx) {
  f = bound(f, ctx);
  return compose(map(f), cat);
}

// collection helpers

function push(arr, x) {
  arr.push(x);
  return arr;
}

function merge(obj, x) {
  if(isArray(x) && x.length === 2) {
    obj[x[0]] = x[1];
  }
  else {
    var keys = Object.keys(x);
    var len = keys.length;
    for(var i=0; i<len; i++) {
      obj[keys[i]] = x[keys[i]];
    }
  }
  return obj;
}

var arrayReducer = {};
arrayReducer['@@transducer/init'] = function() {
  return [];
};
arrayReducer['@@transducer/result'] = function(v) {
  return v;
};
arrayReducer['@@transducer/step'] = push;

var objReducer = {};
objReducer['@@transducer/init'] = function() {
  return {};
};
objReducer['@@transducer/result'] = function(v) {
  return v;
};
objReducer['@@transducer/step'] = merge;

// building new collections

function toArray(coll, xform) {
  if(!xform) {
    return reduce(coll, arrayReducer, []);
  }
  return transduce(coll, xform, arrayReducer, []);
}

function toObj(coll, xform) {
  if(!xform) {
    return reduce(coll, objReducer, {});
  }
  return transduce(coll, xform, objReducer, {});
}

function toIter(coll, xform) {
  if(!xform) {
    return iterator(coll);
  }
  return new LazyTransformer(xform, coll);
}

function seq(coll, xform) {
  if(isArray(coll)) {
    return transduce(coll, xform, arrayReducer, []);
  }
  else if(isObject(coll)) {
    return transduce(coll, xform, objReducer, {});
  }
  else if(coll['@@transducer/step']) {
    var init;
    if(coll['@@transducer/init']) {
      init = coll['@@transducer/init']();
    }
    else {
      init = new coll.constructor();
    }

    return transduce(coll, xform, coll, init);
  }
  else if(fulfillsProtocol(coll, 'iterator')) {
    return new LazyTransformer(xform, coll);
  }
  throwProtocolError('sequence', coll);
}

function into(to, xform, from) {
  if(isArray(to)) {
    return transduce(from, xform, arrayReducer, to);
  }
  else if(isObject(to)) {
    return transduce(from, xform, objReducer, to);
  }
  else if(to['@@transducer/step']) {
    return transduce(from,
                     xform,
                     to,
                     to);
  }
  throwProtocolError('into', to);
}

// laziness

var stepper = {};
stepper['@@transducer/result'] = function(v) {
  return isReduced(v) ? deref(v) : v;
};
stepper['@@transducer/step'] = function(lt, x) {
  lt.items.push(x);
  return lt.rest;
};

function Stepper(xform, iter) {
  this.xform = xform(stepper);
  this.iter = iter;
}

Stepper.prototype['@@transducer/step'] = function(lt) {
  var len = lt.items.length;
  while(lt.items.length === len) {
    var n = this.iter.next();
    if(n.done || isReduced(n.value)) {
      // finalize
      this.xform['@@transducer/result'](this);
      break;
    }

    // step
    this.xform['@@transducer/step'](lt, n.value);
  }
}

function LazyTransformer(xform, coll) {
  this.iter = iterator(coll);
  this.items = [];
  this.stepper = new Stepper(xform, iterator(coll));
}

LazyTransformer.prototype[protocols.iterator] = function() {
  return this;
}

LazyTransformer.prototype.next = function() {
  this['@@transducer/step']();

  if(this.items.length) {
    return {
      value: this.items.pop(),
      done: false
    }
  }
  else {
    return { done: true };
  }
};

LazyTransformer.prototype['@@transducer/step'] = function() {
  if(!this.items.length) {
    this.stepper['@@transducer/step'](this);
  }
}

// util

function range(n) {
  var arr = new Array(n);
  for(var i=0; i<arr.length; i++) {
    arr[i] = i;
  }
  return arr;
}

module.exports = {
  reduce: reduce,
  transformer: transformer,
  Reduced: Reduced,
  isReduced: isReduced,
  iterator: iterator,
  push: push,
  merge: merge,
  transduce: transduce,
  seq: seq,
  toArray: toArray,
  toObj: toObj,
  toIter: toIter,
  into: into,
  compose: compose,
  map: map,
  filter: filter,
  remove: remove,
  cat: cat,
  mapcat: mapcat,
  keep: keep,
  dedupe: dedupe,
  take: take,
  takeWhile: takeWhile,
  takeNth: takeNth,
  drop: drop,
  dropWhile: dropWhile,
  partition: partition,
  partitionBy: partitionBy,
  interpose: interpose,
  repeat: repeat,
  range: range,

  LazyTransformer: LazyTransformer
};

},{}],174:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],175:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":174,"_process":142,"inherits":140}],176:[function(require,module,exports){
module.exports = require("./zen-observable.js").Observable;

},{"./zen-observable.js":177}],177:[function(require,module,exports){
'use strict'; (function(fn, name) { if (typeof exports !== 'undefined') fn(exports, module); else if (typeof self !== 'undefined') fn(name === '*' ? self : (name ? self[name] = {} : {})); })(function(exports, module) { // === Symbol Support ===

function hasSymbol(name) {

    return typeof Symbol === "function" && Boolean(Symbol[name]);
}

function getSymbol(name) {

    return hasSymbol(name) ? Symbol[name] : "@@" + name;
}

// === Abstract Operations ===

function getMethod(obj, key) {

    var value = obj[key];

    if (value == null)
        return undefined;

    if (typeof value !== "function")
        throw new TypeError(value + " is not a function");

    return value;
}

function getSpecies(ctor) {

    var symbol = getSymbol("species");
    return symbol ? ctor[symbol] : ctor;
}

function addMethods(target, methods) {

    Object.keys(methods).forEach(function(k) {

        var desc = Object.getOwnPropertyDescriptor(methods, k);
        desc.enumerable = false;
        Object.defineProperty(target, k, desc);
    });
}

function cleanupSubscription(subscription) {

    // Assert:  observer._observer is undefined

    var cleanup = subscription._cleanup;

    if (!cleanup)
        return;

    // Drop the reference to the cleanup function so that we won't call it
    // more than once
    subscription._cleanup = undefined;

    // Call the cleanup function
    cleanup();
}

function subscriptionClosed(subscription) {

    return subscription._observer === undefined;
}

function closeSubscription(subscription) {

    if (subscriptionClosed(subscription))
        return;

    subscription._observer = undefined;
    cleanupSubscription(subscription);
}

function cleanupFromSubscription(subscription) {
    return function(_) { subscription.unsubscribe() };
}

function Subscription(observer, subscriber) {

    // Assert: subscriber is callable

    // The observer must be an object
    if (Object(observer) !== observer)
        throw new TypeError("Observer must be an object");

    this._cleanup = undefined;
    this._observer = observer;

    var start = getMethod(observer, "start");

    if (start)
        start.call(observer, this);

    if (subscriptionClosed(this))
        return;

    observer = new SubscriptionObserver(this);

    try {

        // Call the subscriber function
        var cleanup$0 = subscriber.call(undefined, observer);

        // The return value must be undefined, null, a subscription object, or a function
        if (cleanup$0 != null) {

            if (typeof cleanup$0.unsubscribe === "function")
                cleanup$0 = cleanupFromSubscription(cleanup$0);
            else if (typeof cleanup$0 !== "function")
                throw new TypeError(cleanup$0 + " is not a function");

            this._cleanup = cleanup$0;
        }

    } catch (e) {

        // If an error occurs during startup, then attempt to send the error
        // to the observer
        observer.error(e);
        return;
    }

    // If the stream is already finished, then perform cleanup
    if (subscriptionClosed(this))
        cleanupSubscription(this);
}

addMethods(Subscription.prototype = {}, {
    get closed() { return subscriptionClosed(this) },
    unsubscribe: function() { closeSubscription(this) },
});

function SubscriptionObserver(subscription) {
    this._subscription = subscription;
}

addMethods(SubscriptionObserver.prototype = {}, {

    get closed() { return subscriptionClosed(this._subscription) },

    next: function(value) {

        var subscription = this._subscription;

        // If the stream if closed, then return undefined
        if (subscriptionClosed(subscription))
            return undefined;

        var observer = subscription._observer;

        try {

            var m$0 = getMethod(observer, "next");

            // If the observer doesn't support "next", then return undefined
            if (!m$0)
                return undefined;

            // Send the next value to the sink
            return m$0.call(observer, value);

        } catch (e) {

            // If the observer throws, then close the stream and rethrow the error
            try { closeSubscription(subscription) }
            finally { throw e }
        }
    },

    error: function(value) {

        var subscription = this._subscription;

        // If the stream is closed, throw the error to the caller
        if (subscriptionClosed(subscription))
            throw value;

        var observer = subscription._observer;
        subscription._observer = undefined;

        try {

            var m$1 = getMethod(observer, "error");

            // If the sink does not support "error", then throw the error to the caller
            if (!m$1)
                throw value;

            value = m$1.call(observer, value);

        } catch (e) {

            try { cleanupSubscription(subscription) }
            finally { throw e }
        }

        cleanupSubscription(subscription);
        return value;
    },

    complete: function(value) {

        var subscription = this._subscription;

        // If the stream is closed, then return undefined
        if (subscriptionClosed(subscription))
            return undefined;

        var observer = subscription._observer;
        subscription._observer = undefined;

        try {

            var m$2 = getMethod(observer, "complete");

            // If the sink does not support "complete", then return undefined
            value = m$2 ? m$2.call(observer, value) : undefined;

        } catch (e) {

            try { cleanupSubscription(subscription) }
            finally { throw e }
        }

        cleanupSubscription(subscription);
        return value;
    },

});

function Observable(subscriber) {

    // The stream subscriber must be a function
    if (typeof subscriber !== "function")
        throw new TypeError("Observable initializer must be a function");

    this._subscriber = subscriber;
}

addMethods(Observable.prototype, {

    subscribe: function(observer) { for (var args = [], __$0 = 1; __$0 < arguments.length; ++__$0) args.push(arguments[__$0]); 

        if (typeof observer === 'function') {

            observer = {
                next: observer,
                error: args[0],
                complete: args[1],
            };
        }

        return new Subscription(observer, this._subscriber);
    },

    forEach: function(fn) { var __this = this; 

        return new Promise(function(resolve, reject) {

            if (typeof fn !== "function")
                return Promise.reject(new TypeError(fn + " is not a function"));

            __this.subscribe({

                _subscription: null,

                start: function(subscription) {

                    if (Object(subscription) !== subscription)
                        throw new TypeError(subscription + " is not an object");

                    this._subscription = subscription;
                },

                next: function(value) {

                    var subscription = this._subscription;

                    if (subscription.closed)
                        return;

                    try {

                        return fn(value);

                    } catch (err) {

                        reject(err);
                        subscription.unsubscribe();
                    }
                },

                error: reject,
                complete: resolve,
            });

        });
    },

    map: function(fn) { var __this = this; 

        if (typeof fn !== "function")
            throw new TypeError(fn + " is not a function");

        var C = getSpecies(this.constructor);

        return new C(function(observer) { return __this.subscribe({

            next: function(value) {

                if (observer.closed)
                    return;

                try { value = fn(value) }
                catch (e) { return observer.error(e) }

                return observer.next(value);
            },

            error: function(e) { return observer.error(e) },
            complete: function(x) { return observer.complete(x) },
        }); });
    },

    filter: function(fn) { var __this = this; 

        if (typeof fn !== "function")
            throw new TypeError(fn + " is not a function");

        var C = getSpecies(this.constructor);

        return new C(function(observer) { return __this.subscribe({

            next: function(value) {

                if (observer.closed)
                    return;

                try { if (!fn(value)) return undefined }
                catch (e) { return observer.error(e) }

                return observer.next(value);
            },

            error: function(e) { return observer.error(e) },
            complete: function() { return observer.complete() },
        }); });
    },

    reduce: function(fn) { var __this = this; 

        if (typeof fn !== "function")
            throw new TypeError(fn + " is not a function");

        var C = getSpecies(this.constructor),
            hasSeed = arguments.length > 1,
            hasValue = false,
            seed = arguments[1],
            acc = seed;

        return new C(function(observer) { return __this.subscribe({

            next: function(value) {

                if (observer.closed)
                    return;

                var first = !hasValue;
                hasValue = true;

                if (!first || hasSeed) {

                    try { acc = fn(acc, value) }
                    catch (e) { return observer.error(e) }

                } else {

                    acc = value;
                }
            },

            error: function(e) { return observer.error(e) },

            complete: function() {

                if (!hasValue && !hasSeed) {
                    observer.error(new TypeError("Cannot reduce an empty sequence"));
                    return;
                }

                observer.next(acc);
                observer.complete();
            },

        }); });
    },

    flatMap: function(fn) { var __this = this; 

        if (typeof fn !== "function")
            throw new TypeError(fn + " is not a function");

        var C = getSpecies(this.constructor);

        return new C(function(observer) {

            var completed = false,
                subscriptions = [];

            // Subscribe to the outer Observable
            var outer = __this.subscribe({

                next: function(value) {

                    if (fn) {

                        try {

                            value = fn(value);

                        } catch (x) {

                            observer.error(x);
                            return;
                        }
                    }

                    // Subscribe to the inner Observable
                    Observable.from(value).subscribe({

                        _subscription: null,

                        start: function(s) { subscriptions.push(this._subscription = s) },
                        next: function(value) { observer.next(value) },
                        error: function(e) { observer.error(e) },

                        complete: function() {

                            var i = subscriptions.indexOf(this._subscription);

                            if (i >= 0)
                                subscriptions.splice(i, 1);

                            closeIfDone();
                        }
                    });
                },

                error: function(e) {

                    return observer.error(e);
                },

                complete: function() {

                    completed = true;
                    closeIfDone();
                }
            });

            function closeIfDone() {

                if (completed && subscriptions.length === 0)
                    observer.complete();
            }

            return function(_) {

                subscriptions.forEach(function(s) { return s.unsubscribe(); });
                outer.unsubscribe();
            };
        });
    }

});

Object.defineProperty(Observable.prototype, getSymbol("observable"), {
    value: function() { return this },
    writable: true,
    configurable: true,
});

addMethods(Observable, {

    from: function(x) {

        var C = typeof this === "function" ? this : Observable;

        if (x == null)
            throw new TypeError(x + " is not an object");

        var method = getMethod(x, getSymbol("observable"));

        if (method) {

            var observable$0 = method.call(x);

            if (Object(observable$0) !== observable$0)
                throw new TypeError(observable$0 + " is not an object");

            if (observable$0.constructor === C)
                return observable$0;

            return new C(function(observer) { return observable$0.subscribe(observer); });
        }

        if (hasSymbol("iterator") && (method = getMethod(x, getSymbol("iterator")))) {

            return new C(function(observer) {

                for (var __$0 = (method.call(x))[Symbol.iterator](), __$1; __$1 = __$0.next(), !__$1.done;) { var item$0 = __$1.value; 

                    observer.next(item$0);

                    if (observer.closed)
                        return;
                }

                observer.complete();
            });
        }

        if (Array.isArray(x)) {

            return new C(function(observer) {

                for (var i$0 = 0; i$0 < x.length; ++i$0) {

                    observer.next(x[i$0]);

                    if (observer.closed)
                        return;
                }

                observer.complete();
            });
        }

        throw new TypeError(x + " is not observable");
    },

    of: function() { for (var items = [], __$0 = 0; __$0 < arguments.length; ++__$0) items.push(arguments[__$0]); 

        var C = typeof this === "function" ? this : Observable;

        return new C(function(observer) {

            for (var i$1 = 0; i$1 < items.length; ++i$1) {

                observer.next(items[i$1]);

                if (observer.closed)
                    return;
            }

            observer.complete();
        });
    },

});

Object.defineProperty(Observable, getSymbol("species"), {
    get: function() { return this },
    configurable: true,
});

exports.Observable = Observable;


}, "*");
},{}],178:[function(require,module,exports){
var Kefir, prop, ref, send, stream;

ref = require('../test-helpers.coffee'), stream = ref.stream, prop = ref.prop, send = ref.send, Kefir = ref.Kefir;

describe('beforeEnd', function() {
  describe('stream', function() {
    it('should return stream', function() {
      return expect(stream().beforeEnd(function() {})).toBeStream();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = stream();
      return expect(a.beforeEnd(function() {})).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(stream(), ['<end>']).beforeEnd(function() {
        return 42;
      })).toEmit([
        {
          current: 42
        }, '<end:current>'
      ]);
    });
    it('should handle events', function() {
      var a;
      a = stream();
      return expect(a.beforeEnd(function() {
        return 42;
      })).toEmit([1, 2, 42, '<end>'], function() {
        return send(a, [1, 2, '<end>']);
      });
    });
    return it('errors should flow', function() {
      var a;
      a = stream();
      return expect(a.beforeEnd(function() {})).errorsToFlow(a);
    });
  });
  return describe('property', function() {
    it('should return property', function() {
      return expect(prop().beforeEnd(function() {})).toBeProperty();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = prop();
      return expect(a.beforeEnd(function() {})).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      expect(send(prop(), ['<end>']).beforeEnd(function() {
        return 42;
      })).toEmit([
        {
          current: 42
        }, '<end:current>'
      ]);
      return expect(send(prop(), [1, '<end>']).beforeEnd(function() {
        return 42;
      })).toEmit([
        {
          current: 42
        }, '<end:current>'
      ]);
    });
    it('should handle events and current', function() {
      var a;
      a = send(prop(), [1]);
      return expect(a.beforeEnd(function() {
        return 42;
      })).toEmit([
        {
          current: 1
        }, 2, 3, 42, '<end>'
      ], function() {
        return send(a, [2, 3, '<end>']);
      });
    });
    return it('errors should flow', function() {
      var a;
      a = prop();
      return expect(a.beforeEnd(function() {})).errorsToFlow(a);
    });
  });
});


},{"../test-helpers.coffee":249}],179:[function(require,module,exports){
var Kefir, activate, deactivate, prop, ref, send, stream;

ref = require('../test-helpers.coffee'), stream = ref.stream, prop = ref.prop, send = ref.send, Kefir = ref.Kefir, deactivate = ref.deactivate, activate = ref.activate;

describe('bufferBy', function() {
  describe('common', function() {
    it('should activate/deactivate sources', function() {
      var a, b;
      a = stream();
      b = stream();
      expect(a.bufferBy(b)).toActivate(a, b);
      a = stream();
      b = prop();
      expect(a.bufferBy(b)).toActivate(a, b);
      a = prop();
      b = stream();
      expect(a.bufferBy(b)).toActivate(a, b);
      a = prop();
      b = prop();
      return expect(a.bufferBy(b)).toActivate(a, b);
    });
    it('should end when primary ends', function() {
      var a, b;
      expect(send(stream(), ['<end>']).bufferBy(stream())).toEmit([
        {
          current: []
        }, '<end:current>'
      ]);
      a = stream();
      b = stream();
      return expect(a.bufferBy(b)).toEmit([[], '<end>'], function() {
        return send(a, ['<end>']);
      });
    });
    it('should flush buffer on end', function() {
      var a, b;
      expect(send(prop(), [1, '<end>']).bufferBy(stream())).toEmit([
        {
          current: [1]
        }, '<end:current>'
      ]);
      a = stream();
      b = stream();
      return expect(a.bufferBy(b)).toEmit([[1, 2], '<end>'], function() {
        return send(a, [1, 2, '<end>']);
      });
    });
    it('should not flush buffer on end if {flushOnEnd: false}', function() {
      var a, b;
      expect(send(prop(), [1, '<end>']).bufferBy(stream(), {
        flushOnEnd: false
      })).toEmit(['<end:current>']);
      a = stream();
      b = stream();
      return expect(a.bufferBy(b, {
        flushOnEnd: false
      })).toEmit(['<end>'], function() {
        return send(a, [1, 2, '<end>']);
      });
    });
    it('should not end when secondary ends', function() {
      var a, b;
      expect(stream().bufferBy(send(stream(), ['<end>']))).toEmit([]);
      a = stream();
      b = stream();
      return expect(a.bufferBy(b)).toEmit([], function() {
        return send(b, ['<end>']);
      });
    });
    it('should do end when secondary ends if {flushOnEnd: false}', function() {
      var a, b;
      expect(stream().bufferBy(send(stream(), ['<end>']), {
        flushOnEnd: false
      })).toEmit(['<end:current>']);
      a = stream();
      b = stream();
      return expect(a.bufferBy(b, {
        flushOnEnd: false
      })).toEmit(['<end>'], function() {
        return send(b, ['<end>']);
      });
    });
    it('should flush buffer on each value from secondary', function() {
      var a, b;
      a = stream();
      b = stream();
      return expect(a.bufferBy(b)).toEmit([[], [1, 2], [], [3]], function() {
        send(b, [0]);
        send(a, [1, 2]);
        send(b, [0]);
        send(b, [0]);
        send(a, [3]);
        send(b, [0]);
        return send(a, [4]);
      });
    });
    return it('errors should flow', function() {
      var a, b;
      a = stream();
      b = stream();
      expect(a.bufferBy(b)).errorsToFlow(a);
      a = stream();
      b = stream();
      expect(a.bufferBy(b)).errorsToFlow(b);
      a = prop();
      b = stream();
      expect(a.bufferBy(b)).errorsToFlow(a);
      a = prop();
      b = stream();
      expect(a.bufferBy(b)).errorsToFlow(b);
      a = stream();
      b = prop();
      expect(a.bufferBy(b)).errorsToFlow(a);
      a = stream();
      b = prop();
      expect(a.bufferBy(b)).errorsToFlow(b);
      a = prop();
      b = prop();
      expect(a.bufferBy(b)).errorsToFlow(a);
      a = prop();
      b = prop();
      return expect(a.bufferBy(b)).errorsToFlow(b);
    });
  });
  describe('stream + stream', function() {
    return it('returns stream', function() {
      return expect(stream().bufferBy(stream())).toBeStream();
    });
  });
  describe('stream + property', function() {
    return it('returns stream', function() {
      return expect(stream().bufferBy(prop())).toBeStream();
    });
  });
  describe('property + stream', function() {
    it('returns property', function() {
      return expect(prop().bufferBy(stream())).toBeProperty();
    });
    return it('includes current to buffer', function() {
      var a, b;
      a = send(prop(), [1]);
      b = stream();
      return expect(a.bufferBy(b)).toEmit([[1]], function() {
        return send(b, [0]);
      });
    });
  });
  return describe('property + property', function() {
    it('returns property', function() {
      return expect(prop().bufferBy(prop())).toBeProperty();
    });
    return it('both have current', function() {
      var a, b;
      a = send(prop(), [1]);
      b = send(prop(), [2]);
      return expect(a.bufferBy(b)).toEmit([
        {
          current: [1]
        }
      ]);
    });
  });
});


},{"../test-helpers.coffee":249}],180:[function(require,module,exports){
var Kefir, activate, deactivate, prop, ref, send, stream;

ref = require('../test-helpers.coffee'), stream = ref.stream, prop = ref.prop, send = ref.send, Kefir = ref.Kefir, deactivate = ref.deactivate, activate = ref.activate;

describe('bufferWhileBy', function() {
  describe('common', function() {
    it('should activate/deactivate sources', function() {
      var a, b;
      a = stream();
      b = stream();
      expect(a.bufferWhileBy(b)).toActivate(a, b);
      a = stream();
      b = prop();
      expect(a.bufferWhileBy(b)).toActivate(a, b);
      a = prop();
      b = stream();
      expect(a.bufferWhileBy(b)).toActivate(a, b);
      a = prop();
      b = prop();
      return expect(a.bufferWhileBy(b)).toActivate(a, b);
    });
    it('should flush empty buffer and then end when primary ends', function() {
      var a, b;
      expect(send(stream(), ['<end>']).bufferWhileBy(stream())).toEmit([
        {
          current: []
        }, '<end:current>'
      ]);
      a = stream();
      b = stream();
      return expect(a.bufferWhileBy(b)).toEmit([[], '<end>'], function() {
        return send(a, ['<end>']);
      });
    });
    it('should flush empty buffer when secondary emits false (w/ {flushOnChange: true})', function() {
      var a, b;
      expect(stream().bufferWhileBy(send(prop(), [false]), {
        flushOnChange: true
      })).toEmit([
        {
          current: []
        }
      ]);
      a = stream();
      b = stream();
      return expect(a.bufferWhileBy(b, {
        flushOnChange: true
      })).toEmit([[]], function() {
        return send(b, [true, false]);
      });
    });
    it('should flush buffer on end', function() {
      var a, b;
      expect(send(prop(), [1, '<end>']).bufferWhileBy(stream())).toEmit([
        {
          current: [1]
        }, '<end:current>'
      ]);
      a = stream();
      b = stream();
      return expect(a.bufferWhileBy(b)).toEmit([[1, 2], '<end>'], function() {
        return send(a, [1, 2, '<end>']);
      });
    });
    it('should not flush buffer on end if {flushOnEnd: false}', function() {
      var a, b;
      expect(send(prop(), [1, '<end>']).bufferWhileBy(stream(), {
        flushOnEnd: false
      })).toEmit(['<end:current>']);
      a = stream();
      b = stream();
      return expect(a.bufferWhileBy(b, {
        flushOnEnd: false
      })).toEmit(['<end>'], function() {
        return send(a, [1, 2, '<end>']);
      });
    });
    it('should end when secondary ends, if it haven\'t emitted any value (w/ {flushOnEnd: false})', function() {
      var a, b;
      expect(stream().bufferWhileBy(send(stream(), ['<end>']), {
        flushOnEnd: false
      })).toEmit(['<end:current>']);
      a = stream();
      b = stream();
      return expect(a.bufferWhileBy(b, {
        flushOnEnd: false
      })).toEmit(['<end>'], function() {
        return send(b, ['<end>']);
      });
    });
    it('should end when secondary ends, if its last emitted value was truthy (w/ {flushOnEnd: false})', function() {
      var a, b;
      expect(stream().bufferWhileBy(send(prop(), [true, '<end>']), {
        flushOnEnd: false
      })).toEmit(['<end:current>']);
      a = stream();
      b = stream();
      return expect(a.bufferWhileBy(b, {
        flushOnEnd: false
      })).toEmit(['<end>'], function() {
        return send(b, [true, '<end>']);
      });
    });
    it('should not end when secondary ends, if its last emitted value was falsy (w/ {flushOnEnd: false})', function() {
      var a, b;
      expect(stream().bufferWhileBy(send(prop(), [false, '<end>']), {
        flushOnEnd: false
      })).toEmit([]);
      a = stream();
      b = stream();
      return expect(a.bufferWhileBy(b, {
        flushOnEnd: false
      })).toEmit([], function() {
        return send(b, [false, '<end>']);
      });
    });
    it('should not end when secondary ends (w/o {flushOnEnd: false})', function() {
      var a, b;
      expect(stream().bufferWhileBy(send(prop(), ['<end>']))).toEmit([]);
      a = stream();
      b = stream();
      expect(a.bufferWhileBy(b)).toEmit([], function() {
        return send(b, ['<end>']);
      });
      expect(stream().bufferWhileBy(send(prop(), [true, '<end>']))).toEmit([]);
      a = stream();
      b = stream();
      expect(a.bufferWhileBy(b)).toEmit([], function() {
        return send(b, [true, '<end>']);
      });
      expect(stream().bufferWhileBy(send(prop(), [false, '<end>']))).toEmit([]);
      a = stream();
      b = stream();
      return expect(a.bufferWhileBy(b)).toEmit([], function() {
        return send(b, [false, '<end>']);
      });
    });
    it('should flush buffer on each value from primary if last value form secondary was falsy', function() {
      var a, b;
      a = stream();
      b = stream();
      return expect(a.bufferWhileBy(b)).toEmit([[1, 2, 3, 4], [5], [6, 7, 8]], function() {
        send(a, [1, 2]);
        send(b, [true]);
        send(a, [3]);
        send(b, [false]);
        send(a, [4]);
        send(a, [5]);
        send(b, [true]);
        send(a, [6, 7]);
        send(b, [false]);
        return send(a, [8]);
      });
    });
    it('errors should flow', function() {
      var a, b;
      a = stream();
      b = stream();
      expect(a.bufferWhileBy(b)).errorsToFlow(a);
      a = stream();
      b = stream();
      expect(a.bufferWhileBy(b)).errorsToFlow(b);
      a = prop();
      b = stream();
      expect(a.bufferWhileBy(b)).errorsToFlow(a);
      a = prop();
      b = stream();
      expect(a.bufferWhileBy(b)).errorsToFlow(b);
      a = stream();
      b = prop();
      expect(a.bufferWhileBy(b)).errorsToFlow(a);
      a = stream();
      b = prop();
      expect(a.bufferWhileBy(b)).errorsToFlow(b);
      a = prop();
      b = prop();
      expect(a.bufferWhileBy(b)).errorsToFlow(a);
      a = prop();
      b = prop();
      return expect(a.bufferWhileBy(b)).errorsToFlow(b);
    });
    return it('should flush on change if {flushOnChange === true}', function() {
      var a, b;
      a = stream();
      b = stream();
      return expect(a.bufferWhileBy(b, {
        flushOnChange: true
      })).toEmit([[1, 2, 3]], function() {
        send(a, [1, 2]);
        send(b, [true]);
        send(a, [3]);
        return send(b, [false]);
      });
    });
  });
  describe('stream + stream', function() {
    return it('returns stream', function() {
      return expect(stream().bufferWhileBy(stream())).toBeStream();
    });
  });
  describe('stream + property', function() {
    return it('returns stream', function() {
      return expect(stream().bufferWhileBy(prop())).toBeStream();
    });
  });
  describe('property + stream', function() {
    it('returns property', function() {
      return expect(prop().bufferWhileBy(stream())).toBeProperty();
    });
    return it('includes current to buffer', function() {
      var a, b;
      a = send(prop(), [1]);
      b = stream();
      return expect(a.bufferWhileBy(b)).toEmit([[1, 2]], function() {
        send(b, [false]);
        return send(a, [2]);
      });
    });
  });
  return describe('property + property', function() {
    it('returns property', function() {
      return expect(prop().bufferWhileBy(prop())).toBeProperty();
    });
    return it('both have current', function() {
      var a, b;
      a = send(prop(), [1]);
      b = send(prop(), [false]);
      expect(a.bufferWhileBy(b)).toEmit([
        {
          current: [1]
        }
      ]);
      a = send(prop(), [1]);
      b = send(prop(), [true]);
      return expect(a.bufferWhileBy(b)).toEmit([]);
    });
  });
});


},{"../test-helpers.coffee":249}],181:[function(require,module,exports){
var Kefir, not3, prop, ref, send, stream;

ref = require('../test-helpers.coffee'), stream = ref.stream, prop = ref.prop, send = ref.send, Kefir = ref.Kefir;

not3 = function(x) {
  return x !== 3;
};

describe('bufferWhile', function() {
  describe('stream', function() {
    it('should return stream', function() {
      return expect(stream().bufferWhile(not3)).toBeStream();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = stream();
      return expect(a.bufferWhile(not3)).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(stream(), ['<end>']).bufferWhile(not3)).toEmit(['<end:current>']);
    });
    it('should work correctly', function() {
      var a;
      a = stream();
      return expect(a.bufferWhile(not3)).toEmit([[3], [1, 2, 3], [4, 3], [3], [5, 6], '<end>'], function() {
        return send(a, [3, 1, 2, 3, 4, 3, 3, 5, 6, '<end>']);
      });
    });
    it('should not flush buffer on end if {flushOnEnd: false}', function() {
      var a;
      a = stream();
      return expect(a.bufferWhile(not3, {
        flushOnEnd: false
      })).toEmit([[3], [1, 2, 3], [4, 3], [3], '<end>'], function() {
        return send(a, [3, 1, 2, 3, 4, 3, 3, 5, 6, '<end>']);
      });
    });
    return it('errors should flow', function() {
      var a;
      a = stream();
      return expect(a.bufferWhile(not3)).errorsToFlow(a);
    });
  });
  return describe('property', function() {
    it('should return property', function() {
      return expect(prop().bufferWhile(not3)).toBeProperty();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = prop();
      return expect(a.bufferWhile(not3)).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      expect(send(prop(), ['<end>']).bufferWhile(not3)).toEmit(['<end:current>']);
      expect(send(prop(), [3, '<end>']).bufferWhile(not3)).toEmit([
        {
          current: [3]
        }, '<end:current>'
      ]);
      expect(send(prop(), [2, '<end>']).bufferWhile(not3)).toEmit([
        {
          current: [2]
        }, '<end:current>'
      ]);
      expect(send(prop(), [3, '<end>']).bufferWhile(not3, {
        flushOnEnd: false
      })).toEmit([
        {
          current: [3]
        }, '<end:current>'
      ]);
      return expect(send(prop(), [2, '<end>']).bufferWhile(not3, {
        flushOnEnd: false
      })).toEmit(['<end:current>']);
    });
    it('should work correctly', function() {
      var a;
      a = send(prop(), [3]);
      expect(a.bufferWhile(not3)).toEmit([
        {
          current: [3]
        }, [1, 2, 3], [4, 3], [3], [5, 6], '<end>'
      ], function() {
        return send(a, [1, 2, 3, 4, 3, 3, 5, 6, '<end>']);
      });
      a = send(prop(), [1]);
      return expect(a.bufferWhile(not3)).toEmit([[1, 2, 3], [5, 6], '<end>'], function() {
        return send(a, [2, 3, 5, 6, '<end>']);
      });
    });
    return it('errors should flow', function() {
      var a;
      a = prop();
      return expect(a.bufferWhile(not3)).errorsToFlow(a);
    });
  });
});


},{"../test-helpers.coffee":249}],182:[function(require,module,exports){
var Kefir, prop, ref, send, stream;

ref = require('../test-helpers.coffee'), stream = ref.stream, prop = ref.prop, send = ref.send, Kefir = ref.Kefir;

describe('bufferWithCount', function() {
  describe('stream', function() {
    it('should return stream', function() {
      return expect(stream().bufferWithCount(1)).toBeStream();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = stream();
      return expect(a.bufferWithCount(1)).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(stream(), ['<end>']).bufferWithCount(1)).toEmit(['<end:current>']);
    });
    it('.bufferWithCount(1) should work correctly', function() {
      var a;
      a = stream();
      return expect(a.bufferWithCount(1)).toEmit([[1], [2], [3], [4], [5], '<end>'], function() {
        return send(a, [1, 2, 3, 4, 5, '<end>']);
      });
    });
    it('.bufferWithCount(2) should work correctly', function() {
      var a;
      a = stream();
      return expect(a.bufferWithCount(2)).toEmit([[1, 2], [3, 4], [5], '<end>'], function() {
        return send(a, [1, 2, 3, 4, 5, '<end>']);
      });
    });
    it('.bufferWithCount(3) should work correctly', function() {
      var a;
      a = stream();
      return expect(a.bufferWithCount(3)).toEmit([[1, 2, 3], [4, 5], '<end>'], function() {
        return send(a, [1, 2, 3, 4, 5, '<end>']);
      });
    });
    it('should not flush buffer on end if {flushOnEnd: false}', function() {
      var a;
      a = stream();
      return expect(a.bufferWithCount(3, {
        flushOnEnd: false
      })).toEmit([[1, 2, 3], '<end>'], function() {
        return send(a, [1, 2, 3, 4, 5, '<end>']);
      });
    });
    return it('errors should flow', function() {
      var a;
      a = stream();
      return expect(a.bufferWithCount(3)).errorsToFlow(a);
    });
  });
  return describe('property', function() {
    it('should return property', function() {
      return expect(prop().bufferWithCount(1)).toBeProperty();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = prop();
      return expect(a.bufferWithCount(1)).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(prop(), ['<end>']).bufferWithCount(1)).toEmit(['<end:current>']);
    });
    it('.bufferWithCount(1) should work correctly', function() {
      var a;
      a = send(prop(), [1]);
      return expect(a.bufferWithCount(1)).toEmit([
        {
          current: [1]
        }, [2], [3], [4], [5], '<end>'
      ], function() {
        return send(a, [2, 3, 4, 5, '<end>']);
      });
    });
    it('.bufferWithCount(2) should work correctly', function() {
      var a;
      a = send(prop(), [1]);
      return expect(a.bufferWithCount(2)).toEmit([[1, 2], [3, 4], [5], '<end>'], function() {
        return send(a, [2, 3, 4, 5, '<end>']);
      });
    });
    it('.bufferWithCount(3) should work correctly', function() {
      var a;
      a = send(prop(), [1]);
      return expect(a.bufferWithCount(3)).toEmit([[1, 2, 3], [4, 5], '<end>'], function() {
        return send(a, [2, 3, 4, 5, '<end>']);
      });
    });
    it('should not flush buffer on end if {flushOnEnd: false}', function() {
      var a;
      a = send(prop(), [1]);
      return expect(a.bufferWithCount(3, {
        flushOnEnd: false
      })).toEmit([[1, 2, 3], '<end>'], function() {
        return send(a, [2, 3, 4, 5, '<end>']);
      });
    });
    return it('errors should flow', function() {
      var a;
      a = prop();
      return expect(a.bufferWithCount(3)).errorsToFlow(a);
    });
  });
});


},{"../test-helpers.coffee":249}],183:[function(require,module,exports){
var Kefir, cnt, intv, prop, ref, send, stream;

ref = require('../test-helpers.coffee'), stream = ref.stream, prop = ref.prop, send = ref.send, Kefir = ref.Kefir;

intv = 300;

cnt = 4;

describe('bufferWithTimeOrCount', function() {
  describe('stream', function() {
    it('should return stream', function() {
      return expect(stream().bufferWithTimeOrCount(intv, cnt)).toBeStream();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = stream();
      return expect(a.bufferWithTimeOrCount(intv, cnt)).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(stream(), ['<end>']).bufferWithTimeOrCount(intv, cnt)).toEmit(['<end:current>']);
    });
    it('should flush buffer when either interval or count is reached', function() {
      var a;
      a = stream();
      return expect(a.bufferWithTimeOrCount(intv, cnt)).toEmitInTime([[300, [1, 2, 3]], [500, [4, 5, 6, 7]], [800, []], [900, [8, 9]], [900, '<end>']], function(tick) {
        tick(100);
        send(a, [1]);
        tick(100);
        send(a, [2]);
        tick(99);
        send(a, [3]);
        tick(51);
        send(a, [4]);
        tick(50);
        send(a, [5]);
        tick(50);
        send(a, [6]);
        tick(50);
        send(a, [7]);
        tick(301);
        send(a, [8]);
        tick(99);
        return send(a, [9, '<end>']);
      });
    });
    it('should not flush buffer on end if {flushOnEnd: false}', function() {
      var a;
      a = stream();
      return expect(a.bufferWithTimeOrCount(intv, cnt, {
        flushOnEnd: false
      })).toEmitInTime([[300, [1, 2, 3]], [500, [4, 5, 6, 7]], [700, '<end>']], function(tick) {
        tick(100);
        send(a, [1]);
        tick(100);
        send(a, [2]);
        tick(99);
        send(a, [3]);
        tick(51);
        send(a, [4]);
        tick(50);
        send(a, [5]);
        tick(50);
        send(a, [6]);
        tick(50);
        send(a, [7]);
        tick(100);
        send(a, [8]);
        tick(100);
        return send(a, [9, '<end>']);
      });
    });
    return it('errors should flow', function() {
      var a;
      a = stream();
      return expect(a.bufferWithTimeOrCount(intv, cnt)).errorsToFlow(a);
    });
  });
  return describe('property', function() {
    it('should return property', function() {
      return expect(prop().bufferWithTimeOrCount(intv, cnt)).toBeProperty();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = prop();
      return expect(a.bufferWithTimeOrCount(intv, cnt)).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      expect(send(prop(), ['<end>']).bufferWithTimeOrCount(intv, cnt)).toEmit(['<end:current>']);
      expect(send(prop(), [1, '<end>']).bufferWithTimeOrCount(intv, cnt)).toEmit([
        {
          current: [1]
        }, '<end:current>'
      ]);
      return expect(send(prop(), [1, '<end>']).bufferWithTimeOrCount(intv, cnt, {
        flushOnEnd: false
      })).toEmit(['<end:current>']);
    });
    it('should flush buffer when either interval or count is reached', function() {
      var a;
      a = send(prop(), [0]);
      return expect(a.bufferWithTimeOrCount(intv, cnt)).toEmitInTime([[300, [0, 1, 2]], [500, [3, 4, 5, 6]], [800, []], [900, [7, 8]], [900, '<end>']], function(tick) {
        tick(100);
        send(a, [1]);
        tick(100);
        send(a, [2]);
        tick(150);
        send(a, [3]);
        tick(50);
        send(a, [4]);
        tick(50);
        send(a, [5]);
        tick(50);
        send(a, [6]);
        tick(301);
        send(a, [7]);
        tick(99);
        return send(a, [8, '<end>']);
      });
    });
    it('should not flush buffer on end if {flushOnEnd: false}', function() {
      var a;
      a = send(prop(), [0]);
      return expect(a.bufferWithTimeOrCount(intv, cnt, {
        flushOnEnd: false
      })).toEmitInTime([[300, [0, 1, 2]], [500, [3, 4, 5, 6]], [700, '<end>']], function(tick) {
        tick(100);
        send(a, [1]);
        tick(100);
        send(a, [2]);
        tick(150);
        send(a, [3]);
        tick(50);
        send(a, [4]);
        tick(50);
        send(a, [5]);
        tick(50);
        send(a, [6]);
        tick(100);
        send(a, [7]);
        tick(100);
        return send(a, [8, '<end>']);
      });
    });
    return it('errors should flow', function() {
      var a;
      a = prop();
      return expect(a.bufferWithTimeOrCount(intv, cnt)).errorsToFlow(a);
    });
  });
});


},{"../test-helpers.coffee":249}],184:[function(require,module,exports){
var Kefir, prop, ref, send, stream, streamWithCurrent;

ref = require('../test-helpers.coffee'), stream = ref.stream, prop = ref.prop, send = ref.send, Kefir = ref.Kefir;

streamWithCurrent = function(event) {
  return Kefir.stream(function(emitter) {
    return emitter.emitEvent(event);
  });
};

describe('changes', function() {
  describe('stream', function() {
    it('should return stream', function() {
      return expect(stream().changes()).toBeStream();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = stream();
      return expect(a.changes()).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(stream(), ['<end>']).changes()).toEmit(['<end:current>']);
    });
    it('test `streamWithCurrent` helper', function() {
      expect(streamWithCurrent({
        type: 'value',
        value: 1
      })).toEmit([
        {
          current: 1
        }
      ]);
      return expect(streamWithCurrent({
        type: 'error',
        value: 1
      })).toEmit([
        {
          currentError: 1
        }
      ]);
    });
    return it('should handle events and current', function() {
      var a;
      a = streamWithCurrent({
        type: 'value',
        value: 1
      });
      expect(a.changes()).toEmit([
        2, {
          error: 5
        }, 3, '<end>'
      ], function() {
        return send(a, [
          2, {
            error: 5
          }, 3, '<end>'
        ]);
      });
      a = streamWithCurrent({
        type: 'error',
        value: 1
      });
      return expect(a.changes()).toEmit([
        2, {
          error: 5
        }, 3, '<end>'
      ], function() {
        return send(a, [
          2, {
            error: 5
          }, 3, '<end>'
        ]);
      });
    });
  });
  return describe('property', function() {
    it('should return stream', function() {
      return expect(prop().changes()).toBeStream();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = prop();
      return expect(a.changes()).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(prop(), ['<end>']).changes()).toEmit(['<end:current>']);
    });
    return it('should handle events and current', function() {
      var a;
      a = send(prop(), [
        1, {
          error: 4
        }
      ]);
      return expect(a.changes()).toEmit([
        2, {
          error: 5
        }, 3, '<end>'
      ], function() {
        return send(a, [
          2, {
            error: 5
          }, 3, '<end>'
        ]);
      });
    });
  });
});


},{"../test-helpers.coffee":249}],185:[function(require,module,exports){
var Kefir, activate, deactivate, prop, ref, send, stream,
  slice = [].slice;

ref = require('../test-helpers.coffee'), stream = ref.stream, prop = ref.prop, send = ref.send, activate = ref.activate, deactivate = ref.deactivate, Kefir = ref.Kefir;

describe('combine', function() {
  it('should return stream', function() {
    expect(Kefir.combine([])).toBeStream();
    expect(Kefir.combine([stream(), prop()])).toBeStream();
    expect(stream().combine(stream())).toBeStream();
    return expect(prop().combine(prop())).toBeStream();
  });
  it('should be ended if empty array provided', function() {
    return expect(Kefir.combine([])).toEmit(['<end:current>']);
  });
  it('should be ended if array of ended observables provided', function() {
    var a, b, c;
    a = send(stream(), ['<end>']);
    b = send(prop(), ['<end>']);
    c = send(stream(), ['<end>']);
    expect(Kefir.combine([a, b, c])).toEmit(['<end:current>']);
    return expect(a.combine(b)).toEmit(['<end:current>']);
  });
  it('should be ended and has current if array of ended properties provided and each of them has current', function() {
    var a, b, c;
    a = send(prop(), [1, '<end>']);
    b = send(prop(), [2, '<end>']);
    c = send(prop(), [3, '<end>']);
    expect(Kefir.combine([a, b, c])).toEmit([
      {
        current: [1, 2, 3]
      }, '<end:current>'
    ]);
    return expect(a.combine(b)).toEmit([
      {
        current: [1, 2]
      }, '<end:current>'
    ]);
  });
  it('should activate sources', function() {
    var a, b, c;
    a = stream();
    b = prop();
    c = stream();
    expect(Kefir.combine([a, b, c])).toActivate(a, b, c);
    return expect(a.combine(b)).toActivate(a, b);
  });
  it('should handle events and current from observables', function() {
    var a, b, c;
    a = stream();
    b = send(prop(), [0]);
    c = stream();
    expect(Kefir.combine([a, b, c])).toEmit([[1, 0, 2], [1, 3, 2], [1, 4, 2], [1, 4, 5], [1, 4, 6], '<end>'], function() {
      send(a, [1]);
      send(c, [2]);
      send(b, [3]);
      send(a, ['<end>']);
      send(b, [4, '<end>']);
      return send(c, [5, 6, '<end>']);
    });
    a = stream();
    b = send(prop(), [0]);
    return expect(a.combine(b)).toEmit([[1, 0], [1, 2], [1, 3], '<end>'], function() {
      send(a, [1]);
      send(b, [2]);
      send(a, ['<end>']);
      return send(b, [3, '<end>']);
    });
  });
  it('should accept optional combinator function', function() {
    var a, b, c, join;
    a = stream();
    b = send(prop(), [0]);
    c = stream();
    join = function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return args.join('+');
    };
    expect(Kefir.combine([a, b, c], join)).toEmit(['1+0+2', '1+3+2', '1+4+2', '1+4+5', '1+4+6', '<end>'], function() {
      send(a, [1]);
      send(c, [2]);
      send(b, [3]);
      send(a, ['<end>']);
      send(b, [4, '<end>']);
      return send(c, [5, 6, '<end>']);
    });
    a = stream();
    b = send(prop(), [0]);
    return expect(a.combine(b, join)).toEmit(['1+0', '1+2', '1+3', '<end>'], function() {
      send(a, [1]);
      send(b, [2]);
      send(a, ['<end>']);
      return send(b, [3, '<end>']);
    });
  });
  it('when activating second time and has 2+ properties in sources, should emit current value at most once', function() {
    var a, b, cb;
    a = send(prop(), [0]);
    b = send(prop(), [1]);
    cb = Kefir.combine([a, b]);
    activate(cb);
    deactivate(cb);
    return expect(cb).toEmit([
      {
        current: [0, 1]
      }
    ]);
  });
  it('errors should flow', function() {
    var a, b, c;
    a = stream();
    b = prop();
    c = stream();
    expect(Kefir.combine([a, b, c])).errorsToFlow(a);
    a = stream();
    b = prop();
    c = stream();
    expect(Kefir.combine([a, b, c])).errorsToFlow(b);
    a = stream();
    b = prop();
    c = stream();
    return expect(Kefir.combine([a, b, c])).errorsToFlow(c);
  });
  it('should handle errors correctly', function() {
    var a, b, c;
    a = stream();
    b = stream();
    c = stream();
    return expect(Kefir.combine([a, b, c])).toEmit([
      {
        error: -1
      }, {
        error: -1
      }, {
        error: -1
      }, [3, 1, 2], {
        error: -2
      }, {
        error: -3
      }, {
        error: -3
      }, {
        error: -2
      }, [4, 6, 5]
    ], function() {
      send(a, [
        {
          error: -1
        }
      ]);
      send(b, [1]);
      send(c, [2]);
      send(a, [3]);
      send(b, [
        {
          error: -2
        }
      ]);
      send(c, [
        {
          error: -3
        }
      ]);
      send(a, [4]);
      send(c, [5]);
      return send(b, [6]);
    });
  });
  return describe('sampledBy functionality (3 arity combine)', function() {
    it('should return stream', function() {
      expect(Kefir.combine([], [])).toBeStream();
      return expect(Kefir.combine([stream(), prop()], [stream(), prop()])).toBeStream();
    });
    it('should be ended if empty array provided', function() {
      expect(Kefir.combine([stream(), prop()], [])).toEmit([]);
      return expect(Kefir.combine([], [stream(), prop()])).toEmit(['<end:current>']);
    });
    it('should be ended if array of ended observables provided', function() {
      var a, b, c;
      a = send(stream(), ['<end>']);
      b = send(prop(), ['<end>']);
      c = send(stream(), ['<end>']);
      return expect(Kefir.combine([a, b, c], [stream(), prop()])).toEmit(['<end:current>']);
    });
    it('should be ended and emmit current (once) if array of ended properties provided and each of them has current', function() {
      var a, b, c, s1;
      a = send(prop(), [1, '<end>']);
      b = send(prop(), [2, '<end>']);
      c = send(prop(), [3, '<end>']);
      s1 = Kefir.combine([a, b], [c]);
      expect(s1).toEmit([
        {
          current: [1, 2, 3]
        }, '<end:current>'
      ]);
      return expect(s1).toEmit(['<end:current>']);
    });
    it('should activate sources', function() {
      var a, b, c;
      a = stream();
      b = prop();
      c = stream();
      return expect(Kefir.combine([a, b], [c])).toActivate(a, b, c);
    });
    it('should handle events and current from observables', function() {
      var a, b, c, d;
      a = stream();
      b = send(prop(), [0]);
      c = stream();
      d = stream();
      return expect(Kefir.combine([c, d], [a, b])).toEmit([[2, 3, 1, 0], [5, 3, 1, 4], [6, 3, 1, 4], [6, 7, 1, 4], '<end>'], function() {
        send(a, [1]);
        send(c, [2]);
        send(d, [3]);
        send(b, [4, '<end>']);
        send(c, [5, 6, '<end>']);
        return send(d, [7, '<end>']);
      });
    });
    it('should accept optional combinator function', function() {
      var a, b, c, d, join;
      join = function() {
        var args;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        return args.join('+');
      };
      a = stream();
      b = send(prop(), [0]);
      c = stream();
      d = stream();
      return expect(Kefir.combine([c, d], [a, b], join)).toEmit(['2+3+1+0', '5+3+1+4', '6+3+1+4', '6+7+1+4', '<end>'], function() {
        send(a, [1]);
        send(c, [2]);
        send(d, [3]);
        send(b, [4, '<end>']);
        send(c, [5, 6, '<end>']);
        return send(d, [7, '<end>']);
      });
    });
    it('when activating second time and has 2+ properties in sources, should emit current value at most once', function() {
      var a, b, c, sb;
      a = send(prop(), [0]);
      b = send(prop(), [1]);
      c = send(prop(), [2]);
      sb = Kefir.combine([a, b], [c]);
      activate(sb);
      deactivate(sb);
      return expect(sb).toEmit([
        {
          current: [0, 1, 2]
        }
      ]);
    });
    it('errors should flow', function() {
      var a, b, c, d;
      a = stream();
      b = prop();
      c = stream();
      d = prop();
      expect(Kefir.combine([a, b], [c, d])).errorsToFlow(a);
      a = stream();
      b = prop();
      c = stream();
      d = prop();
      return expect(Kefir.combine([a, b], [c, d])).errorsToFlow(b);
    });
    return it('should work nice for emitating atomic updates', function() {
      var a, b, c;
      a = stream();
      b = a.map(function(x) {
        return x + 2;
      });
      c = a.map(function(x) {
        return x * 2;
      });
      return expect(Kefir.combine([b], [c])).toEmit([[3, 2], [4, 4], [5, 6]], function() {
        return send(a, [1, 2, 3]);
      });
    });
  });
});


},{"../test-helpers.coffee":249}],186:[function(require,module,exports){
var Kefir, activate, deactivate, prop, ref, send, stream;

ref = require('../test-helpers.coffee'), stream = ref.stream, prop = ref.prop, send = ref.send, activate = ref.activate, deactivate = ref.deactivate, Kefir = ref.Kefir;

describe('concat', function() {
  it('should return stream', function() {
    expect(Kefir.concat([])).toBeStream();
    expect(Kefir.concat([stream(), prop()])).toBeStream();
    expect(stream().concat(stream())).toBeStream();
    return expect(prop().concat(prop())).toBeStream();
  });
  it('should be ended if empty array provided', function() {
    return expect(Kefir.concat([])).toEmit(['<end:current>']);
  });
  it('should be ended if array of ended observables provided', function() {
    var a, b, c;
    a = send(stream(), ['<end>']);
    b = send(prop(), ['<end>']);
    c = send(stream(), ['<end>']);
    expect(Kefir.concat([a, b, c])).toEmit(['<end:current>']);
    return expect(a.concat(b)).toEmit(['<end:current>']);
  });
  it('should activate only current source', function() {
    var a, b, c;
    a = stream();
    b = prop();
    c = stream();
    expect(Kefir.concat([a, b, c])).toActivate(a);
    expect(Kefir.concat([a, b, c])).not.toActivate(b, c);
    expect(a.concat(b)).toActivate(a);
    expect(a.concat(b)).not.toActivate(b);
    send(a, ['<end>']);
    expect(Kefir.concat([a, b, c])).toActivate(b);
    expect(Kefir.concat([a, b, c])).not.toActivate(a, c);
    expect(a.concat(b)).toActivate(b);
    return expect(a.concat(b)).not.toActivate(a);
  });
  it('should deliver events from observables, then end when all of them end', function() {
    var a, b, c;
    a = send(prop(), [0]);
    b = prop();
    c = stream();
    expect(Kefir.concat([a, b, c])).toEmit([
      {
        current: 0
      }, 1, 4, 2, 5, 7, 8, '<end>'
    ], function() {
      send(a, [1]);
      send(b, [2]);
      send(c, [3]);
      send(a, [4, '<end>']);
      send(b, [5]);
      send(c, [6]);
      send(b, ['<end>']);
      return send(c, [7, 8, '<end>']);
    });
    a = send(prop(), [0]);
    b = stream();
    return expect(a.concat(b)).toEmit([
      {
        current: 0
      }, 1, 3, 4, '<end>'
    ], function() {
      send(a, [1]);
      send(b, [2]);
      send(a, ['<end>']);
      return send(b, [3, 4, '<end>']);
    });
  });
  it('should deliver current from current source, but only to first subscriber on each activation', function() {
    var a, b, c, concat;
    a = send(prop(), [0]);
    b = send(prop(), [1]);
    c = stream();
    concat = Kefir.concat([a, b, c]);
    expect(concat).toEmit([
      {
        current: 0
      }
    ]);
    concat = Kefir.concat([a, b, c]);
    activate(concat);
    expect(concat).toEmit([]);
    concat = Kefir.concat([a, b, c]);
    activate(concat);
    deactivate(concat);
    return expect(concat).toEmit([
      {
        current: 0
      }
    ]);
  });
  it('if made of ended properties, should emit all currents then end', function() {
    return expect(Kefir.concat([send(prop(), [0, '<end>']), send(prop(), [1, '<end>']), send(prop(), [2, '<end>'])])).toEmit([
      {
        current: 0
      }, {
        current: 1
      }, {
        current: 2
      }, '<end:current>'
    ]);
  });
  return it('errors should flow', function() {
    var a, b, c, result;
    a = stream();
    b = prop();
    c = stream();
    expect(Kefir.concat([a, b, c])).errorsToFlow(a);
    a = send(stream(), ['<end>']);
    b = prop();
    c = stream();
    expect(Kefir.concat([a, b, c])).errorsToFlow(b);
    a = send(stream(), ['<end>']);
    b = prop();
    c = stream();
    result = Kefir.concat([a, b, c]);
    activate(result);
    send(b, ['<end>']);
    deactivate(result);
    return expect(result).errorsToFlow(c);
  });
});


},{"../test-helpers.coffee":249}],187:[function(require,module,exports){
var Kefir;

Kefir = require('../../dist/kefir');

describe('constantError', function() {
  it('should return property', function() {
    return expect(Kefir.constantError(1)).toBeProperty();
  });
  return it('should be ended and has a current error', function() {
    return expect(Kefir.constantError(1)).toEmit([
      {
        currentError: 1
      }, '<end:current>'
    ]);
  });
});


},{"../../dist/kefir":1}],188:[function(require,module,exports){
var Kefir;

Kefir = require('../../dist/kefir');

describe('constant', function() {
  it('should return property', function() {
    return expect(Kefir.constant(1)).toBeProperty();
  });
  return it('should be ended and has current', function() {
    return expect(Kefir.constant(1)).toEmit([
      {
        current: 1
      }, '<end:current>'
    ]);
  });
});


},{"../../dist/kefir":1}],189:[function(require,module,exports){
var Kefir, prop, ref, send, stream;

ref = require('../test-helpers.coffee'), stream = ref.stream, prop = ref.prop, send = ref.send, Kefir = ref.Kefir;

describe('debounce', function() {
  describe('stream', function() {
    it('should return stream', function() {
      return expect(stream().debounce(100)).toBeStream();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = stream();
      return expect(a.debounce(100)).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(stream(), ['<end>']).debounce(100)).toEmit(['<end:current>']);
    });
    it('should handle events', function() {
      var a;
      a = stream();
      return expect(a.debounce(100)).toEmitInTime([[160, 3], [360, 4], [710, 8], [710, '<end>']], function(tick) {
        send(a, [1]);
        tick(30);
        send(a, [2]);
        tick(30);
        send(a, [3]);
        tick(200);
        send(a, [4]);
        tick(200);
        send(a, [5]);
        tick(90);
        send(a, [6]);
        tick(30);
        send(a, [7]);
        tick(30);
        return send(a, [8, '<end>']);
      });
    });
    it('should end immediately if no value to emit later', function() {
      var a;
      a = stream();
      return expect(a.debounce(100)).toEmitInTime([[100, 1], [200, '<end>']], function(tick) {
        send(a, [1]);
        tick(200);
        return send(a, ['<end>']);
      });
    });
    it('should handle events (immediate)', function() {
      var a;
      a = stream();
      return expect(a.debounce(100, {
        immediate: true
      })).toEmitInTime([[0, 1], [260, 4], [460, 5], [610, '<end>']], function(tick) {
        send(a, [1]);
        tick(30);
        send(a, [2]);
        tick(30);
        send(a, [3]);
        tick(200);
        send(a, [4]);
        tick(200);
        send(a, [5]);
        tick(90);
        send(a, [6]);
        tick(30);
        send(a, [7]);
        tick(30);
        return send(a, [8, '<end>']);
      });
    });
    it('should end immediately if no value to emit later (immediate)', function() {
      var a;
      a = stream();
      return expect(a.debounce(100, {
        immediate: true
      })).toEmitInTime([[0, 1], [0, '<end>']], function(tick) {
        return send(a, [1, '<end>']);
      });
    });
    return it('errors should flow', function() {
      var a;
      a = stream();
      return expect(a.debounce(100)).errorsToFlow(a);
    });
  });
  return describe('property', function() {
    it('should return property', function() {
      return expect(prop().debounce(100)).toBeProperty();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = prop();
      return expect(a.debounce(100)).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(prop(), ['<end>']).debounce(100)).toEmit(['<end:current>']);
    });
    it('should be ended if source was ended (with current)', function() {
      return expect(send(prop(), [1, '<end>']).debounce(100)).toEmit([
        {
          current: 1
        }, '<end:current>'
      ]);
    });
    it('should handle events', function() {
      var a;
      a = send(prop(), [0]);
      return expect(a.debounce(100)).toEmitInTime([
        [
          0, {
            current: 0
          }
        ], [160, 3], [360, 4], [710, 8], [710, '<end>']
      ], function(tick) {
        send(a, [1]);
        tick(30);
        send(a, [2]);
        tick(30);
        send(a, [3]);
        tick(200);
        send(a, [4]);
        tick(200);
        send(a, [5]);
        tick(90);
        send(a, [6]);
        tick(30);
        send(a, [7]);
        tick(30);
        return send(a, [8, '<end>']);
      });
    });
    it('should end immediately if no value to emit later', function() {
      var a;
      a = send(prop(), [0]);
      return expect(a.debounce(100)).toEmitInTime([
        [
          0, {
            current: 0
          }
        ], [100, 1], [200, '<end>']
      ], function(tick) {
        send(a, [1]);
        tick(200);
        return send(a, ['<end>']);
      });
    });
    it('should handle events (immediate)', function() {
      var a;
      a = send(prop(), [0]);
      return expect(a.debounce(100, {
        immediate: true
      })).toEmitInTime([
        [
          0, {
            current: 0
          }
        ], [0, 1], [260, 4], [460, 5], [610, '<end>']
      ], function(tick) {
        send(a, [1]);
        tick(30);
        send(a, [2]);
        tick(30);
        send(a, [3]);
        tick(200);
        send(a, [4]);
        tick(200);
        send(a, [5]);
        tick(90);
        send(a, [6]);
        tick(30);
        send(a, [7]);
        tick(30);
        return send(a, [8, '<end>']);
      });
    });
    it('should end immediately if no value to emit later (immediate)', function() {
      var a;
      a = send(prop(), [0]);
      return expect(a.debounce(100, {
        immediate: true
      })).toEmitInTime([
        [
          0, {
            current: 0
          }
        ], [0, 1], [0, '<end>']
      ], function(tick) {
        return send(a, [1, '<end>']);
      });
    });
    return it('errors should flow', function() {
      var a;
      a = prop();
      return expect(a.debounce(100)).errorsToFlow(a);
    });
  });
});


},{"../test-helpers.coffee":249}],190:[function(require,module,exports){
var Kefir, prop, ref, send, shakyTimeTest, stream;

ref = require('../test-helpers.coffee'), stream = ref.stream, prop = ref.prop, send = ref.send, shakyTimeTest = ref.shakyTimeTest, Kefir = ref.Kefir;

describe('delay', function() {
  describe('stream', function() {
    it('should return stream', function() {
      return expect(stream().delay(100)).toBeStream();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = stream();
      return expect(a.delay(100)).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(stream(), ['<end>']).delay(100)).toEmit(['<end:current>']);
    });
    it('should handle events', function() {
      var a;
      a = stream();
      return expect(a.delay(100)).toEmitInTime([[100, 1], [150, 2], [250, '<end>']], function(tick) {
        send(a, [1]);
        tick(50);
        send(a, [2]);
        tick(100);
        return send(a, ['<end>']);
      });
    });
    it('errors should flow', function() {
      var a;
      a = stream();
      return expect(a.delay(100)).errorsToFlow(a);
    });
    return describe('works with undependable setTimeout', function() {
      return shakyTimeTest(function(expectToEmitOverShakyTime) {
        var a;
        a = stream();
        return expectToEmitOverShakyTime(a.delay(10), [[10, 1], [15, 4], [15, '<end>']], function(tick) {
          send(a, [1]);
          tick(5);
          send(a, [4]);
          return send(a, ['<end>']);
        });
      });
    });
  });
  return describe('property', function() {
    it('should return property', function() {
      return expect(prop().delay(100)).toBeProperty();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = prop();
      return expect(a.delay(100)).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(prop(), ['<end>']).delay(100)).toEmit(['<end:current>']);
    });
    it('should handle events and current', function() {
      var a;
      a = send(prop(), [1]);
      return expect(a.delay(100)).toEmitInTime([
        [
          0, {
            current: 1
          }
        ], [100, 2], [150, 3], [250, '<end>']
      ], function(tick) {
        send(a, [2]);
        tick(50);
        send(a, [3]);
        tick(100);
        return send(a, ['<end>']);
      });
    });
    return it('errors should flow', function() {
      var a;
      a = prop();
      return expect(a.delay(100)).errorsToFlow(a);
    });
  });
});


},{"../test-helpers.coffee":249}],191:[function(require,module,exports){
var Kefir, minus, noop, prop, ref, send, stream;

ref = require('../test-helpers.coffee'), stream = ref.stream, prop = ref.prop, send = ref.send, Kefir = ref.Kefir;

noop = function() {};

minus = function(prev, next) {
  return prev - next;
};

describe('diff', function() {
  describe('stream', function() {
    it('should return stream', function() {
      return expect(stream().diff(noop, 0)).toBeStream();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = stream();
      return expect(a.diff(noop, 0)).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(stream(), ['<end>']).diff(noop, 0)).toEmit(['<end:current>']);
    });
    it('should handle events', function() {
      var a;
      a = stream();
      return expect(a.diff(minus, 0)).toEmit([-1, -2, '<end>'], function() {
        return send(a, [1, 3, '<end>']);
      });
    });
    it('works without fn argument', function() {
      var a;
      a = stream();
      return expect(a.diff(null, 0)).toEmit([[0, 1], [1, 3], '<end>'], function() {
        return send(a, [1, 3, '<end>']);
      });
    });
    it('if no seed provided uses first value as seed', function() {
      var a;
      a = stream();
      expect(a.diff(minus)).toEmit([-1, -2, '<end>'], function() {
        return send(a, [0, 1, 3, '<end>']);
      });
      a = stream();
      return expect(a.diff()).toEmit([[0, 1], [1, 3], '<end>'], function() {
        return send(a, [0, 1, 3, '<end>']);
      });
    });
    return it('errors should flow', function() {
      var a;
      a = stream();
      return expect(a.diff()).errorsToFlow(a);
    });
  });
  return describe('property', function() {
    it('should return property', function() {
      return expect(prop().diff(noop, 0)).toBeProperty();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = prop();
      return expect(a.diff(noop, 0)).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(prop(), ['<end>']).diff(noop, 0)).toEmit(['<end:current>']);
    });
    it('should handle events and current', function() {
      var a;
      a = send(prop(), [1]);
      return expect(a.diff(minus, 0)).toEmit([
        {
          current: -1
        }, -2, -3, '<end>'
      ], function() {
        return send(a, [3, 6, '<end>']);
      });
    });
    it('works without fn argument', function() {
      var a;
      a = send(prop(), [1]);
      return expect(a.diff(null, 0)).toEmit([
        {
          current: [0, 1]
        }, [1, 3], [3, 6], '<end>'
      ], function() {
        return send(a, [3, 6, '<end>']);
      });
    });
    it('if no seed provided uses first value as seed', function() {
      var a;
      a = send(prop(), [0]);
      expect(a.diff(minus)).toEmit([-1, -2, '<end>'], function() {
        return send(a, [1, 3, '<end>']);
      });
      a = send(prop(), [0]);
      return expect(a.diff()).toEmit([[0, 1], [1, 3], '<end>'], function() {
        return send(a, [1, 3, '<end>']);
      });
    });
    return it('errors should flow', function() {
      var a;
      a = prop();
      return expect(a.diff()).errorsToFlow(a);
    });
  });
});


},{"../test-helpers.coffee":249}],192:[function(require,module,exports){
var Kefir, prop, ref, send, stream;

ref = require('../test-helpers.coffee'), stream = ref.stream, prop = ref.prop, send = ref.send, Kefir = ref.Kefir;

describe('endOnError', function() {
  describe('stream', function() {
    it('should return stream', function() {
      return expect(stream().endOnError()).toBeStream();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = stream();
      return expect(a.endOnError()).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(stream(), ['<end>']).endOnError()).toEmit(['<end:current>']);
    });
    return it('should handle events', function() {
      var a;
      a = stream();
      expect(a.endOnError()).toEmit([
        1, {
          error: 5
        }, '<end>'
      ], function() {
        return send(a, [
          1, {
            error: 5
          }, 2
        ]);
      });
      a = stream();
      return expect(a.endOnError()).toEmit([1, 2, '<end>'], function() {
        return send(a, [1, 2, '<end>']);
      });
    });
  });
  return describe('property', function() {
    it('should return property', function() {
      return expect(prop().endOnError()).toBeProperty();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = prop();
      return expect(a.endOnError()).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(prop(), ['<end>']).endOnError()).toEmit(['<end:current>']);
    });
    it('should handle events and current', function() {
      var a;
      a = send(prop(), [1]);
      expect(a.endOnError()).toEmit([
        {
          current: 1
        }, {
          error: 5
        }, '<end>'
      ], function() {
        return send(a, [
          {
            error: 5
          }, 2
        ]);
      });
      a = send(prop(), [1]);
      return expect(a.endOnError()).toEmit([
        {
          current: 1
        }, 2, '<end>'
      ], function() {
        return send(a, [2, '<end>']);
      });
    });
    return it('should handle currents', function() {
      var a;
      a = send(prop(), [
        {
          error: -1
        }
      ]);
      expect(a.endOnError()).toEmit([
        {
          currentError: -1
        }, '<end:current>'
      ]);
      a = send(prop(), [
        {
          error: -1
        }, '<end>'
      ]);
      expect(a.endOnError()).toEmit([
        {
          currentError: -1
        }, '<end:current>'
      ]);
      a = send(prop(), [1]);
      expect(a.endOnError()).toEmit([
        {
          current: 1
        }
      ]);
      a = send(prop(), [1, '<end>']);
      return expect(a.endOnError()).toEmit([
        {
          current: 1
        }, '<end:current>'
      ]);
    });
  });
});


},{"../test-helpers.coffee":249}],193:[function(require,module,exports){
var Kefir, handler, prop, ref, send, stream;

ref = require('../test-helpers.coffee'), stream = ref.stream, prop = ref.prop, send = ref.send, Kefir = ref.Kefir;

handler = function(x) {
  return {
    convert: x >= 0,
    value: x * 3
  };
};

describe('errorsToValues', function() {
  describe('stream', function() {
    it('should return stream', function() {
      return expect(stream().errorsToValues(function() {})).toBeStream();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = stream();
      return expect(a.errorsToValues(function() {})).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(stream(), ['<end>']).errorsToValues(function() {})).toEmit(['<end:current>']);
    });
    it('should handle events', function() {
      var a;
      a = stream();
      return expect(a.errorsToValues(handler)).toEmit([
        1, 6, {
          error: -1
        }, 9, 4, '<end>'
      ], function() {
        return send(a, [
          1, {
            error: 2
          }, {
            error: -1
          }, {
            error: 3
          }, 4, '<end>'
        ]);
      });
    });
    return it('default handler should convert all errors', function() {
      var a;
      a = stream();
      return expect(a.errorsToValues()).toEmit([1, 2, -1, 3, 4, '<end>'], function() {
        return send(a, [
          1, {
            error: 2
          }, {
            error: -1
          }, {
            error: 3
          }, 4, '<end>'
        ]);
      });
    });
  });
  return describe('property', function() {
    it('should return property', function() {
      return expect(prop().errorsToValues(function() {})).toBeProperty();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = prop();
      return expect(a.errorsToValues(function() {})).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(prop(), ['<end>']).errorsToValues(function() {})).toEmit(['<end:current>']);
    });
    it('should handle events', function() {
      var a;
      a = send(prop(), [1]);
      return expect(a.errorsToValues(handler)).toEmit([
        {
          current: 1
        }, 6, {
          error: -1
        }, 9, 4, '<end>'
      ], function() {
        return send(a, [
          {
            error: 2
          }, {
            error: -1
          }, {
            error: 3
          }, 4, '<end>'
        ]);
      });
    });
    return it('should handle currents', function() {
      var a;
      a = send(prop(), [
        {
          error: -2
        }
      ]);
      expect(a.errorsToValues(handler)).toEmit([
        {
          currentError: -2
        }
      ]);
      a = send(prop(), [
        {
          error: 2
        }
      ]);
      expect(a.errorsToValues(handler)).toEmit([
        {
          current: 6
        }
      ]);
      a = send(prop(), [1]);
      return expect(a.errorsToValues(handler)).toEmit([
        {
          current: 1
        }
      ]);
    });
  });
});


},{"../test-helpers.coffee":249}],194:[function(require,module,exports){
var $$observable, Kefir, Observable, prop, ref, send, stream;

$$observable = require('symbol-observable')["default"];

Observable = require('zen-observable');

ref = require('../test-helpers.coffee'), stream = ref.stream, prop = ref.prop, send = ref.send, Kefir = ref.Kefir;

describe('[Symbol.observable]', function() {
  it('outputs a compatible Observable', function(done) {
    var a, observable, values;
    a = stream();
    values = [];
    observable = Observable.from(a);
    observable.subscribe({
      next: function(x) {
        return values.push(x);
      },
      complete: function(x) {
        expect(values).toEqual([1, 2, 3]);
        return done();
      }
    });
    return send(a, [1, 2, 3, '<end>']);
  });
  it('unsubscribes stream after an error', function() {
    var a, observable, values;
    a = stream();
    values = [];
    observable = a[$$observable]();
    observable.subscribe({
      next: function(x) {
        return values.push(x);
      }
    });
    send(a, [
      1, {
        error: 2
      }, 3
    ]);
    return expect(values).toEqual([1]);
  });
  it('subscribe() returns an subscribtion object with unsubscribe method', function() {
    var a, observable, subscribtion, values;
    a = stream();
    values = [];
    observable = a[$$observable]();
    subscribtion = observable.subscribe({
      next: function(x) {
        return values.push(x);
      }
    });
    send(a, [1]);
    subscribtion.unsubscribe();
    send(a, [2]);
    return expect(values).toEqual([1]);
  });
  it('subscribtion object has `closed` property', function() {
    var a, observable, subscribtion;
    a = stream();
    observable = a[$$observable]();
    subscribtion = observable.subscribe({
      next: function() {}
    });
    expect(subscribtion.closed).toEqual(false);
    subscribtion.unsubscribe();
    return expect(subscribtion.closed).toEqual(true);
  });
  it('supports subscribe(onNext, onError, onCompete) format', function() {
    var a, completes, errors, observable, onComplete, onError, onValue, values;
    a = stream();
    values = [];
    errors = [];
    completes = [];
    onValue = function(x) {
      return values.push(x);
    };
    onError = function(x) {
      return errors.push(x);
    };
    onComplete = function(x) {
      return completes.push(x);
    };
    observable = a[$$observable]();
    observable.subscribe(onValue, onError, onComplete);
    send(a, [
      1, {
        error: 2
      }
    ]);
    expect(values).toEqual([1]);
    expect(errors).toEqual([2]);
    return expect(completes).toEqual([void 0]);
  });
  return it('closed=true after end', function() {
    var a, observable, subscribtion;
    a = stream();
    observable = a[$$observable]();
    subscribtion = observable.subscribe(function() {});
    expect(subscribtion.closed).toEqual(false);
    send(a, ['<end>']);
    return expect(subscribtion.closed).toEqual(true);
  });
});


},{"../test-helpers.coffee":249,"symbol-observable":169,"zen-observable":176}],195:[function(require,module,exports){
var Kefir, prop, ref, send, stream;

ref = require('../test-helpers.coffee'), stream = ref.stream, prop = ref.prop, send = ref.send, Kefir = ref.Kefir;

describe('filterBy', function() {
  describe('common', function() {
    return it('errors should flow', function() {
      var a, b;
      a = stream();
      b = stream();
      expect(a.filterBy(b)).errorsToFlow(a);
      a = stream();
      b = stream();
      expect(a.filterBy(b)).errorsToFlow(b);
      a = prop();
      b = stream();
      expect(a.filterBy(b)).errorsToFlow(a);
      a = prop();
      b = stream();
      expect(a.filterBy(b)).errorsToFlow(b);
      a = stream();
      b = prop();
      expect(a.filterBy(b)).errorsToFlow(a);
      a = stream();
      b = prop();
      expect(a.filterBy(b)).errorsToFlow(b);
      a = prop();
      b = prop();
      expect(a.filterBy(b)).errorsToFlow(a);
      a = prop();
      b = prop();
      return expect(a.filterBy(b)).errorsToFlow(b);
    });
  });
  describe('stream, stream', function() {
    it('should return a stream', function() {
      return expect(stream().filterBy(stream())).toBeStream();
    });
    it('should activate/deactivate sources', function() {
      var a, b;
      a = stream();
      b = stream();
      return expect(a.filterBy(b)).toActivate(a, b);
    });
    it('should be ended if primary was ended', function() {
      return expect(send(stream(), ['<end>']).filterBy(stream())).toEmit(['<end:current>']);
    });
    it('should be ended if secondary was ended', function() {
      return expect(stream().filterBy(send(stream(), ['<end>']))).toEmit(['<end:current>']);
    });
    it('should end when secondary ends if last value from it was falsey', function() {
      var a, b;
      a = stream();
      b = stream();
      return expect(a.filterBy(b)).toEmit(['<end>'], function() {
        return send(b, [false, '<end>']);
      });
    });
    it('should not end when secondary ends if last value from it wasn\'t falsey', function() {
      var a, b;
      a = stream();
      b = stream();
      return expect(a.filterBy(b)).toEmit([], function() {
        return send(b, [true, '<end>']);
      });
    });
    it('should ignore values from primary until first value from secondary', function() {
      var a, b;
      a = stream();
      b = stream();
      return expect(a.filterBy(b)).toEmit([], function() {
        return send(a, [1, 2]);
      });
    });
    return it('should filter values as expected', function() {
      var a, b;
      a = stream();
      b = stream();
      return expect(a.filterBy(b)).toEmit([3, 4, 7, 8, '<end>'], function() {
        send(b, [true]);
        send(a, [3, 4]);
        send(b, [0]);
        send(a, [5, 6]);
        send(b, [1]);
        send(a, [7, 8]);
        send(b, [false]);
        return send(a, [9, '<end>']);
      });
    });
  });
  describe('stream, property', function() {
    it('should return a stream', function() {
      return expect(stream().filterBy(prop())).toBeStream();
    });
    it('should activate/deactivate sources', function() {
      var a, b;
      a = stream();
      b = prop();
      return expect(a.filterBy(b)).toActivate(a, b);
    });
    it('should be ended if primary was ended', function() {
      return expect(send(stream(), ['<end>']).filterBy(prop())).toEmit(['<end:current>']);
    });
    it('should be ended if secondary was ended and has no current', function() {
      return expect(stream().filterBy(send(prop(), ['<end>']))).toEmit(['<end:current>']);
    });
    it('should be ended if secondary was ended and has falsey current', function() {
      return expect(stream().filterBy(send(prop(), [false, '<end>']))).toEmit(['<end:current>']);
    });
    it('should not be ended if secondary was ended but has truthy current', function() {
      return expect(stream().filterBy(send(prop(), [true, '<end>']))).toEmit([]);
    });
    it('should end when secondary ends if last value from it was falsey', function() {
      var a, b;
      a = stream();
      b = prop();
      return expect(a.filterBy(b)).toEmit(['<end>'], function() {
        return send(b, [false, '<end>']);
      });
    });
    it('should not end when secondary ends if last value from it wasn\'t falsey', function() {
      var a, b;
      a = stream();
      b = prop();
      return expect(a.filterBy(b)).toEmit([], function() {
        return send(b, [true, '<end>']);
      });
    });
    it('should ignore values from primary until first value from secondary', function() {
      var a, b;
      a = stream();
      b = prop();
      return expect(a.filterBy(b)).toEmit([], function() {
        return send(a, [1, 2]);
      });
    });
    return it('should filter values as expected', function() {
      var a, b;
      a = stream();
      b = prop();
      return expect(a.filterBy(b)).toEmit([3, 4, 7, 8, '<end>'], function() {
        send(b, [true]);
        send(a, [3, 4]);
        send(b, [0]);
        send(a, [5, 6]);
        send(b, [1]);
        send(a, [7, 8]);
        send(b, [false]);
        return send(a, [9, '<end>']);
      });
    });
  });
  describe('property, stream', function() {
    it('should return a property', function() {
      return expect(prop().filterBy(stream())).toBeProperty();
    });
    it('should activate/deactivate sources', function() {
      var a, b;
      a = prop();
      b = stream();
      return expect(a.filterBy(b)).toActivate(a, b);
    });
    it('should be ended if primary was ended', function() {
      return expect(send(prop(), ['<end>']).filterBy(stream())).toEmit(['<end:current>']);
    });
    it('should be ended if secondary was ended', function() {
      return expect(prop().filterBy(send(stream(), ['<end>']))).toEmit(['<end:current>']);
    });
    it('should end when secondary ends if last value from it was falsey', function() {
      var a, b;
      a = prop();
      b = stream();
      return expect(a.filterBy(b)).toEmit(['<end>'], function() {
        return send(b, [false, '<end>']);
      });
    });
    it('should not end when secondary ends if last value from it wasn\'t falsey', function() {
      var a, b;
      a = prop();
      b = stream();
      return expect(a.filterBy(b)).toEmit([], function() {
        return send(b, [true, '<end>']);
      });
    });
    it('should ignore values from primary until first value from secondary', function() {
      var a, b;
      a = prop();
      b = stream();
      return expect(a.filterBy(b)).toEmit([], function() {
        return send(a, [1, 2]);
      });
    });
    return it('should filter values as expected', function() {
      var a, b;
      a = send(prop(), [0]);
      b = stream();
      return expect(a.filterBy(b)).toEmit([3, 4, 7, 8, '<end>'], function() {
        send(b, [true]);
        send(a, [3, 4]);
        send(b, [0]);
        send(a, [5, 6]);
        send(b, [1]);
        send(a, [7, 8]);
        send(b, [false]);
        return send(a, [9, '<end>']);
      });
    });
  });
  return describe('property, property', function() {
    it('should return a property', function() {
      return expect(prop().filterBy(prop())).toBeProperty();
    });
    it('should activate/deactivate sources', function() {
      var a, b;
      a = prop();
      b = prop();
      return expect(a.filterBy(b)).toActivate(a, b);
    });
    it('should be ended if primary was ended', function() {
      return expect(send(prop(), ['<end>']).filterBy(prop())).toEmit(['<end:current>']);
    });
    it('should be ended if secondary was ended and has no current', function() {
      return expect(prop().filterBy(send(prop(), ['<end>']))).toEmit(['<end:current>']);
    });
    it('should be ended if secondary was ended and has falsey current', function() {
      return expect(prop().filterBy(send(prop(), [false, '<end>']))).toEmit(['<end:current>']);
    });
    it('should not be ended if secondary was ended but has truthy current', function() {
      return expect(prop().filterBy(send(prop(), [true, '<end>']))).toEmit([]);
    });
    it('should end when secondary ends if last value from it was falsey', function() {
      var a, b;
      a = prop();
      b = prop();
      return expect(a.filterBy(b)).toEmit(['<end>'], function() {
        return send(b, [false, '<end>']);
      });
    });
    it('should not end when secondary ends if last value from it wasn\'t falsey', function() {
      var a, b;
      a = prop();
      b = prop();
      return expect(a.filterBy(b)).toEmit([], function() {
        return send(b, [true, '<end>']);
      });
    });
    it('should ignore values from primary until first value from secondary', function() {
      var a, b;
      a = prop();
      b = prop();
      return expect(a.filterBy(b)).toEmit([], function() {
        return send(a, [1, 2]);
      });
    });
    return it('should filter values as expected', function() {
      var a, b;
      a = send(prop(), [0]);
      b = send(prop(), [true]);
      return expect(a.filterBy(b)).toEmit([
        {
          current: 0
        }, 3, 4, 7, 8, '<end>'
      ], function() {
        send(a, [3, 4]);
        send(b, [0]);
        send(a, [5, 6]);
        send(b, [1]);
        send(a, [7, 8]);
        send(b, [false]);
        return send(a, [9, '<end>']);
      });
    });
  });
});


},{"../test-helpers.coffee":249}],196:[function(require,module,exports){
var Kefir, prop, ref, send, stream;

ref = require('../test-helpers.coffee'), stream = ref.stream, prop = ref.prop, send = ref.send, Kefir = ref.Kefir;

describe('filterErrors', function() {
  describe('stream', function() {
    it('should return stream', function() {
      return expect(stream().filterErrors(function() {})).toBeStream();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = stream();
      return expect(a.filterErrors(function() {})).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(stream(), ['<end>']).filterErrors(function() {})).toEmit(['<end:current>']);
    });
    it('should handle events', function() {
      var a;
      a = stream();
      return expect(a.filterErrors(function(x) {
        return x > 3;
      })).toEmit([
        -1, {
          error: 4
        }, -2, {
          error: 5
        }, {
          error: 6
        }, '<end>'
      ], function() {
        return send(a, [
          -1, {
            error: 1
          }, {
            error: 2
          }, {
            error: 3
          }, {
            error: 4
          }, -2, {
            error: 5
          }, {
            error: 0
          }, {
            error: 6
          }, '<end>'
        ]);
      });
    });
    return it('shoud use id as default predicate', function() {
      var a;
      a = stream();
      return expect(a.filterErrors()).toEmit([
        -1, {
          error: 4
        }, -2, {
          error: 5
        }, false, {
          error: 6
        }, '<end>'
      ], function() {
        return send(a, [
          -1, {
            error: 0
          }, {
            error: false
          }, {
            error: null
          }, {
            error: 4
          }, -2, {
            error: 5
          }, {
            error: ''
          }, false, {
            error: 6
          }, '<end>'
        ]);
      });
    });
  });
  return describe('property', function() {
    it('should return property', function() {
      return expect(prop().filterErrors(function() {})).toBeProperty();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = prop();
      return expect(a.filterErrors(function() {})).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(prop(), ['<end>']).filterErrors(function() {})).toEmit(['<end:current>']);
    });
    it('should handle events and current', function() {
      var a;
      a = send(prop(), [
        {
          error: 5
        }
      ]);
      return expect(a.filterErrors(function(x) {
        return x > 3;
      })).toEmit([
        {
          currentError: 5
        }, {
          error: 4
        }, -2, {
          error: 6
        }, '<end>'
      ], function() {
        return send(a, [
          {
            error: 1
          }, {
            error: 2
          }, {
            error: 3
          }, {
            error: 4
          }, -2, {
            error: 0
          }, {
            error: 6
          }, '<end>'
        ]);
      });
    });
    it('should handle current (not pass)', function() {
      var a;
      a = send(prop(), [
        {
          error: 0
        }
      ]);
      return expect(a.filterErrors(function(x) {
        return x > 2;
      })).toEmit([]);
    });
    return it('shoud use id as default predicate', function() {
      var a;
      a = send(prop(), [
        {
          error: 5
        }
      ]);
      expect(a.filterErrors()).toEmit([
        {
          currentError: 5
        }, {
          error: 4
        }, -2, {
          error: 6
        }, '<end>'
      ], function() {
        return send(a, [
          {
            error: 0
          }, {
            error: false
          }, {
            error: null
          }, {
            error: 4
          }, -2, {
            error: void 0
          }, {
            error: 6
          }, '<end>'
        ]);
      });
      a = send(prop(), [
        {
          error: 0
        }
      ]);
      return expect(a.filterErrors()).toEmit([]);
    });
  });
});


},{"../test-helpers.coffee":249}],197:[function(require,module,exports){
var Kefir, prop, ref, send, stream;

ref = require('../test-helpers.coffee'), stream = ref.stream, prop = ref.prop, send = ref.send, Kefir = ref.Kefir;

describe('filter', function() {
  describe('stream', function() {
    it('should return stream', function() {
      return expect(stream().filter(function() {})).toBeStream();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = stream();
      return expect(a.filter(function() {})).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(stream(), ['<end>']).filter(function() {})).toEmit(['<end:current>']);
    });
    it('should handle events', function() {
      var a;
      a = stream();
      return expect(a.filter(function(x) {
        return x > 3;
      })).toEmit([
        4, 5, {
          error: 7
        }, 6, '<end>'
      ], function() {
        return send(a, [
          1, 2, 4, 5, 0, {
            error: 7
          }, 6, '<end>'
        ]);
      });
    });
    return it('shoud use id as default predicate', function() {
      var a;
      a = stream();
      return expect(a.filter()).toEmit([
        4, 5, {
          error: 7
        }, 6, '<end>'
      ], function() {
        return send(a, [
          0, 0, 4, 5, 0, {
            error: 7
          }, 6, '<end>'
        ]);
      });
    });
  });
  return describe('property', function() {
    it('should return property', function() {
      return expect(prop().filter(function() {})).toBeProperty();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = prop();
      return expect(a.filter(function() {})).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(prop(), ['<end>']).filter(function() {})).toEmit(['<end:current>']);
    });
    it('should handle events and current', function() {
      var a;
      a = send(prop(), [5]);
      expect(a.filter(function(x) {
        return x > 2;
      })).toEmit([
        {
          current: 5
        }, 4, {
          error: 7
        }, 3, '<end>'
      ], function() {
        return send(a, [
          4, {
            error: 7
          }, 3, 2, 1, '<end>'
        ]);
      });
      a = send(prop(), [
        {
          error: 0
        }
      ]);
      return expect(a.filter(function(x) {
        return x > 2;
      })).toEmit([
        {
          currentError: 0
        }, 4, {
          error: 7
        }, 3, '<end>'
      ], function() {
        return send(a, [
          4, {
            error: 7
          }, 3, 2, 1, '<end>'
        ]);
      });
    });
    it('should handle current (not pass)', function() {
      var a;
      a = send(prop(), [
        1, {
          error: 0
        }
      ]);
      return expect(a.filter(function(x) {
        return x > 2;
      })).toEmit([
        {
          currentError: 0
        }
      ]);
    });
    return it('shoud use id as default predicate', function() {
      var a;
      a = send(prop(), [0]);
      expect(a.filter()).toEmit([
        4, {
          error: -2
        }, 5, 6, '<end>'
      ], function() {
        return send(a, [
          0, 4, {
            error: -2
          }, 5, 0, 6, '<end>'
        ]);
      });
      a = send(prop(), [1]);
      return expect(a.filter()).toEmit([
        {
          current: 1
        }, 4, {
          error: -2
        }, 5, 6, '<end>'
      ], function() {
        return send(a, [
          0, 4, {
            error: -2
          }, 5, 0, 6, '<end>'
        ]);
      });
    });
  });
});


},{"../test-helpers.coffee":249}],198:[function(require,module,exports){
var Kefir, activate, deactivate, prop, ref, send, stream;

ref = require('../test-helpers.coffee'), stream = ref.stream, prop = ref.prop, send = ref.send, activate = ref.activate, deactivate = ref.deactivate, Kefir = ref.Kefir;

describe('flatMapConcat', function() {
  describe('stream', function() {
    it('should return stream', function() {
      return expect(stream().flatMapConcat()).toBeStream();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = stream();
      return expect(a.flatMapConcat()).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(stream(), ['<end>']).flatMapConcat()).toEmit(['<end:current>']);
    });
    it('should handle events', function() {
      var a, b, c;
      a = stream();
      b = stream();
      c = stream();
      return expect(a.flatMapConcat()).toEmit([1, 2, 5, 6, '<end>'], function() {
        send(b, [0]);
        send(a, [b]);
        send(b, [1, 2]);
        send(a, [c, '<end>']);
        send(c, [4]);
        send(b, [5, '<end>']);
        return send(c, [6, '<end>']);
      });
    });
    it('should activate sub-sources', function() {
      var a, b, c, map;
      a = stream();
      b = stream();
      c = send(prop(), [0]);
      map = a.flatMapConcat();
      activate(map);
      send(a, [b, c]);
      deactivate(map);
      expect(map).toActivate(b);
      expect(map).not.toActivate(c);
      send(b, ['<end>']);
      return expect(map).toActivate(c);
    });
    it('should accept optional map fn', function() {
      var a, b;
      a = stream();
      b = stream();
      return expect(a.flatMapConcat(function(x) {
        return x.obs;
      })).toEmit([1, 2, '<end>'], function() {
        send(b, [0]);
        send(a, [
          {
            obs: b
          }, '<end>'
        ]);
        return send(b, [1, 2, '<end>']);
      });
    });
    it('should correctly handle current values of sub sources on activation', function() {
      var a, b, m;
      a = stream();
      b = send(prop(), [1]);
      m = a.flatMapConcat();
      activate(m);
      send(a, [b]);
      deactivate(m);
      return expect(m).toEmit([
        {
          current: 1
        }
      ]);
    });
    it('should correctly handle current values of new sub sources', function() {
      var a, b, c, d;
      a = stream();
      b = send(prop(), [1, '<end>']);
      c = send(prop(), [2]);
      d = send(prop(), [3]);
      return expect(a.flatMapConcat()).toEmit([1, 2], function() {
        return send(a, [b, c, d]);
      });
    });
    return it('should work nicely with Kefir.constant and Kefir.never', function() {
      var a;
      a = stream();
      return expect(a.flatMapConcat(function(x) {
        if (x > 2) {
          return Kefir.constant(x);
        } else {
          return Kefir.never();
        }
      })).toEmit([3, 4, 5], function() {
        return send(a, [1, 2, 3, 4, 5]);
      });
    });
  });
  return describe('property', function() {
    it('should return stream', function() {
      return expect(prop().flatMapConcat()).toBeStream();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = prop();
      return expect(a.flatMapConcat()).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(prop(), ['<end>']).flatMapConcat()).toEmit(['<end:current>']);
    });
    it('should be ended if source was ended (with value)', function() {
      return expect(send(prop(), [send(prop(), [0, '<end>']), '<end>']).flatMapConcat()).toEmit([
        {
          current: 0
        }, '<end:current>'
      ]);
    });
    return it('should correctly handle current value of source', function() {
      var a, b;
      a = send(prop(), [0]);
      b = send(prop(), [a]);
      return expect(b.flatMapConcat()).toEmit([
        {
          current: 0
        }
      ]);
    });
  });
});


},{"../test-helpers.coffee":249}],199:[function(require,module,exports){
var Kefir, activate, deactivate, prop, ref, send, stream;

ref = require('../test-helpers.coffee'), stream = ref.stream, prop = ref.prop, send = ref.send, activate = ref.activate, deactivate = ref.deactivate, Kefir = ref.Kefir;

describe('flatMapErrors', function() {
  describe('stream', function() {
    it('should return stream', function() {
      return expect(stream().flatMapErrors()).toBeStream();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = stream();
      return expect(a.flatMapErrors()).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(stream(), ['<end>']).flatMapErrors()).toEmit(['<end:current>']);
    });
    it('should handle events', function() {
      var a, b, c;
      a = stream();
      b = stream();
      c = send(prop(), [0]);
      return expect(a.flatMapErrors()).toEmit([1, 2, 0, 3, 4, '<end>'], function() {
        send(b, [0]);
        send(a, [
          {
            error: b
          }
        ]);
        send(b, [1, 2]);
        send(a, [
          {
            error: c
          }, '<end>'
        ]);
        send(b, [3, '<end>']);
        return send(c, [4, '<end>']);
      });
    });
    it('should activate sub-sources', function() {
      var a, b, c, map;
      a = stream();
      b = stream();
      c = send(prop(), [0]);
      map = a.flatMapErrors();
      activate(map);
      send(a, [
        {
          error: b
        }, {
          error: c
        }
      ]);
      deactivate(map);
      return expect(map).toActivate(b, c);
    });
    it('should accept optional map fn', function() {
      var a, b;
      a = stream();
      b = stream();
      return expect(a.flatMapErrors(function(x) {
        return x.obs;
      })).toEmit([1, 2, '<end>'], function() {
        send(b, [0]);
        send(a, [
          {
            error: {
              obs: b
            }
          }, '<end>'
        ]);
        return send(b, [1, 2, '<end>']);
      });
    });
    it('should correctly handle current values of sub sources on activation', function() {
      var a, b, c, m;
      a = stream();
      b = send(prop(), [1]);
      c = send(prop(), [2]);
      m = a.flatMapErrors();
      activate(m);
      send(a, [
        {
          error: b
        }, {
          error: c
        }
      ]);
      deactivate(m);
      return expect(m).toEmit([
        {
          current: 1
        }, {
          current: 2
        }
      ]);
    });
    it('should correctly handle current values of new sub sources', function() {
      var a, b, c;
      a = stream();
      b = send(prop(), [1]);
      c = send(prop(), [2]);
      return expect(a.flatMapErrors()).toEmit([1, 2], function() {
        return send(a, [
          {
            error: b
          }, {
            error: c
          }
        ]);
      });
    });
    it('should work nicely with Kefir.constant and Kefir.never', function() {
      var a;
      a = stream();
      return expect(a.valuesToErrors().flatMapErrors(function(x) {
        if (x > 2) {
          return Kefir.constant(x);
        } else if (x < 0) {
          return Kefir.constantError(x);
        } else {
          return Kefir.never();
        }
      })).toEmit([
        3, {
          error: -1
        }, 4, {
          error: -2
        }, 5
      ], function() {
        return send(a, [1, 2, 3, -1, 4, -2, 5]);
      });
    });
    it('values should flow', function() {
      var a;
      a = stream();
      return expect(a.flatMapErrors()).toEmit([1, 2, 3], function() {
        return send(a, [1, 2, 3]);
      });
    });
    return it('should be possible to add same obs twice on activation', function() {
      var a, b;
      b = send(prop(), [1]);
      a = Kefir.stream(function(em) {
        em.error(b);
        return em.error(b);
      });
      return expect(a.flatMapErrors()).toEmit([
        {
          current: 1
        }, {
          current: 1
        }
      ]);
    });
  });
  return describe('property', function() {
    it('should be ended if source was ended (with current error)', function() {
      return expect(send(prop(), [
        {
          error: send(prop(), [0, '<end>'])
        }, '<end>'
      ]).flatMapErrors()).toEmit([
        {
          current: 0
        }, '<end:current>'
      ]);
    });
    it('should not costantly adding current value on each activation', function() {
      var a, b, map;
      a = send(prop(), [0]);
      b = send(prop(), [
        {
          error: a
        }
      ]);
      map = b.flatMapErrors();
      activate(map);
      deactivate(map);
      activate(map);
      deactivate(map);
      return expect(map).toEmit([
        {
          current: 0
        }
      ]);
    });
    it('should allow to add same obs several times', function() {
      var a, b, c;
      b = send(prop(), ['b0']);
      c = stream();
      a = send(prop(), [b]);
      return expect(a.valuesToErrors().flatMapErrors()).toEmit([
        {
          current: 'b0'
        }, 'b0', 'b0', 'b0', 'b0', 'b1', 'b1', 'b1', 'b1', 'b1', 'c1', 'c1', 'c1', '<end>'
      ], function() {
        send(a, [b, c, b, c, c, b, b, '<end>']);
        send(b, ['b1', '<end>']);
        return send(c, ['c1', '<end>']);
      });
    });
    it('should correctly handle current error of source', function() {
      var a, b;
      a = send(prop(), [0]);
      b = send(prop(), [
        {
          error: a
        }
      ]);
      return expect(b.flatMapErrors()).toEmit([
        {
          current: 0
        }
      ]);
    });
    return it('values should flow', function() {
      var a;
      a = send(prop(), [0]);
      return expect(a.flatMapErrors()).toEmit([
        {
          current: 0
        }, 1, 2, 3
      ], function() {
        return send(a, [1, 2, 3]);
      });
    });
  });
});


},{"../test-helpers.coffee":249}],200:[function(require,module,exports){
var Kefir, activate, deactivate, prop, ref, send, stream;

ref = require('../test-helpers.coffee'), stream = ref.stream, prop = ref.prop, send = ref.send, activate = ref.activate, deactivate = ref.deactivate, Kefir = ref.Kefir;

describe('flatMapFirst', function() {
  describe('stream', function() {
    it('should return stream', function() {
      return expect(stream().flatMapFirst()).toBeStream();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = stream();
      return expect(a.flatMapFirst()).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(stream(), ['<end>']).flatMapFirst()).toEmit(['<end:current>']);
    });
    it('should handle events', function() {
      var a, b, c;
      a = stream();
      b = stream();
      c = stream();
      return expect(a.flatMapFirst()).toEmit([1, 2, 4, '<end>'], function() {
        send(b, [0]);
        send(a, [b]);
        send(b, [1]);
        send(a, [c]);
        send(b, [2, '<end>']);
        send(c, [3]);
        send(a, [c, '<end>']);
        return send(c, [4, '<end>']);
      });
    });
    it('should activate sub-sources (only first)', function() {
      var a, b, c, map;
      a = stream();
      b = stream();
      c = send(prop(), [0]);
      map = a.flatMapFirst();
      activate(map);
      send(a, [b, c]);
      deactivate(map);
      expect(map).toActivate(b);
      return expect(map).not.toActivate(c);
    });
    it('should accept optional map fn', function() {
      var a, b;
      a = stream();
      b = stream();
      return expect(a.flatMapFirst(function(x) {
        return x.obs;
      })).toEmit([1, 2, '<end>'], function() {
        send(a, [
          {
            obs: b
          }, '<end>'
        ]);
        return send(b, [1, 2, '<end>']);
      });
    });
    it('should correctly handle current values of sub sources on activation', function() {
      var a, b, c, m;
      a = stream();
      b = send(prop(), [1]);
      c = send(prop(), [2]);
      m = a.flatMapFirst();
      activate(m);
      send(a, [b, c]);
      deactivate(m);
      return expect(m).toEmit([
        {
          current: 1
        }
      ]);
    });
    it('should correctly handle current values of new sub sources', function() {
      var a, b, c, d;
      a = stream();
      b = send(prop(), [1, '<end>']);
      c = send(prop(), [2]);
      d = send(prop(), [3]);
      return expect(a.flatMapFirst()).toEmit([1, 2], function() {
        return send(a, [b, c, d]);
      });
    });
    it('should work nicely with Kefir.constant and Kefir.never', function() {
      var a;
      a = stream();
      return expect(a.flatMapFirst(function(x) {
        if (x > 2) {
          return Kefir.constant(x);
        } else {
          return Kefir.never();
        }
      })).toEmit([3, 4, 5], function() {
        return send(a, [1, 2, 3, 4, 5]);
      });
    });
    return it('should not call transformer function when skiping values', function() {
      var a, b, c, count, result;
      count = 0;
      a = stream();
      b = stream();
      c = stream();
      result = a.flatMapFirst(function(x) {
        count++;
        return x;
      });
      activate(result);
      expect(count).toBe(0);
      send(a, [b]);
      expect(count).toBe(1);
      send(a, [c]);
      expect(count).toBe(1);
      send(b, ['<end>']);
      expect(count).toBe(1);
      send(a, [c]);
      return expect(count).toBe(2);
    });
  });
  return describe('property', function() {
    it('should return stream', function() {
      return expect(prop().flatMapFirst()).toBeStream();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = prop();
      return expect(a.flatMapFirst()).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(prop(), ['<end>']).flatMapFirst()).toEmit(['<end:current>']);
    });
    it('should be ended if source was ended (with value)', function() {
      return expect(send(prop(), [send(prop(), [0, '<end>']), '<end>']).flatMapFirst()).toEmit([
        {
          current: 0
        }, '<end:current>'
      ]);
    });
    return it('should correctly handle current value of source', function() {
      var a, b;
      a = send(prop(), [0]);
      b = send(prop(), [a]);
      return expect(b.flatMapFirst()).toEmit([
        {
          current: 0
        }
      ]);
    });
  });
});


},{"../test-helpers.coffee":249}],201:[function(require,module,exports){
var Kefir, activate, deactivate, prop, ref, send, stream;

ref = require('../test-helpers.coffee'), stream = ref.stream, prop = ref.prop, send = ref.send, activate = ref.activate, deactivate = ref.deactivate, Kefir = ref.Kefir;

describe('flatMapLatest', function() {
  describe('stream', function() {
    it('should return stream', function() {
      return expect(stream().flatMapLatest()).toBeStream();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = stream();
      return expect(a.flatMapLatest()).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(stream(), ['<end>']).flatMapLatest()).toEmit(['<end:current>']);
    });
    it('should handle events', function() {
      var a, b, c;
      a = stream();
      b = stream();
      c = send(prop(), [0]);
      return expect(a.flatMapLatest()).toEmit([1, 0, 3, 5, '<end>'], function() {
        send(b, [0]);
        send(a, [b]);
        send(b, [1]);
        send(a, [c]);
        send(b, [2]);
        send(c, [3]);
        send(a, [b, '<end>']);
        send(c, [4]);
        return send(b, [5, '<end>']);
      });
    });
    it('should activate sub-sources (only latest)', function() {
      var a, b, c, map;
      a = stream();
      b = stream();
      c = send(prop(), [0]);
      map = a.flatMapLatest();
      activate(map);
      send(a, [b, c]);
      deactivate(map);
      expect(map).toActivate(c);
      return expect(map).not.toActivate(b);
    });
    it('should accept optional map fn', function() {
      var a, b;
      a = stream();
      b = stream();
      return expect(a.flatMapLatest(function(x) {
        return x.obs;
      })).toEmit([1, 2, '<end>'], function() {
        send(a, [
          {
            obs: b
          }, '<end>'
        ]);
        return send(b, [1, 2, '<end>']);
      });
    });
    it('should correctly handle current values of sub sources on activation', function() {
      var a, b, c, m;
      a = stream();
      b = send(prop(), [1]);
      c = send(prop(), [2]);
      m = a.flatMapLatest();
      activate(m);
      send(a, [b, c]);
      deactivate(m);
      return expect(m).toEmit([
        {
          current: 2
        }
      ]);
    });
    it('should correctly handle current values of new sub sources', function() {
      var a, b, c;
      a = stream();
      b = send(prop(), [1]);
      c = send(prop(), [2]);
      return expect(a.flatMapLatest()).toEmit([1, 2], function() {
        return send(a, [b, c]);
      });
    });
    return it('should work nicely with Kefir.constant and Kefir.never', function() {
      var a;
      a = stream();
      return expect(a.flatMapLatest(function(x) {
        if (x > 2) {
          return Kefir.constant(x);
        } else {
          return Kefir.never();
        }
      })).toEmit([3, 4, 5], function() {
        return send(a, [1, 2, 3, 4, 5]);
      });
    });
  });
  return describe('property', function() {
    it('should return stream', function() {
      return expect(prop().flatMapLatest()).toBeStream();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = prop();
      return expect(a.flatMapLatest()).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(prop(), ['<end>']).flatMapLatest()).toEmit(['<end:current>']);
    });
    it('should be ended if source was ended (with value)', function() {
      return expect(send(prop(), [send(prop(), [0, '<end>']), '<end>']).flatMapLatest()).toEmit([
        {
          current: 0
        }, '<end:current>'
      ]);
    });
    return it('should correctly handle current value of source', function() {
      var a, b;
      a = send(prop(), [0]);
      b = send(prop(), [a]);
      return expect(b.flatMapLatest()).toEmit([
        {
          current: 0
        }
      ]);
    });
  });
});


},{"../test-helpers.coffee":249}],202:[function(require,module,exports){
var Kefir, activate, deactivate, prop, ref, send, stream;

ref = require('../test-helpers.coffee'), stream = ref.stream, prop = ref.prop, send = ref.send, activate = ref.activate, deactivate = ref.deactivate, Kefir = ref.Kefir;

describe('flatMapConcurLimit', function() {
  describe('stream', function() {
    it('should return stream', function() {
      return expect(stream().flatMapConcurLimit(null, 1)).toBeStream();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = stream();
      return expect(a.flatMapConcurLimit(null, 1)).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(stream(), ['<end>']).flatMapConcurLimit(null, 1)).toEmit(['<end:current>']);
    });
    it('should handle events', function() {
      var a, b, c, d;
      a = stream();
      b = stream();
      c = stream();
      d = stream();
      return expect(a.flatMapConcurLimit(null, 2)).toEmit([1, 2, 4, 5, 6, '<end>'], function() {
        send(b, [0]);
        send(a, [b]);
        send(b, [1]);
        send(a, [c, d, '<end>']);
        send(c, [2]);
        send(d, [3]);
        send(b, [4, '<end>']);
        send(d, [5, '<end>']);
        return send(c, [6, '<end>']);
      });
    });
    it('should activate sub-sources', function() {
      var a, b, c, d, map;
      a = stream();
      b = stream();
      c = stream();
      d = stream();
      map = a.flatMapConcurLimit(null, 2);
      activate(map);
      send(a, [b, c, d]);
      deactivate(map);
      expect(map).toActivate(b, c);
      expect(map).not.toActivate(d);
      send(b, ['<end>']);
      return expect(map).toActivate(d);
    });
    it('should accept optional map fn', function() {
      var a, b;
      a = stream();
      b = stream();
      return expect(a.flatMapConcurLimit((function(x) {
        return x.obs;
      }), 1)).toEmit([1, 2, '<end>'], function() {
        send(b, [0]);
        send(a, [
          {
            obs: b
          }, '<end>'
        ]);
        return send(b, [1, 2, '<end>']);
      });
    });
    it('should correctly handle current values of sub sources on activation', function() {
      var a, b, c, d, m;
      a = stream();
      b = send(prop(), [1]);
      c = send(prop(), [2]);
      d = send(prop(), [3]);
      m = a.flatMapConcurLimit(null, 2);
      activate(m);
      send(a, [b, c, d]);
      deactivate(m);
      return expect(m).toEmit([
        {
          current: 1
        }, {
          current: 2
        }
      ]);
    });
    it('should correctly handle current values of new sub sources', function() {
      var a, b, c, d, e;
      a = stream();
      b = send(prop(), [1, '<end>']);
      c = send(prop(), [2]);
      d = send(prop(), [3]);
      e = send(prop(), [4]);
      return expect(a.flatMapConcurLimit(null, 2)).toEmit([4, 1, 2], function() {
        return send(a, [e, b, c, d]);
      });
    });
    it('limit = 0', function() {
      var a;
      a = stream();
      return expect(a.flatMapConcurLimit(null, 0)).toEmit(['<end:current>']);
    });
    it('limit = -1', function() {
      var a, b, c, d;
      a = stream();
      b = stream();
      c = stream();
      d = stream();
      return expect(a.flatMapConcurLimit(null, -1)).toEmit([1, 2, 3, 4, 5, 6, '<end>'], function() {
        send(b, [0]);
        send(a, [b]);
        send(b, [1]);
        send(a, [c, d, '<end>']);
        send(c, [2]);
        send(d, [3]);
        send(b, [4, '<end>']);
        send(d, [5, '<end>']);
        return send(c, [6, '<end>']);
      });
    });
    return it('limit = -2', function() {
      var a, b, c, d;
      a = stream();
      b = stream();
      c = stream();
      d = stream();
      return expect(a.flatMapConcurLimit(null, -2)).toEmit([1, 2, 3, 4, 5, 6, '<end>'], function() {
        send(b, [0]);
        send(a, [b]);
        send(b, [1]);
        send(a, [c, d, '<end>']);
        send(c, [2]);
        send(d, [3]);
        send(b, [4, '<end>']);
        send(d, [5, '<end>']);
        return send(c, [6, '<end>']);
      });
    });
  });
  return describe('property', function() {
    it('should return stream', function() {
      return expect(prop().flatMapConcurLimit(null, 1)).toBeStream();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = prop();
      return expect(a.flatMapConcurLimit(null, 1)).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(prop(), ['<end>']).flatMapConcurLimit(null, 1)).toEmit(['<end:current>']);
    });
    it('should be ended if source was ended (with value)', function() {
      return expect(send(prop(), [send(prop(), [0, '<end>']), '<end>']).flatMapConcurLimit(null, 1)).toEmit([
        {
          current: 0
        }, '<end:current>'
      ]);
    });
    return it('should correctly handle current value of source', function() {
      var a, b;
      a = send(prop(), [0]);
      b = send(prop(), [a]);
      return expect(b.flatMapConcurLimit(null, 1)).toEmit([
        {
          current: 0
        }
      ]);
    });
  });
});


},{"../test-helpers.coffee":249}],203:[function(require,module,exports){
var Kefir, activate, deactivate, prop, ref, send, stream;

ref = require('../test-helpers.coffee'), stream = ref.stream, prop = ref.prop, send = ref.send, activate = ref.activate, deactivate = ref.deactivate, Kefir = ref.Kefir;

describe('flatMap', function() {
  describe('stream', function() {
    it('should return stream', function() {
      return expect(stream().flatMap()).toBeStream();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = stream();
      return expect(a.flatMap()).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(stream(), ['<end>']).flatMap()).toEmit(['<end:current>']);
    });
    it('should handle events', function() {
      var a, b, c;
      a = stream();
      b = stream();
      c = send(prop(), [0]);
      return expect(a.flatMap()).toEmit([1, 2, 0, 3, 4, '<end>'], function() {
        send(b, [0]);
        send(a, [b]);
        send(b, [1, 2]);
        send(a, [c, '<end>']);
        send(b, [3, '<end>']);
        return send(c, [4, '<end>']);
      });
    });
    it('should activate sub-sources', function() {
      var a, b, c, map;
      a = stream();
      b = stream();
      c = send(prop(), [0]);
      map = a.flatMap();
      activate(map);
      send(a, [b, c]);
      deactivate(map);
      return expect(map).toActivate(b, c);
    });
    it('should accept optional map fn', function() {
      var a, b;
      a = stream();
      b = stream();
      return expect(a.flatMap(function(x) {
        return x.obs;
      })).toEmit([1, 2, '<end>'], function() {
        send(b, [0]);
        send(a, [
          {
            obs: b
          }, '<end>'
        ]);
        return send(b, [1, 2, '<end>']);
      });
    });
    it('should correctly handle current values of sub sources on activation', function() {
      var a, b, c, m;
      a = stream();
      b = send(prop(), [1]);
      c = send(prop(), [2]);
      m = a.flatMap();
      activate(m);
      send(a, [b, c]);
      deactivate(m);
      return expect(m).toEmit([
        {
          current: 1
        }, {
          current: 2
        }
      ]);
    });
    it('should correctly handle current values of new sub sources', function() {
      var a, b, c;
      a = stream();
      b = send(prop(), [1]);
      c = send(prop(), [2]);
      return expect(a.flatMap()).toEmit([1, 2], function() {
        return send(a, [b, c]);
      });
    });
    it('should work nicely with Kefir.constant and Kefir.never', function() {
      var a;
      a = stream();
      return expect(a.flatMap(function(x) {
        if (x > 2) {
          return Kefir.constant(x);
        } else if (x < 0) {
          return Kefir.constantError(x);
        } else {
          return Kefir.never();
        }
      })).toEmit([
        3, {
          error: -1
        }, 4, {
          error: -2
        }, 5
      ], function() {
        return send(a, [1, 2, 3, -1, 4, -2, 5]);
      });
    });
    it('Bug in flatMap: exception thrown when resubscribing to stream', function() {
      var handler, src, stream1, sub;
      src = stream();
      stream1 = src.flatMap(function(x) {
        return x;
      });
      handler = function() {};
      stream1.onValue(handler);
      sub = stream();
      send(src, [sub, '<end>']);
      stream1.offValue(handler);
      send(sub, ['<end>']);
      return stream1.onValue(handler);
    });
    it('errors should flow', function() {
      var a, b, c, result;
      a = stream();
      b = stream();
      c = prop();
      result = a.flatMap();
      activate(result);
      send(a, [b, c]);
      deactivate(result);
      expect(result).errorsToFlow(a);
      expect(result).errorsToFlow(b);
      return expect(result).errorsToFlow(c);
    });
    it('Bug "flatMap with take(1) doesn\'t unsubscribe from source"', function() {
      var a, b, subs, unsubs;
      subs = 0;
      unsubs = 0;
      a = Kefir.stream(function(emitter) {
        subs++;
        emitter.emit(1);
        return function() {
          return unsubs++;
        };
      });
      b = Kefir.constant(1).flatMap(function() {
        return a;
      }).take(1);
      b.onValue(function() {});
      expect(subs).toBe(1);
      return expect(unsubs).toBe(1);
    });
    return it('should be possible to add same obs twice on activation', function() {
      var a, b;
      b = send(prop(), [1]);
      a = Kefir.stream(function(em) {
        em.emit(b);
        return em.emit(b);
      });
      return expect(a.flatMap()).toEmit([
        {
          current: 1
        }, {
          current: 1
        }
      ]);
    });
  });
  return describe('property', function() {
    it('should return stream', function() {
      return expect(prop().flatMap()).toBeStream();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = prop();
      return expect(a.flatMap()).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(prop(), ['<end>']).flatMap()).toEmit(['<end:current>']);
    });
    it('should be ended if source was ended (with value)', function() {
      return expect(send(prop(), [send(prop(), [0, '<end>']), '<end>']).flatMap()).toEmit([
        {
          current: 0
        }, '<end:current>'
      ]);
    });
    it('should not costantly adding current value on each activation', function() {
      var a, b, map;
      a = send(prop(), [0]);
      b = send(prop(), [a]);
      map = b.flatMap();
      activate(map);
      deactivate(map);
      activate(map);
      deactivate(map);
      return expect(map).toEmit([
        {
          current: 0
        }
      ]);
    });
    it('should allow to add same obs several times', function() {
      var a, b, c;
      b = send(prop(), ['b0']);
      c = stream();
      a = send(prop(), [b]);
      return expect(a.flatMap()).toEmit([
        {
          current: 'b0'
        }, 'b0', 'b0', 'b0', 'b0', 'b1', 'b1', 'b1', 'b1', 'b1', 'c1', 'c1', 'c1', '<end>'
      ], function() {
        send(a, [b, c, b, c, c, b, b, '<end>']);
        send(b, ['b1', '<end>']);
        return send(c, ['c1', '<end>']);
      });
    });
    it('should correctly handle current value of source', function() {
      var a, b;
      a = send(prop(), [0]);
      b = send(prop(), [a]);
      return expect(b.flatMap()).toEmit([
        {
          current: 0
        }
      ]);
    });
    it('errors should flow 1', function() {
      var a, result;
      a = prop();
      result = a.flatMap();
      return expect(result).errorsToFlow(a);
    });
    return it('errors should flow 2', function() {
      var a, b, c, result;
      a = prop();
      b = stream();
      c = prop();
      result = a.flatMap();
      activate(result);
      send(a, [b, c]);
      deactivate(result);
      expect(result).errorsToFlow(b);
      return expect(result).errorsToFlow(c);
    });
  });
});


},{"../test-helpers.coffee":249}],204:[function(require,module,exports){
var Kefir, prop, ref, send, stream;

ref = require('../test-helpers.coffee'), stream = ref.stream, prop = ref.prop, send = ref.send, Kefir = ref.Kefir;

describe('flatten', function() {
  describe('stream', function() {
    it('should return stream', function() {
      return expect(stream().flatten(function() {})).toBeStream();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = stream();
      return expect(a.flatten(function() {})).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(stream(), ['<end>']).flatten(function() {})).toEmit(['<end:current>']);
    });
    it('should handle events', function() {
      var a;
      a = stream();
      return expect(a.flatten(function(x) {
        var i, results;
        if (x > 1) {
          return (function() {
            results = [];
            for (var i = 1; 1 <= x ? i <= x : i >= x; 1 <= x ? i++ : i--){ results.push(i); }
            return results;
          }).apply(this);
        } else {
          return [];
        }
      })).toEmit([
        1, 2, {
          error: 4
        }, 1, 2, 3, '<end>'
      ], function() {
        return send(a, [
          1, 2, {
            error: 4
          }, 3, '<end>'
        ]);
      });
    });
    return it('if no `fn` provided should use the `id` function by default', function() {
      var a;
      a = stream();
      return expect(a.flatten()).toEmit([1, 2, 3, '<end>'], function() {
        return send(a, [[1], [], [2, 3], '<end>']);
      });
    });
  });
  return describe('property', function() {
    it('should return stream', function() {
      return expect(prop().flatten(function() {})).toBeStream();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = prop();
      return expect(a.flatten(function() {})).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(prop(), ['<end>']).flatten(function() {})).toEmit(['<end:current>']);
    });
    it('should handle events (handler skips current)', function() {
      var a;
      a = send(prop(), [1]);
      return expect(a.flatten(function(x) {
        var i, results;
        if (x > 1) {
          return (function() {
            results = [];
            for (var i = 1; 1 <= x ? i <= x : i >= x; 1 <= x ? i++ : i--){ results.push(i); }
            return results;
          }).apply(this);
        } else {
          return [];
        }
      })).toEmit([
        1, 2, {
          error: 4
        }, 1, 2, 3, '<end>'
      ], function() {
        return send(a, [
          2, {
            error: 4
          }, 3, '<end>'
        ]);
      });
    });
    it('should handle current correctly', function() {
      expect(send(prop(), [1]).flatten(function(x) {
        return [x];
      })).toEmit([
        {
          current: 1
        }
      ]);
      return expect(send(prop(), [
        {
          error: 0
        }
      ]).flatten(function() {})).toEmit([
        {
          currentError: 0
        }
      ]);
    });
    return it('should handle multiple currents correctly', function() {
      return expect(send(prop(), [2]).flatten(function(x) {
        var i, results;
        return (function() {
          results = [];
          for (var i = 1; 1 <= x ? i <= x : i >= x; 1 <= x ? i++ : i--){ results.push(i); }
          return results;
        }).apply(this);
      })).toEmit([
        {
          current: 1
        }, {
          current: 2
        }
      ]);
    });
  });
});


},{"../test-helpers.coffee":249}],205:[function(require,module,exports){
var Kefir, activate, deactivate, ref;

ref = require('../test-helpers.coffee'), activate = ref.activate, deactivate = ref.deactivate, Kefir = ref.Kefir;

describe('fromCallback', function() {
  it('should return stream', function() {
    return expect(Kefir.fromCallback(function() {})).toBeStream();
  });
  it('should not be ended', function() {
    return expect(Kefir.fromCallback(function() {})).toEmit([]);
  });
  it('should call `callbackConsumer` on first activation, and only on first', function() {
    var count, s;
    count = 0;
    s = Kefir.fromCallback(function() {
      return count++;
    });
    expect(count).toBe(0);
    activate(s);
    expect(count).toBe(1);
    deactivate(s);
    activate(s);
    deactivate(s);
    activate(s);
    return expect(count).toBe(1);
  });
  it('should emit first result and end after that', function() {
    var cb;
    cb = null;
    return expect(Kefir.fromCallback(function(_cb) {
      return cb = _cb;
    })).toEmit([1, '<end>'], function() {
      return cb(1);
    });
  });
  it('should work after deactivation/activate cicle', function() {
    var cb, s;
    cb = null;
    s = Kefir.fromCallback(function(_cb) {
      return cb = _cb;
    });
    activate(s);
    deactivate(s);
    activate(s);
    deactivate(s);
    return expect(s).toEmit([1, '<end>'], function() {
      return cb(1);
    });
  });
  return it('should emit a current, if `callback` is called immediately in `callbackConsumer`', function() {
    return expect(Kefir.fromCallback(function(cb) {
      return cb(1);
    })).toEmit([
      {
        current: 1
      }, '<end:current>'
    ]);
  });
});


},{"../test-helpers.coffee":249}],206:[function(require,module,exports){
var Kefir, Observable, Rx, activate, deactivate, ref;

Observable = require('zen-observable');

Rx = require('@reactivex/rxjs');

ref = require('../test-helpers.coffee'), activate = ref.activate, deactivate = ref.deactivate, Kefir = ref.Kefir;

describe('fromESObservable', function() {
  it('turns an ES7 observable into a stream', function() {
    return expect(Kefir.fromESObservable(Observable.of(1, 2))).toBeStream();
  });
  it('emits events from observable to stream', function(done) {
    var stream, values;
    stream = Kefir.fromESObservable(Observable.of(1, 2));
    values = [];
    stream.onValue(function(value) {
      return values.push(value);
    });
    return stream.onEnd(function() {
      expect(values).toEqual([1, 2]);
      return done();
    });
  });
  it('ends stream after an error', function(done) {
    var observable;
    observable = new Observable(function(observer) {
      observer.next(1);
      return observer.error();
    });
    return Kefir.fromESObservable(observable).onEnd(function() {
      return done();
    });
  });
  return it('turns an RxJS observable into a Kefir stream', function(done) {
    var stream, values;
    stream = Kefir.fromESObservable(Rx.Observable.of('hello world'));
    values = [];
    stream.onValue(function(value) {
      return values.push(value);
    });
    return stream.onEnd(function() {
      expect(values).toEqual(['hello world']);
      return done();
    });
  });
});


},{"../test-helpers.coffee":249,"@reactivex/rxjs":138,"zen-observable":176}],207:[function(require,module,exports){
var Kefir, activate, deactivate, ref;

ref = require('../test-helpers.coffee'), activate = ref.activate, deactivate = ref.deactivate, Kefir = ref.Kefir;

describe('fromEvents', function() {
  var domTarget, nodeTarget, onOffTarget;
  domTarget = function() {
    return {
      addEventListener: function(name, fn) {
        return this[name + 'Listener'] = fn;
      },
      removeEventListener: function(name, fn) {
        if (this[name + 'Listener'] === fn) {
          return delete this[name + 'Listener'];
        }
      }
    };
  };
  nodeTarget = function() {
    return {
      addListener: function(name, fn) {
        return this[name + 'Listener'] = fn;
      },
      removeListener: function(name, fn) {
        if (this[name + 'Listener'] === fn) {
          return delete this[name + 'Listener'];
        }
      }
    };
  };
  onOffTarget = function() {
    return {
      on: function(name, fn) {
        return this[name + 'Listener'] = fn;
      },
      off: function(name, fn) {
        if (this[name + 'Listener'] === fn) {
          return delete this[name + 'Listener'];
        }
      }
    };
  };
  it('should return stream', function() {
    return expect(Kefir.fromEvents(domTarget(), 'foo')).toBeStream();
  });
  it('should not be ended', function() {
    return expect(Kefir.fromEvents(domTarget(), 'foo')).toEmit([]);
  });
  it('should subscribe/unsubscribe from target', function() {
    var a, target;
    target = domTarget();
    a = Kefir.fromEvents(target, 'foo');
    expect(target.fooListener).toBeUndefined();
    activate(a);
    expect(target.fooListener).toEqual(jasmine.any(Function));
    deactivate(a);
    expect(target.fooListener).toBeUndefined();
    target = onOffTarget();
    a = Kefir.fromEvents(target, 'foo');
    expect(target.fooListener).toBeUndefined();
    activate(a);
    expect(target.fooListener).toEqual(jasmine.any(Function));
    deactivate(a);
    expect(target.fooListener).toBeUndefined();
    target = nodeTarget();
    a = Kefir.fromEvents(target, 'foo');
    expect(target.fooListener).toBeUndefined();
    activate(a);
    expect(target.fooListener).toEqual(jasmine.any(Function));
    deactivate(a);
    return expect(target.fooListener).toBeUndefined();
  });
  it('should emit values', function() {
    var a, target;
    target = domTarget();
    a = Kefir.fromEvents(target, 'foo');
    expect(a).toEmit([1, 2, 3], function() {
      target.fooListener(1);
      target.fooListener(2);
      return target.fooListener(3);
    });
    target = nodeTarget();
    a = Kefir.fromEvents(target, 'foo');
    expect(a).toEmit([1, 2, 3], function() {
      target.fooListener(1);
      target.fooListener(2);
      return target.fooListener(3);
    });
    target = onOffTarget();
    a = Kefir.fromEvents(target, 'foo');
    return expect(a).toEmit([1, 2, 3], function() {
      target.fooListener(1);
      target.fooListener(2);
      return target.fooListener(3);
    });
  });
  it('should accept optional transformer and call it properly', function() {
    var a, target;
    target = domTarget();
    a = Kefir.fromEvents(target, 'foo', function(a, b) {
      return [this, a, b];
    });
    return expect(a).toEmit([
      [
        {
          a: 1
        }, void 0, void 0
      ], [
        {
          b: 1
        }, 1, void 0
      ], [
        {
          c: 1
        }, 1, 2
      ]
    ], function() {
      target.fooListener.call({
        a: 1
      });
      target.fooListener.call({
        b: 1
      }, 1);
      return target.fooListener.call({
        c: 1
      }, 1, 2);
    });
  });
  it('the callback passed to the target should always retrun undefined (no transformer)', function() {
    var a, cb, target;
    cb = null;
    target = {
      on: function(e, x) {
        return cb = x;
      },
      off: function(e, x) {
        return cb = null;
      }
    };
    a = Kefir.fromEvents(target, 'foo');
    a.take(2).onValue(function() {});
    expect(cb(1)).toEqual(void 0);
    expect(cb(2)).toEqual(void 0);
    return expect(cb).toEqual(null);
  });
  return it('the callback passed to the target should always retrun undefined (with transformer)', function() {
    var a, cb, target;
    cb = null;
    target = {
      on: function(e, x) {
        return cb = x;
      },
      off: function(e, x) {
        return cb = null;
      }
    };
    a = Kefir.fromEvents(target, 'foo', function(x) {
      return x;
    });
    a.take(2).onValue(function() {});
    expect(cb(1)).toEqual(void 0);
    expect(cb(2)).toEqual(void 0);
    return expect(cb).toEqual(null);
  });
});


},{"../test-helpers.coffee":249}],208:[function(require,module,exports){
var Kefir, activate, deactivate, ref;

ref = require('../test-helpers.coffee'), activate = ref.activate, deactivate = ref.deactivate, Kefir = ref.Kefir;

describe('fromNodeCallback', function() {
  it('should return stream', function() {
    return expect(Kefir.fromNodeCallback(function() {})).toBeStream();
  });
  it('should not be ended', function() {
    return expect(Kefir.fromNodeCallback(function() {})).toEmit([]);
  });
  it('should call `callbackConsumer` on first activation, and only on first', function() {
    var count, s;
    count = 0;
    s = Kefir.fromNodeCallback(function() {
      return count++;
    });
    expect(count).toBe(0);
    activate(s);
    expect(count).toBe(1);
    deactivate(s);
    activate(s);
    deactivate(s);
    activate(s);
    return expect(count).toBe(1);
  });
  it('should emit first result and end after that', function() {
    var cb;
    cb = null;
    return expect(Kefir.fromNodeCallback(function(_cb) {
      return cb = _cb;
    })).toEmit([1, '<end>'], function() {
      return cb(null, 1);
    });
  });
  it('should emit first error and end after that', function() {
    var cb;
    cb = null;
    return expect(Kefir.fromNodeCallback(function(_cb) {
      return cb = _cb;
    })).toEmit([
      {
        error: -1
      }, '<end>'
    ], function() {
      return cb(-1);
    });
  });
  it('should work after deactivation/activate cicle', function() {
    var cb, s;
    cb = null;
    s = Kefir.fromNodeCallback(function(_cb) {
      return cb = _cb;
    });
    activate(s);
    deactivate(s);
    activate(s);
    deactivate(s);
    return expect(s).toEmit([1, '<end>'], function() {
      return cb(null, 1);
    });
  });
  return it('should emit a current, if `callback` is called immediately in `callbackConsumer`', function() {
    expect(Kefir.fromNodeCallback(function(cb) {
      return cb(null, 1);
    })).toEmit([
      {
        current: 1
      }, '<end:current>'
    ]);
    return expect(Kefir.fromNodeCallback(function(cb) {
      return cb(-1);
    })).toEmit([
      {
        currentError: -1
      }, '<end:current>'
    ]);
  });
});


},{"../test-helpers.coffee":249}],209:[function(require,module,exports){
var Kefir;

Kefir = require('../../dist/kefir');

describe('fromPoll', function() {
  it('should return stream', function() {
    return expect(Kefir.fromPoll(100, function() {})).toBeStream();
  });
  return it('should emit whatever fn returns at certain time', function() {
    var i;
    i = 0;
    return expect(Kefir.fromPoll(100, function() {
      return ++i;
    })).toEmitInTime([[100, 1], [200, 2], [300, 3]], null, 350);
  });
});


},{"../../dist/kefir":1}],210:[function(require,module,exports){
var Kefir, activate, deactivate, ref;

ref = require('../test-helpers.coffee'), activate = ref.activate, deactivate = ref.deactivate, Kefir = ref.Kefir;

describe('fromPromise', function() {
  var failedAsync, failedSync, fulfilledAsync, fulfilledSync, inProgress;
  inProgress = {
    then: function() {}
  };
  fulfilledSync = {
    then: function(onSuccess) {
      return onSuccess(1);
    }
  };
  failedSync = {
    then: function(onSuccess, onError) {
      return onError(1);
    }
  };
  fulfilledAsync = {
    then: function(onSuccess) {
      var fulfill;
      fulfill = function() {
        return onSuccess(1);
      };
      return setTimeout(fulfill, 1000);
    }
  };
  failedAsync = {
    then: function(onSuccess, onError) {
      var fail;
      fail = function() {
        return onError(1);
      };
      return setTimeout(fail, 1000);
    }
  };
  it('should return property', function() {
    return expect(Kefir.fromPromise(inProgress)).toBeProperty();
  });
  it('should call `property.then` on first activation, and only on first', function() {
    var count, s;
    count = 0;
    s = Kefir.fromPromise({
      then: function() {
        return count++;
      }
    });
    expect(count).toBe(0);
    activate(s);
    expect(count).toBe(1);
    deactivate(s);
    activate(s);
    deactivate(s);
    activate(s);
    return expect(count).toBe(1);
  });
  it('should call `property.done`', function() {
    var count, s;
    count = 0;
    s = Kefir.fromPromise({
      then: (function() {
        return this;
      }),
      done: (function() {
        return count++;
      })
    });
    expect(count).toBe(0);
    activate(s);
    expect(count).toBe(1);
    deactivate(s);
    activate(s);
    deactivate(s);
    activate(s);
    return expect(count).toBe(1);
  });
  it('should work correctly with inProgress property', function() {
    return expect(Kefir.fromPromise(inProgress)).toEmitInTime([]);
  });
  it('... with fulfilledSync property', function() {
    return expect(Kefir.fromPromise(fulfilledSync)).toEmit([
      {
        current: 1
      }, '<end:current>'
    ]);
  });
  it('... with failedSync property', function() {
    return expect(Kefir.fromPromise(failedSync)).toEmit([
      {
        currentError: 1
      }, '<end:current>'
    ]);
  });
  it('... with fulfilledAsync property', function() {
    var a;
    a = Kefir.fromPromise(fulfilledAsync);
    expect(a).toEmitInTime([[1000, 1], [1000, '<end>']]);
    return expect(a).toEmit([
      {
        current: 1
      }, '<end:current>'
    ]);
  });
  return it('... with failedAsync property', function() {
    var a;
    a = Kefir.fromPromise(failedAsync);
    expect(a).toEmitInTime([
      [
        1000, {
          error: 1
        }
      ], [1000, '<end>']
    ]);
    return expect(a).toEmit([
      {
        currentError: 1
      }, '<end:current>'
    ]);
  });
});


},{"../test-helpers.coffee":249}],211:[function(require,module,exports){
var Kefir, prop, ref, send, stream;

ref = require('../test-helpers.coffee'), stream = ref.stream, prop = ref.prop, send = ref.send, Kefir = ref.Kefir;

describe('ignoreEnd', function() {
  describe('stream', function() {
    it('should return stream', function() {
      return expect(stream().ignoreEnd()).toBeStream();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = stream();
      return expect(a.ignoreEnd()).toActivate(a);
    });
    it('should not be ended if source was ended', function() {
      return expect(send(stream(), ['<end>']).ignoreEnd()).toEmit([]);
    });
    it('should handle events', function() {
      var a;
      a = stream();
      return expect(a.ignoreEnd()).toEmit([1, 2], function() {
        return send(a, [1, 2, '<end>']);
      });
    });
    return it('errors should flow', function() {
      var a;
      a = stream();
      return expect(a.ignoreEnd()).errorsToFlow(a);
    });
  });
  return describe('property', function() {
    it('should return property', function() {
      return expect(prop().ignoreEnd()).toBeProperty();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = prop();
      return expect(a.ignoreEnd()).toActivate(a);
    });
    it('should not be ended if source was ended', function() {
      expect(send(prop(), ['<end>']).ignoreEnd()).toEmit([]);
      return expect(send(prop(), [1, '<end>']).ignoreEnd()).toEmit([
        {
          current: 1
        }
      ]);
    });
    it('should handle events and current', function() {
      var a;
      a = send(prop(), [1]);
      return expect(a.ignoreEnd()).toEmit([
        {
          current: 1
        }, 2, 3
      ], function() {
        return send(a, [2, 3, '<end>']);
      });
    });
    return it('errors should flow', function() {
      var a;
      a = prop();
      return expect(a.ignoreEnd()).errorsToFlow(a);
    });
  });
});


},{"../test-helpers.coffee":249}],212:[function(require,module,exports){
var Kefir, prop, ref, send, stream;

ref = require('../test-helpers.coffee'), stream = ref.stream, prop = ref.prop, send = ref.send, Kefir = ref.Kefir;

describe('ignoreErrors', function() {
  describe('stream', function() {
    it('should return stream', function() {
      return expect(stream().ignoreErrors()).toBeStream();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = stream();
      return expect(a.ignoreErrors()).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(stream(), ['<end>']).ignoreErrors()).toEmit(['<end:current>']);
    });
    return it('should handle events', function() {
      var a;
      a = stream();
      return expect(a.ignoreErrors()).toEmit([1, 2, '<end>'], function() {
        return send(a, [
          1, {
            error: -1
          }, 2, {
            error: -2
          }, '<end>'
        ]);
      });
    });
  });
  return describe('property', function() {
    it('should return property', function() {
      return expect(prop().ignoreErrors()).toBeProperty();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = prop();
      return expect(a.ignoreErrors()).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(prop(), ['<end>']).ignoreErrors()).toEmit(['<end:current>']);
    });
    return it('should handle events and current', function() {
      var a;
      a = send(prop(), [
        {
          error: -1
        }
      ]);
      expect(a.ignoreErrors()).toEmit([2, 3, '<end>'], function() {
        return send(a, [
          2, {
            error: -2
          }, 3, {
            error: -3
          }, '<end>'
        ]);
      });
      a = send(prop(), [1]);
      return expect(a.ignoreErrors()).toEmit([
        {
          current: 1
        }, 2, 3, '<end>'
      ], function() {
        return send(a, [
          2, {
            error: -2
          }, 3, {
            error: -3
          }, '<end>'
        ]);
      });
    });
  });
});


},{"../test-helpers.coffee":249}],213:[function(require,module,exports){
var Kefir, prop, ref, send, stream;

ref = require('../test-helpers.coffee'), stream = ref.stream, prop = ref.prop, send = ref.send, Kefir = ref.Kefir;

describe('ignoreValues', function() {
  describe('stream', function() {
    it('should return stream', function() {
      return expect(stream().ignoreValues()).toBeStream();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = stream();
      return expect(a.ignoreValues()).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(stream(), ['<end>']).ignoreValues()).toEmit(['<end:current>']);
    });
    return it('should handle events', function() {
      var a;
      a = stream();
      return expect(a.ignoreValues()).toEmit([
        {
          error: -1
        }, {
          error: -2
        }, '<end>'
      ], function() {
        return send(a, [
          1, {
            error: -1
          }, 2, {
            error: -2
          }, '<end>'
        ]);
      });
    });
  });
  return describe('property', function() {
    it('should return property', function() {
      return expect(prop().ignoreValues()).toBeProperty();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = prop();
      return expect(a.ignoreValues()).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(prop(), ['<end>']).ignoreValues()).toEmit(['<end:current>']);
    });
    return it('should handle events and current', function() {
      var a;
      a = send(prop(), [
        1, {
          error: -1
        }
      ]);
      return expect(a.ignoreValues()).toEmit([
        {
          currentError: -1
        }, {
          error: -2
        }, {
          error: -3
        }, '<end>'
      ], function() {
        return send(a, [
          2, {
            error: -2
          }, 3, {
            error: -3
          }, '<end>'
        ]);
      });
    });
  });
});


},{"../test-helpers.coffee":249}],214:[function(require,module,exports){
var Kefir;

Kefir = require('../../dist/kefir');

describe('interval', function() {
  it('should return stream', function() {
    return expect(Kefir.interval(100, 1)).toBeStream();
  });
  return it('should repeat same value at certain time', function() {
    return expect(Kefir.interval(100, 1)).toEmitInTime([[100, 1], [200, 1], [300, 1]], null, 350);
  });
});


},{"../../dist/kefir":1}],215:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _require = require('../test-helpers.coffee');

var Kefir = _require.Kefir;


describe('Kefir.Observable', function () {
  describe('observe', function () {
    var em = void 0,
        count = void 0,
        obs = void 0,
        sub = void 0;

    beforeEach(function () {
      em = null;
      count = 0;
      obs = Kefir.stream(function (_em) {
        em = _em;
      });
      sub = obs.observe({ value: function value() {
          return count++;
        }, error: function error() {
          return count--;
        }, end: function end() {
          return count = 0;
        } });
    });

    it('should return a Subscription', function () {
      expect(sub.closed).toBe(false);
      expect(_typeof(sub.unsubscribe)).toBe('function');
    });

    it('should call Observer methods', function () {
      expect(count).toBe(0);

      em.emit(1);
      expect(count).toBe(1);

      em.emit(1);
      expect(count).toBe(2);

      em.error(1);
      expect(count).toBe(1);

      em.end();
      expect(count).toBe(0);
      expect(sub.closed).toBe(true);
    });

    it('should unsubcribe early', function () {
      expect(count).toBe(0);

      em.emit(1);
      expect(count).toBe(1);

      sub.unsubscribe();

      em.emit(1);
      expect(count).toBe(1);
      expect(sub.closed).toBe(true);
    });

    it('closed=true after end (w/o end handler)', function () {
      obs = Kefir.stream(function (_em) {
        em = _em;
      });
      sub = obs.observe(function () {});
      em.end();
      expect(sub.closed).toBe(true);
    });
  });
});

},{"../test-helpers.coffee":249}],216:[function(require,module,exports){
var Kefir, activate, deactivate, ref;

ref = require('../test-helpers.coffee'), activate = ref.activate, deactivate = ref.deactivate, Kefir = ref.Kefir;

describe('Kefir.stream', function() {
  it('should return stream', function() {
    return expect(Kefir.stream(function() {})).toBeStream();
  });
  it('should not be ended', function() {
    return expect(Kefir.stream(function() {})).toEmit([]);
  });
  it('should emit values, errors, and end', function() {
    var a, emitter;
    emitter = null;
    a = Kefir.stream(function(em) {
      emitter = em;
      return null;
    });
    return expect(a).toEmit([
      1, 2, {
        error: -1
      }, 3, '<end>'
    ], function() {
      emitter.value(1);
      emitter.value(2);
      emitter.error(-1);
      emitter.value(3);
      return emitter.end();
    });
  });
  it('should call `subscribe` / `unsubscribe` on activation / deactivation', function() {
    var a, subCount, unsubCount;
    subCount = 0;
    unsubCount = 0;
    a = Kefir.stream(function() {
      subCount++;
      return function() {
        return unsubCount++;
      };
    });
    expect(subCount).toBe(0);
    expect(unsubCount).toBe(0);
    activate(a);
    expect(subCount).toBe(1);
    activate(a);
    expect(subCount).toBe(1);
    deactivate(a);
    expect(unsubCount).toBe(0);
    deactivate(a);
    expect(unsubCount).toBe(1);
    expect(subCount).toBe(1);
    activate(a);
    expect(subCount).toBe(2);
    expect(unsubCount).toBe(1);
    deactivate(a);
    return expect(unsubCount).toBe(2);
  });
  it('should automatically controll isCurent argument in `send`', function() {
    expect(Kefir.stream(function(emitter) {
      emitter.end();
      return null;
    })).toEmit(['<end:current>']);
    return expect(Kefir.stream(function(emitter) {
      emitter.value(1);
      emitter.error(-1);
      emitter.value(2);
      setTimeout(function() {
        emitter.value(2);
        return emitter.end();
      }, 1000);
      return null;
    })).toEmitInTime([
      [
        0, {
          current: 1
        }
      ], [
        0, {
          currentError: -1
        }
      ], [
        0, {
          current: 2
        }
      ], [1000, 2], [1000, '<end>']
    ]);
  });
  it('should support emitter.event', function() {
    return expect(Kefir.stream(function(emitter) {
      emitter.event({
        type: 'value',
        value: 1,
        current: true
      });
      emitter.event({
        type: 'error',
        value: -1,
        current: false
      });
      emitter.event({
        type: 'value',
        value: 2,
        current: false
      });
      setTimeout(function() {
        emitter.event({
          type: 'value',
          value: 3,
          current: true
        });
        emitter.event({
          type: 'value',
          value: 4,
          current: false
        });
        return emitter.event({
          type: 'end',
          value: void 0,
          current: false
        });
      }, 1000);
      return null;
    })).toEmitInTime([
      [
        0, {
          current: 1
        }
      ], [
        0, {
          currentError: -1
        }
      ], [
        0, {
          current: 2
        }
      ], [1000, 3], [1000, 4], [1000, '<end>']
    ]);
  });
  it('should work with .take(1) and sync emit', function() {
    var a, log;
    log = [];
    a = Kefir.stream(function(emitter) {
      var logRecord;
      logRecord = {
        sub: 1,
        unsub: 0
      };
      log.push(logRecord);
      emitter.value(1);
      return function() {
        return logRecord.unsub++;
      };
    });
    a.take(1).onValue(function() {});
    a.take(1).onValue(function() {});
    return expect(log).toEqual([
      {
        sub: 1,
        unsub: 1
      }, {
        sub: 1,
        unsub: 1
      }
    ]);
  });
  it('should not throw if not falsey but not a function returned', function() {
    return expect(Kefir.stream(function() {
      return true;
    })).toEmit([]);
  });
  it('emitter should return a boolean representing if anyone intrested in future events', function() {
    var a, emitter, f, lastX;
    emitter = null;
    a = Kefir.stream(function(em) {
      return emitter = em;
    });
    activate(a);
    expect(emitter.value(1)).toBe(true);
    deactivate(a);
    expect(emitter.value(1)).toBe(false);
    a = Kefir.stream(function(em) {
      expect(em.value(1)).toBe(true);
      expect(em.value(2)).toBe(false);
      return expect(em.value(3)).toBe(false);
    });
    lastX = null;
    f = function(x) {
      lastX = x;
      if (x === 2) {
        return a.offValue(f);
      }
    };
    a.onValue(f);
    return expect(lastX).toBe(2);
  });
  return it('calling emitter.end() in undubscribe() should work fine', function() {
    var em, s;
    em = null;
    s = Kefir.stream(function(_em) {
      em = _em;
      return function() {
        return em.end();
      };
    });
    s.onValue(function() {});
    em.value(1);
    return em.end();
  });
});


},{"../test-helpers.coffee":249}],217:[function(require,module,exports){
var Kefir, prop, ref, send, stream;

ref = require('../test-helpers.coffee'), stream = ref.stream, prop = ref.prop, send = ref.send, Kefir = ref.Kefir;

describe('last', function() {
  describe('stream', function() {
    it('should return stream', function() {
      return expect(stream().last()).toBeStream();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = stream();
      return expect(a.last()).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(stream(), ['<end>']).last()).toEmit(['<end:current>']);
    });
    return it('should handle events', function() {
      var a;
      a = stream();
      return expect(a.last()).toEmit([
        {
          error: 5
        }, {
          error: 6
        }, 3, '<end>'
      ], function() {
        return send(a, [
          1, {
            error: 5
          }, {
            error: 6
          }, 2, 3, '<end>'
        ]);
      });
    });
  });
  return describe('property', function() {
    it('should return property', function() {
      return expect(prop().last()).toBeProperty();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = prop();
      return expect(a.last()).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      expect(send(prop(), ['<end>']).last()).toEmit(['<end:current>']);
      return expect(send(prop(), [1, '<end>']).last()).toEmit([
        {
          current: 1
        }, '<end:current>'
      ]);
    });
    return it('should handle events and current', function() {
      var a;
      a = send(prop(), [1]);
      expect(a.last()).toEmit([
        {
          error: 5
        }, 1, '<end>'
      ], function() {
        return send(a, [
          {
            error: 5
          }, '<end>'
        ]);
      });
      a = send(prop(), [
        {
          error: 0
        }
      ]);
      return expect(a.last()).toEmit([
        {
          currentError: 0
        }, {
          error: 5
        }, 3, '<end>'
      ], function() {
        return send(a, [
          2, {
            error: 5
          }, 3, '<end>'
        ]);
      });
    });
  });
});


},{"../test-helpers.coffee":249}],218:[function(require,module,exports){
var Kefir;

Kefir = require('../../dist/kefir');

describe('later', function() {
  it('should return stream', function() {
    return expect(Kefir.later(100, 1)).toBeStream();
  });
  return it('should emmit value after interval then end', function() {
    return expect(Kefir.later(100, 1)).toEmitInTime([[100, 1], [100, '<end>']]);
  });
});


},{"../../dist/kefir":1}],219:[function(require,module,exports){
var Kefir, prop, ref, send, stream;

ref = require('../test-helpers.coffee'), stream = ref.stream, prop = ref.prop, send = ref.send, Kefir = ref.Kefir;

describe('mapErrors', function() {
  describe('stream', function() {
    it('should return stream', function() {
      return expect(stream().mapErrors(function() {})).toBeStream();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = stream();
      return expect(a.mapErrors(function() {})).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(stream(), ['<end>']).mapErrors(function() {})).toEmit(['<end:current>']);
    });
    return it('should handle events', function() {
      var a;
      a = stream();
      return expect(a.mapErrors(function(x) {
        return x * 2;
      })).toEmit([
        1, {
          error: -2
        }, 2, {
          error: -4
        }, '<end>'
      ], function() {
        return send(a, [
          1, {
            error: -1
          }, 2, {
            error: -2
          }, '<end>'
        ]);
      });
    });
  });
  return describe('property', function() {
    it('should return property', function() {
      return expect(prop().mapErrors(function() {})).toBeProperty();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = prop();
      return expect(a.mapErrors(function() {})).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(prop(), ['<end>']).mapErrors(function() {})).toEmit(['<end:current>']);
    });
    return it('should handle events and current', function() {
      var a;
      a = send(prop(), [1]);
      expect(a.mapErrors(function(x) {
        return x * 2;
      })).toEmit([
        {
          current: 1
        }, 2, {
          error: -4
        }, 3, {
          error: -6
        }, '<end>'
      ], function() {
        return send(a, [
          2, {
            error: -2
          }, 3, {
            error: -3
          }, '<end>'
        ]);
      });
      a = send(prop(), [
        {
          error: -1
        }
      ]);
      return expect(a.mapErrors(function(x) {
        return x * 2;
      })).toEmit([
        {
          currentError: -2
        }, 2, {
          error: -4
        }, 3, {
          error: -6
        }, '<end>'
      ], function() {
        return send(a, [
          2, {
            error: -2
          }, 3, {
            error: -3
          }, '<end>'
        ]);
      });
    });
  });
});


},{"../test-helpers.coffee":249}],220:[function(require,module,exports){
var Kefir, prop, ref, send, stream;

ref = require('../test-helpers.coffee'), stream = ref.stream, prop = ref.prop, send = ref.send, Kefir = ref.Kefir;

describe('map', function() {
  describe('stream', function() {
    it('should return stream', function() {
      return expect(stream().map(function() {})).toBeStream();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = stream();
      return expect(a.map(function() {})).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(stream(), ['<end>']).map(function() {})).toEmit(['<end:current>']);
    });
    it('should handle events', function() {
      var a;
      a = stream();
      return expect(a.map(function(x) {
        return x * 2;
      })).toEmit([
        2, {
          error: 5
        }, 4, '<end>'
      ], function() {
        return send(a, [
          1, {
            error: 5
          }, 2, '<end>'
        ]);
      });
    });
    return it('should work with default `fn`', function() {
      var a;
      a = stream();
      return expect(a.map()).toEmit([
        1, {
          error: 5
        }, 2, '<end>'
      ], function() {
        return send(a, [
          1, {
            error: 5
          }, 2, '<end>'
        ]);
      });
    });
  });
  return describe('property', function() {
    it('should return property', function() {
      return expect(prop().map(function() {})).toBeProperty();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = prop();
      return expect(a.map(function() {})).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(prop(), ['<end>']).map(function() {})).toEmit(['<end:current>']);
    });
    return it('should handle events and current', function() {
      var a;
      a = send(prop(), [1]);
      expect(a.map(function(x) {
        return x * 2;
      })).toEmit([
        {
          current: 2
        }, 4, {
          error: 5
        }, 6, '<end>'
      ], function() {
        return send(a, [
          2, {
            error: 5
          }, 3, '<end>'
        ]);
      });
      a = send(prop(), [
        {
          error: 0
        }
      ]);
      return expect(a.map(function(x) {
        return x * 2;
      })).toEmit([
        {
          currentError: 0
        }, 4, {
          error: 5
        }, 6, '<end>'
      ], function() {
        return send(a, [
          2, {
            error: 5
          }, 3, '<end>'
        ]);
      });
    });
  });
});


},{"../test-helpers.coffee":249}],221:[function(require,module,exports){
var Kefir, activate, deactivate, prop, ref, send, stream;

ref = require('../test-helpers.coffee'), stream = ref.stream, prop = ref.prop, send = ref.send, activate = ref.activate, deactivate = ref.deactivate, Kefir = ref.Kefir;

describe('merge', function() {
  it('should return stream', function() {
    expect(Kefir.merge([])).toBeStream();
    expect(Kefir.merge([stream(), prop()])).toBeStream();
    expect(stream().merge(stream())).toBeStream();
    return expect(prop().merge(prop())).toBeStream();
  });
  it('should be ended if empty array provided', function() {
    return expect(Kefir.merge([])).toEmit(['<end:current>']);
  });
  it('should be ended if array of ended observables provided', function() {
    var a, b, c;
    a = send(stream(), ['<end>']);
    b = send(prop(), ['<end>']);
    c = send(stream(), ['<end>']);
    expect(Kefir.merge([a, b, c])).toEmit(['<end:current>']);
    return expect(a.merge(b)).toEmit(['<end:current>']);
  });
  it('should activate sources', function() {
    var a, b, c;
    a = stream();
    b = prop();
    c = stream();
    expect(Kefir.merge([a, b, c])).toActivate(a, b, c);
    return expect(a.merge(b)).toActivate(a, b);
  });
  it('should deliver events from observables, then end when all of them end', function() {
    var a, b, c;
    a = stream();
    b = send(prop(), [0]);
    c = stream();
    expect(Kefir.merge([a, b, c])).toEmit([
      {
        current: 0
      }, 1, 2, 3, 4, 5, 6, '<end>'
    ], function() {
      send(a, [1]);
      send(b, [2]);
      send(c, [3]);
      send(a, ['<end>']);
      send(b, [4, '<end>']);
      return send(c, [5, 6, '<end>']);
    });
    a = stream();
    b = send(prop(), [0]);
    return expect(a.merge(b)).toEmit([
      {
        current: 0
      }, 1, 2, 3, '<end>'
    ], function() {
      send(a, [1]);
      send(b, [2]);
      send(a, ['<end>']);
      return send(b, [3, '<end>']);
    });
  });
  it('should deliver currents from all source properties, but only to first subscriber on each activation', function() {
    var a, b, c, merge;
    a = send(prop(), [0]);
    b = send(prop(), [1]);
    c = send(prop(), [2]);
    merge = Kefir.merge([a, b, c]);
    expect(merge).toEmit([
      {
        current: 0
      }, {
        current: 1
      }, {
        current: 2
      }
    ]);
    merge = Kefir.merge([a, b, c]);
    activate(merge);
    expect(merge).toEmit([]);
    merge = Kefir.merge([a, b, c]);
    activate(merge);
    deactivate(merge);
    return expect(merge).toEmit([
      {
        current: 0
      }, {
        current: 1
      }, {
        current: 2
      }
    ]);
  });
  it('errors should flow', function() {
    var a, b, c;
    a = stream();
    b = prop();
    c = stream();
    expect(Kefir.merge([a, b, c])).errorsToFlow(a);
    a = stream();
    b = prop();
    c = stream();
    expect(Kefir.merge([a, b, c])).errorsToFlow(b);
    a = stream();
    b = prop();
    c = stream();
    return expect(Kefir.merge([a, b, c])).errorsToFlow(c);
  });
  return it('should work correctly when unsuscribing after one sync event', function() {
    var a, b, c;
    a = Kefir.constant(1);
    b = Kefir.interval(1000, 1);
    c = a.merge(b);
    activate(c.take(1));
    return expect(b).not.toBeActive();
  });
});


},{"../test-helpers.coffee":249}],222:[function(require,module,exports){
var Kefir;

Kefir = require('../../dist/kefir');

describe('never', function() {
  it('should return stream', function() {
    return expect(Kefir.never()).toBeStream();
  });
  return it('should be ended', function() {
    return expect(Kefir.never()).toEmit(['<end:current>']);
  });
});


},{"../../dist/kefir":1}],223:[function(require,module,exports){
var Kefir, activate, deactivate, prop, ref, send, stream;

ref = require('../test-helpers.coffee'), stream = ref.stream, prop = ref.prop, send = ref.send, activate = ref.activate, deactivate = ref.deactivate, Kefir = ref.Kefir;

describe('pool', function() {
  it('should return stream', function() {
    expect(Kefir.pool()).toBeStream();
    return expect(new Kefir.Pool()).toBeStream();
  });
  it('should return pool', function() {
    expect(Kefir.pool()).toBePool();
    return expect(new Kefir.Pool()).toBePool();
  });
  it('should activate sources', function() {
    var a, b, c, pool;
    a = stream();
    b = prop();
    c = stream();
    pool = Kefir.pool().plug(a).plug(b).plug(c);
    expect(pool).toActivate(a, b, c);
    pool.unplug(b);
    expect(pool).toActivate(a, c);
    return expect(pool).not.toActivate(b);
  });
  it('should deliver events from observables', function() {
    var a, b, c, pool;
    a = stream();
    b = send(prop(), [0]);
    c = stream();
    pool = Kefir.pool().plug(a).plug(b).plug(c);
    return expect(pool).toEmit([
      {
        current: 0
      }, 1, 2, 3, 4, 5, 6
    ], function() {
      send(a, [1]);
      send(b, [2]);
      send(c, [3]);
      send(a, ['<end>']);
      send(b, [4, '<end>']);
      return send(c, [5, 6, '<end>']);
    });
  });
  it('should deliver currents from all source properties, but only to first subscriber on each activation', function() {
    var a, b, c, pool;
    a = send(prop(), [0]);
    b = send(prop(), [1]);
    c = send(prop(), [2]);
    pool = Kefir.pool().plug(a).plug(b).plug(c);
    expect(pool).toEmit([
      {
        current: 0
      }, {
        current: 1
      }, {
        current: 2
      }
    ]);
    pool = Kefir.pool().plug(a).plug(b).plug(c);
    activate(pool);
    expect(pool).toEmit([]);
    pool = Kefir.pool().plug(a).plug(b).plug(c);
    activate(pool);
    deactivate(pool);
    return expect(pool).toEmit([
      {
        current: 0
      }, {
        current: 1
      }, {
        current: 2
      }
    ]);
  });
  it('should not deliver events from removed sources', function() {
    var a, b, c, pool;
    a = stream();
    b = send(prop(), [0]);
    c = stream();
    pool = Kefir.pool().plug(a).plug(b).plug(c).unplug(b);
    return expect(pool).toEmit([1, 3, 5, 6], function() {
      send(a, [1]);
      send(b, [2]);
      send(c, [3]);
      send(a, ['<end>']);
      send(b, [4, '<end>']);
      return send(c, [5, 6, '<end>']);
    });
  });
  it('should correctly handle current values of new sub sources', function() {
    var b, c, pool;
    pool = Kefir.pool();
    b = send(prop(), [1]);
    c = send(prop(), [2]);
    return expect(pool).toEmit([1, 2], function() {
      pool.plug(b);
      return pool.plug(c);
    });
  });
  return it('errors should flow', function() {
    var a, b, c, pool;
    a = stream();
    b = prop();
    c = stream();
    pool = Kefir.pool();
    pool.plug(a);
    expect(pool).errorsToFlow(a);
    pool.unplug(a);
    expect(pool).not.errorsToFlow(a);
    pool.plug(a);
    pool.plug(b);
    expect(pool).errorsToFlow(a);
    expect(pool).errorsToFlow(b);
    pool.unplug(b);
    expect(pool).not.errorsToFlow(b);
    pool.plug(c);
    return expect(pool).errorsToFlow(c);
  });
});


},{"../test-helpers.coffee":249}],224:[function(require,module,exports){
var Kefir, activate, prop, ref, send, sinon;

ref = require('../test-helpers.coffee'), prop = ref.prop, send = ref.send, activate = ref.activate, Kefir = ref.Kefir;

sinon = require('sinon');

describe('Property', function() {
  describe('new', function() {
    it('should create a Property', function() {
      expect(prop()).toBeProperty();
      return expect(new Kefir.Property()).toBeProperty();
    });
    it('should not be ended', function() {
      return expect(prop()).toEmit([]);
    });
    return it('should not be active', function() {
      return expect(prop()).not.toBeActive();
    });
  });
  describe('end', function() {
    it('should end when `end` sent', function() {
      var s;
      s = prop();
      return expect(s).toEmit(['<end>'], function() {
        return send(s, ['<end>']);
      });
    });
    it('should call `end` subscribers', function() {
      var log, s;
      s = prop();
      log = [];
      s.onEnd(function() {
        return log.push(1);
      });
      s.onEnd(function() {
        return log.push(2);
      });
      expect(log).toEqual([]);
      send(s, ['<end>']);
      return expect(log).toEqual([1, 2]);
    });
    it('should call `end` subscribers on already ended property', function() {
      var log, s;
      s = prop();
      send(s, ['<end>']);
      log = [];
      s.onEnd(function() {
        return log.push(1);
      });
      s.onEnd(function() {
        return log.push(2);
      });
      return expect(log).toEqual([1, 2]);
    });
    it('should deactivate on end', function() {
      var s;
      s = prop();
      activate(s);
      expect(s).toBeActive();
      send(s, ['<end>']);
      return expect(s).not.toBeActive();
    });
    it('should stop deliver new values after end', function() {
      var s;
      s = prop();
      return expect(s).toEmit([1, 2, '<end>'], function() {
        return send(s, [1, 2, '<end>', 3]);
      });
    });
    it('calling ._emitEnd twice should work fine', function() {
      var e, err, error, s;
      err = void 0;
      try {
        s = prop();
        s._emitEnd();
        s._emitEnd();
      } catch (error) {
        e = error;
        err = e;
      }
      return expect(err && err.message).toBe(void 0);
    });
    return it('calling ._emitEnd in an end handler should work fine', function() {
      var e, err, error, s;
      err = void 0;
      try {
        s = prop();
        s.onEnd(function() {
          return s._emitEnd();
        });
        s._emitEnd();
      } catch (error) {
        e = error;
        err = e;
      }
      return expect(err && err.message).toBe(void 0);
    });
  });
  describe('active state', function() {
    it('should activate when first subscriber added (value)', function() {
      var s;
      s = prop();
      s.onValue(function() {});
      return expect(s).toBeActive();
    });
    it('should activate when first subscriber added (error)', function() {
      var s;
      s = prop();
      s.onError(function() {});
      return expect(s).toBeActive();
    });
    it('should activate when first subscriber added (end)', function() {
      var s;
      s = prop();
      s.onEnd(function() {});
      return expect(s).toBeActive();
    });
    it('should activate when first subscriber added (any)', function() {
      var s;
      s = prop();
      s.onAny(function() {});
      return expect(s).toBeActive();
    });
    return it('should deactivate when all subscribers removed', function() {
      var any1, any2, end1, end2, s, value1, value2;
      s = prop();
      s.onAny((any1 = function() {}));
      s.onAny((any2 = function() {}));
      s.onValue((value1 = function() {}));
      s.onValue((value2 = function() {}));
      s.onEnd((end1 = function() {}));
      s.onEnd((end2 = function() {}));
      s.offValue(value1);
      s.offValue(value2);
      s.offAny(any1);
      s.offAny(any2);
      s.offEnd(end1);
      expect(s).toBeActive();
      s.offEnd(end2);
      return expect(s).not.toBeActive();
    });
  });
  return describe('subscribers', function() {
    it('should deliver values and current', function() {
      var s;
      s = send(prop(), [0]);
      return expect(s).toEmit([
        {
          current: 0
        }, 1, 2
      ], function() {
        return send(s, [1, 2]);
      });
    });
    it('should deliver errors and current error', function() {
      var s;
      s = send(prop(), [
        {
          error: 0
        }
      ]);
      return expect(s).toEmit([
        {
          currentError: 0
        }, {
          error: 1
        }, {
          error: 2
        }
      ], function() {
        return send(s, [
          {
            error: 1
          }, {
            error: 2
          }
        ]);
      });
    });
    it('onValue subscribers should be called with 1 argument', function() {
      var count, s;
      s = send(prop(), [0]);
      count = null;
      s.onValue(function() {
        return count = arguments.length;
      });
      expect(count).toBe(1);
      send(s, [1]);
      return expect(count).toBe(1);
    });
    it('onError subscribers should be called with 1 argument', function() {
      var count, s;
      s = send(prop(), [
        {
          error: 0
        }
      ]);
      count = null;
      s.onError(function() {
        return count = arguments.length;
      });
      expect(count).toBe(1);
      send(s, [
        {
          error: 1
        }
      ]);
      return expect(count).toBe(1);
    });
    it('onAny subscribers should be called with 1 arguments', function() {
      var count, s;
      s = send(prop(), [0]);
      count = null;
      s.onAny(function() {
        return count = arguments.length;
      });
      expect(count).toBe(1);
      send(s, [1]);
      return expect(count).toBe(1);
    });
    it('onEnd subscribers should be called with 0 arguments', function() {
      var count, s;
      s = send(prop(), [0]);
      count = null;
      s.onEnd(function() {
        return count = arguments.length;
      });
      send(s, ['<end>']);
      expect(count).toBe(0);
      s.onEnd(function() {
        return count = arguments.length;
      });
      return expect(count).toBe(0);
    });
    it('can\'t have current value and error at same time', function() {
      var p;
      p = send(prop(), [0]);
      expect(p).toEmit([
        {
          current: 0
        }
      ]);
      send(p, [
        {
          error: 1
        }
      ]);
      expect(p).toEmit([
        {
          currentError: 1
        }
      ]);
      send(p, [2]);
      return expect(p).toEmit([
        {
          current: 2
        }
      ]);
    });
    it('should update catched current value before dispatching it', function() {
      var p, spy;
      p = send(prop(), [0]);
      spy = sinon.spy();
      p.onValue(function(x) {
        if (x === 1) {
          return p.onValue(spy);
        }
      });
      send(p, [1]);
      return expect(spy.args).toEqual([[1]]);
    });
    return it('should update catched current error before dispatching it', function() {
      var p, spy;
      p = send(prop(), [
        {
          error: 0
        }
      ]);
      spy = sinon.spy();
      p.onError(function(x) {
        if (x === 1) {
          return p.onError(spy);
        }
      });
      send(p, [
        {
          error: 1
        }
      ]);
      return expect(spy.args).toEqual([[1]]);
    });
  });
});


},{"../test-helpers.coffee":249,"sinon":144}],225:[function(require,module,exports){
var Kefir, activate, deactivate, prop, ref, send, stream;

ref = require('../test-helpers.coffee'), stream = ref.stream, prop = ref.prop, send = ref.send, activate = ref.activate, deactivate = ref.deactivate, Kefir = ref.Kefir;

describe('repeat', function() {
  it('should return stream', function() {
    return expect(Kefir.repeat()).toBeStream();
  });
  it('should work correctly (with .constant)', function() {
    var a;
    a = Kefir.repeat(function(i) {
      return Kefir[i === 2 ? 'constantError' : 'constant'](i);
    });
    return expect(a.take(3)).toEmit([
      {
        current: 0
      }, {
        current: 1
      }, {
        currentError: 2
      }, {
        current: 3
      }, '<end:current>'
    ]);
  });
  it('should work correctly (with .later)', function() {
    var a;
    a = Kefir.repeat(function(i) {
      return Kefir.later(100, i);
    });
    return expect(a.take(3)).toEmitInTime([[100, 0], [200, 1], [300, 2], [300, '<end>']]);
  });
  it('should work correctly (with .sequentially)', function() {
    var a;
    a = Kefir.repeat(function(i) {
      return Kefir.sequentially(100, [1, 2, 3]);
    });
    return expect(a.take(5)).toEmitInTime([[100, 1], [200, 2], [300, 3], [400, 1], [500, 2], [500, '<end>']]);
  });
  it('should not cause stack overflow', function() {
    var a, genConstant, sum;
    sum = function(a, b) {
      return a + b;
    };
    genConstant = function() {
      return Kefir.constant(1);
    };
    a = Kefir.repeat(genConstant).take(3000).scan(sum, 0).last();
    return expect(a).toEmit([
      {
        current: 3000
      }, '<end:current>'
    ]);
  });
  it('should get new source only if previous one ended', function() {
    var a, b, callsCount;
    a = stream();
    callsCount = 0;
    b = Kefir.repeat(function() {
      callsCount++;
      if (!a._alive) {
        a = stream();
      }
      return a;
    });
    expect(callsCount).toBe(0);
    activate(b);
    expect(callsCount).toBe(1);
    deactivate(b);
    activate(b);
    expect(callsCount).toBe(1);
    send(a, ['<end>']);
    return expect(callsCount).toBe(2);
  });
  it('should unsubscribe from source', function() {
    var a, b;
    a = stream();
    b = Kefir.repeat(function() {
      return a;
    });
    return expect(b).toActivate(a);
  });
  return it('should end when falsy value returned from generator', function() {
    var a;
    a = Kefir.repeat(function(i) {
      if (i < 3) {
        return Kefir.constant(i);
      } else {
        return false;
      }
    });
    return expect(a).toEmit([
      {
        current: 0
      }, {
        current: 1
      }, {
        current: 2
      }, '<end:current>'
    ]);
  });
});


},{"../test-helpers.coffee":249}],226:[function(require,module,exports){
var Kefir, activate, deactivate, prop, ref, send, stream,
  slice = [].slice;

ref = require('../test-helpers.coffee'), stream = ref.stream, prop = ref.prop, send = ref.send, activate = ref.activate, deactivate = ref.deactivate, Kefir = ref.Kefir;

describe('sampledBy', function() {
  it('should return stream', function() {
    expect(prop().sampledBy(stream())).toBeStream();
    return expect(stream().sampledBy(prop())).toBeStream();
  });
  it('should be ended if array of ended observables provided', function() {
    var a;
    a = send(stream(), ['<end>']);
    return expect(prop().sampledBy(a)).toEmit(['<end:current>']);
  });
  it('should be ended and emmit current (once) if array of ended properties provided and each of them has current', function() {
    var a, b, s2;
    a = send(prop(), [1, '<end>']);
    b = send(prop(), [2, '<end>']);
    s2 = a.sampledBy(b);
    expect(s2).toEmit([
      {
        current: 1
      }, '<end:current>'
    ]);
    return expect(s2).toEmit(['<end:current>']);
  });
  it('should activate sources', function() {
    var a, b;
    a = stream();
    b = prop();
    return expect(a.sampledBy(b)).toActivate(a, b);
  });
  it('should handle events and current from observables', function() {
    var a, b;
    a = stream();
    b = send(prop(), [0]);
    return expect(a.sampledBy(b)).toEmit([2, 4, 4, '<end>'], function() {
      send(b, [1]);
      send(a, [2]);
      send(b, [3]);
      send(a, [4]);
      return send(b, [5, 6, '<end>']);
    });
  });
  it('should accept optional combinator function', function() {
    var a, b, join;
    join = function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return args.join('+');
    };
    a = stream();
    b = send(prop(), [0]);
    return expect(a.sampledBy(b, join)).toEmit(['2+3', '4+5', '4+6', '<end>'], function() {
      send(b, [1]);
      send(a, [2]);
      send(b, [3]);
      send(a, [4]);
      return send(b, [5, 6, '<end>']);
    });
  });
  it('one sampledBy should remove listeners of another', function() {
    var a, b, s1, s2;
    a = send(prop(), [0]);
    b = stream();
    s1 = a.sampledBy(b);
    s2 = a.sampledBy(b);
    activate(s1);
    activate(s2);
    deactivate(s2);
    return expect(s1).toEmit([0], function() {
      return send(b, [1]);
    });
  });
  return it('should work nice for emitating atomic updates', function() {
    var a, b, c;
    a = stream();
    b = a.map(function(x) {
      return x + 2;
    });
    c = a.map(function(x) {
      return x * 2;
    });
    return expect(b.sampledBy(c, function(x, y) {
      return [x, y];
    })).toEmit([[3, 2], [4, 4], [5, 6]], function() {
      return send(a, [1, 2, 3]);
    });
  });
});


},{"../test-helpers.coffee":249}],227:[function(require,module,exports){
var Kefir, activate, deactivate, minus, noop, prop, ref, send, sinon, stream;

ref = require('../test-helpers.coffee'), stream = ref.stream, prop = ref.prop, send = ref.send, Kefir = ref.Kefir, activate = ref.activate, deactivate = ref.deactivate;

sinon = require('sinon');

noop = function() {};

minus = function(prev, next) {
  return prev - next;
};

describe('scan', function() {
  describe('stream', function() {
    it('should return stream', function() {
      return expect(stream().scan(noop, 0)).toBeProperty();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = stream();
      return expect(a.scan(noop, 0)).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(stream(), ['<end>']).scan(noop, 0)).toEmit([
        {
          current: 0
        }, '<end:current>'
      ]);
    });
    it('should handle events', function() {
      var a;
      a = stream();
      return expect(a.scan(minus, 0)).toEmit([
        {
          current: 0
        }, -1, -4, '<end>'
      ], function() {
        return send(a, [1, 3, '<end>']);
      });
    });
    it('if no seed provided uses first value as seed', function() {
      var a;
      a = stream();
      return expect(a.scan(minus)).toEmit([0, -1, -4, '<end>'], function() {
        return send(a, [0, 1, 3, '<end>']);
      });
    });
    it('errors should flow', function() {
      var a;
      a = stream();
      return expect(a.scan(minus)).errorsToFlow(a);
    });
    it('should never pass a value as current result if seed specified (test with error)', function() {
      var a, b, handler;
      a = stream();
      handler = sinon.stub().returns('abc');
      b = a.scan(handler, 'seed');
      activate(b);
      send(a, [
        1, {
          error: 'err'
        }, 2, 3, '<end>'
      ]);
      deactivate(b);
      return expect(handler.args.filter(function(xs) {
        return typeof xs[0] === 'number';
      })).toEqual([]);
    });
    it('should fall back to the seed after error, if seed specified', function() {
      var a;
      a = stream();
      return expect(a.scan((function(res, x) {
        return res + x;
      }), 'seed')).toEmit([
        {
          current: 'seed'
        }, 'seed1', {
          error: 'err'
        }, 'seed2', 'seed23', '<end>'
      ], function() {
        return send(a, [
          1, {
            error: 'err'
          }, 2, 3, '<end>'
        ]);
      });
    });
    return it('should use next value after error as seed, if seed not specified', function() {
      var a;
      a = stream();
      return expect(a.scan(function() {
        return 'abc';
      })).toEmit([
        1, 'abc', {
          error: 'err'
        }, 3, 'abc', '<end>'
      ], function() {
        return send(a, [
          1, 2, {
            error: 'err'
          }, 3, 4, '<end>'
        ]);
      });
    });
  });
  return describe('property', function() {
    it('should return property', function() {
      return expect(prop().scan(noop, 0)).toBeProperty();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = prop();
      return expect(a.scan(noop, 0)).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(prop(), ['<end>']).scan(noop, 0)).toEmit([
        {
          current: 0
        }, '<end:current>'
      ]);
    });
    it('should handle events and current', function() {
      var a;
      a = send(prop(), [1]);
      return expect(a.scan(minus, 0)).toEmit([
        {
          current: -1
        }, -4, -10, '<end>'
      ], function() {
        return send(a, [3, 6, '<end>']);
      });
    });
    it('if no seed provided uses first value as seed', function() {
      var a;
      a = send(prop(), [0]);
      return expect(a.scan(minus)).toEmit([
        {
          current: 0
        }, -1, -4, '<end>'
      ], function() {
        return send(a, [1, 3, '<end>']);
      });
    });
    return it('errors should flow', function() {
      var a;
      a = prop();
      return expect(a.scan(minus)).errorsToFlow(a);
    });
  });
});


},{"../test-helpers.coffee":249,"sinon":144}],228:[function(require,module,exports){
var Kefir;

Kefir = require('../../dist/kefir');

describe('sequentially', function() {
  it('should return stream', function() {
    return expect(Kefir.sequentially(100, [1, 2, 3])).toBeStream();
  });
  it('should be ended if empty array provided', function() {
    return expect(Kefir.sequentially(100, [])).toEmitInTime([[0, '<end:current>']]);
  });
  return it('should emmit values at certain time then end', function() {
    return expect(Kefir.sequentially(100, [1, 2, 3])).toEmitInTime([[100, 1], [200, 2], [300, 3], [300, '<end>']]);
  });
});


},{"../../dist/kefir":1}],229:[function(require,module,exports){
var Kefir, prop, ref, send, stream;

ref = require('../test-helpers.coffee'), stream = ref.stream, prop = ref.prop, send = ref.send, Kefir = ref.Kefir;

describe('skipDuplicates', function() {
  var roundlyEqual;
  roundlyEqual = function(a, b) {
    return Math.round(a) === Math.round(b);
  };
  describe('stream', function() {
    it('should return stream', function() {
      return expect(stream().skipDuplicates()).toBeStream();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = stream();
      return expect(a.skipDuplicates()).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(stream(), ['<end>']).skipDuplicates()).toEmit(['<end:current>']);
    });
    it('should handle events (default comparator)', function() {
      var a;
      a = stream();
      return expect(a.skipDuplicates()).toEmit([1, 2, 3, '<end>'], function() {
        return send(a, [1, 1, 2, 3, 3, '<end>']);
      });
    });
    it('should handle events (custom comparator)', function() {
      var a;
      a = stream();
      return expect(a.skipDuplicates(roundlyEqual)).toEmit([1, 2, 3.8, '<end>'], function() {
        return send(a, [1, 1.1, 2, 3.8, 4, '<end>']);
      });
    });
    it('errors should flow', function() {
      var a;
      a = stream();
      return expect(a.skipDuplicates()).errorsToFlow(a);
    });
    return it('should help with creating circular dependencies', function() {
      var a, b;
      a = stream();
      b = Kefir.pool();
      b.plug(a);
      b.plug(b.map(function(x) {
        return x;
      }).skipDuplicates());
      return expect(b).toEmit([1, 1], function() {
        return send(a, [1]);
      });
    });
  });
  return describe('property', function() {
    it('should return property', function() {
      return expect(prop().skipDuplicates()).toBeProperty();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = prop();
      return expect(a.skipDuplicates()).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(prop(), ['<end>']).skipDuplicates()).toEmit(['<end:current>']);
    });
    it('should handle events and current (default comparator)', function() {
      var a;
      a = send(prop(), [1]);
      return expect(a.skipDuplicates()).toEmit([
        {
          current: 1
        }, 2, 3, '<end>'
      ], function() {
        return send(a, [1, 1, 2, 3, 3, '<end>']);
      });
    });
    it('should handle events and current (custom comparator)', function() {
      var a;
      a = send(prop(), [1]);
      return expect(a.skipDuplicates(roundlyEqual)).toEmit([
        {
          current: 1
        }, 2, 3, '<end>'
      ], function() {
        return send(a, [1.1, 1.2, 2, 3, 3.2, '<end>']);
      });
    });
    return it('errors should flow', function() {
      var a;
      a = prop();
      return expect(a.skipDuplicates()).errorsToFlow(a);
    });
  });
});


},{"../test-helpers.coffee":249}],230:[function(require,module,exports){
var Kefir, activate, deactivate, prop, ref, send, stream;

ref = require('../test-helpers.coffee'), stream = ref.stream, prop = ref.prop, send = ref.send, Kefir = ref.Kefir, activate = ref.activate, deactivate = ref.deactivate;

describe('skipUntilBy', function() {
  describe('common', function() {
    it('errors should flow', function() {
      var a, b;
      a = stream();
      b = stream();
      expect(a.skipUntilBy(b)).errorsToFlow(a);
      a = stream();
      b = stream();
      expect(a.skipUntilBy(b)).errorsToFlow(b);
      a = prop();
      b = stream();
      expect(a.skipUntilBy(b)).errorsToFlow(a);
      a = prop();
      b = stream();
      expect(a.skipUntilBy(b)).errorsToFlow(b);
      a = stream();
      b = prop();
      expect(a.skipUntilBy(b)).errorsToFlow(a);
      a = stream();
      b = prop();
      expect(a.skipUntilBy(b)).errorsToFlow(b);
      a = prop();
      b = prop();
      expect(a.skipUntilBy(b)).errorsToFlow(a);
      a = prop();
      b = prop();
      return expect(a.skipUntilBy(b)).errorsToFlow(b);
    });
    return it('errors should flow after first value from secondary', function() {
      var a, b, res;
      a = stream();
      b = stream();
      res = a.skipUntilBy(b);
      activate(res);
      send(b, [1]);
      deactivate(res);
      return expect(res).errorsToFlow(b);
    });
  });
  describe('stream, stream', function() {
    it('should return a stream', function() {
      return expect(stream().skipUntilBy(stream())).toBeStream();
    });
    it('should activate/deactivate sources', function() {
      var a, b;
      a = stream();
      b = stream();
      return expect(a.skipUntilBy(b)).toActivate(a, b);
    });
    it('should do activate secondary after first value from it', function() {
      var a, b, res;
      a = stream();
      b = stream();
      res = a.skipUntilBy(b);
      activate(res);
      send(b, [1]);
      deactivate(res);
      expect(res).toActivate(a);
      return expect(res).toActivate(b);
    });
    it('should be ended if primary was ended', function() {
      return expect(send(stream(), ['<end>']).skipUntilBy(stream())).toEmit(['<end:current>']);
    });
    it('should be ended if secondary was ended', function() {
      return expect(stream().skipUntilBy(send(stream(), ['<end>']))).toEmit(['<end:current>']);
    });
    it('should not end when secondary ends if it produced at least one value', function() {
      var a, b;
      a = stream();
      b = stream();
      return expect(a.skipUntilBy(b)).toEmit([], function() {
        return send(b, [0, '<end>']);
      });
    });
    it('should ignore values from primary until first value from secondary', function() {
      var a, b;
      a = stream();
      b = stream();
      return expect(a.skipUntilBy(b)).toEmit([], function() {
        return send(a, [1, 2]);
      });
    });
    return it('should emit all values from primary after first value from secondary', function() {
      var a, b;
      a = stream();
      b = stream();
      return expect(a.skipUntilBy(b)).toEmit([3, 4, 5, 6, 7, 8, 9, '<end>'], function() {
        send(b, [true]);
        send(a, [3, 4]);
        send(b, [0]);
        send(a, [5, 6]);
        send(b, [1]);
        send(a, [7, 8]);
        send(b, [false]);
        return send(a, [9, '<end>']);
      });
    });
  });
  describe('stream, property', function() {
    it('should return a stream', function() {
      return expect(stream().skipUntilBy(prop())).toBeStream();
    });
    it('should activate/deactivate sources', function() {
      var a, b;
      a = stream();
      b = prop();
      return expect(a.skipUntilBy(b)).toActivate(a, b);
    });
    it('should do activate secondary after first value from it', function() {
      var a, b, res;
      a = stream();
      b = prop();
      res = a.skipUntilBy(b);
      activate(res);
      send(b, [1]);
      deactivate(res);
      expect(res).toActivate(a);
      return expect(res).toActivate(b);
    });
    it('should be ended if primary was ended', function() {
      return expect(send(stream(), ['<end>']).skipUntilBy(prop())).toEmit(['<end:current>']);
    });
    it('should be ended if secondary was ended and has no current', function() {
      return expect(stream().skipUntilBy(send(prop(), ['<end>']))).toEmit(['<end:current>']);
    });
    it('should not be ended if secondary was ended but has any current', function() {
      return expect(stream().skipUntilBy(send(prop(), [0, '<end>']))).toEmit([]);
    });
    it('should not end when secondary ends if it produced at least one value', function() {
      var a, b;
      a = stream();
      b = prop();
      return expect(a.skipUntilBy(b)).toEmit([], function() {
        return send(b, [true, '<end>']);
      });
    });
    it('should ignore values from primary until first value from secondary', function() {
      var a, b;
      a = stream();
      b = prop();
      return expect(a.skipUntilBy(b)).toEmit([], function() {
        return send(a, [1, 2]);
      });
    });
    return it('should filter values as expected', function() {
      var a, b;
      a = stream();
      b = send(prop(), [0]);
      return expect(a.skipUntilBy(b)).toEmit([3, 4, 5, 6, 7, 8, 9, '<end>'], function() {
        send(a, [3, 4]);
        send(b, [2]);
        send(a, [5, 6]);
        send(b, [1]);
        send(a, [7, 8]);
        send(b, [false]);
        return send(a, [9, '<end>']);
      });
    });
  });
  describe('property, stream', function() {
    it('should return a property', function() {
      return expect(prop().skipUntilBy(stream())).toBeProperty();
    });
    it('should activate/deactivate sources', function() {
      var a, b;
      a = prop();
      b = stream();
      return expect(a.skipUntilBy(b)).toActivate(a, b);
    });
    it('should do activate secondary after first value from it', function() {
      var a, b, res;
      a = prop();
      b = stream();
      res = a.skipUntilBy(b);
      activate(res);
      send(b, [1]);
      deactivate(res);
      expect(res).toActivate(a);
      return expect(res).toActivate(b);
    });
    it('should be ended if primary was ended', function() {
      return expect(send(prop(), ['<end>']).skipUntilBy(stream())).toEmit(['<end:current>']);
    });
    it('should be ended if secondary was ended', function() {
      return expect(prop().skipUntilBy(send(stream(), ['<end>']))).toEmit(['<end:current>']);
    });
    it('should not end when secondary ends if it produced at least one value', function() {
      var a, b;
      a = prop();
      b = stream();
      return expect(a.skipUntilBy(b)).toEmit([], function() {
        return send(b, [0, '<end>']);
      });
    });
    it('should ignore values from primary until first value from secondary', function() {
      var a, b;
      a = prop();
      b = stream();
      return expect(a.skipUntilBy(b)).toEmit([], function() {
        return send(a, [1, 2]);
      });
    });
    return it('should filter values as expected', function() {
      var a, b;
      a = send(prop(), [0]);
      b = stream();
      return expect(a.skipUntilBy(b)).toEmit([3, 4, 5, 6, 7, 8, 9, '<end>'], function() {
        send(b, [true]);
        send(a, [3, 4]);
        send(b, [0]);
        send(a, [5, 6]);
        send(b, [1]);
        send(a, [7, 8]);
        send(b, [false]);
        return send(a, [9, '<end>']);
      });
    });
  });
  return describe('property, property', function() {
    it('should return a property', function() {
      return expect(prop().skipUntilBy(prop())).toBeProperty();
    });
    it('should activate/deactivate sources', function() {
      var a, b;
      a = prop();
      b = prop();
      return expect(a.skipUntilBy(b)).toActivate(a, b);
    });
    it('should do activate secondary after first value from it', function() {
      var a, b, res;
      a = prop();
      b = prop();
      res = a.skipUntilBy(b);
      activate(res);
      send(b, [1]);
      deactivate(res);
      expect(res).toActivate(a);
      return expect(res).toActivate(b);
    });
    it('should be ended if primary was ended', function() {
      return expect(send(prop(), ['<end>']).skipUntilBy(prop())).toEmit(['<end:current>']);
    });
    it('should be ended if secondary was ended and has no current', function() {
      return expect(prop().skipUntilBy(send(prop(), ['<end>']))).toEmit(['<end:current>']);
    });
    it('should not be ended if secondary was ended but has any current', function() {
      return expect(prop().skipUntilBy(send(prop(), [0, '<end>']))).toEmit([]);
    });
    it('should not end when secondary ends if it produced at least one value', function() {
      var a, b;
      a = prop();
      b = prop();
      return expect(a.skipUntilBy(b)).toEmit([], function() {
        return send(b, [true, '<end>']);
      });
    });
    it('should ignore values from primary until first value from secondary', function() {
      var a, b;
      a = prop();
      b = prop();
      return expect(a.skipUntilBy(b)).toEmit([], function() {
        return send(a, [1, 2]);
      });
    });
    return it('should filter values as expected', function() {
      var a, b;
      a = send(prop(), [0]);
      b = send(prop(), [0]);
      return expect(a.skipUntilBy(b)).toEmit([
        {
          current: 0
        }, 3, 4, 5, 6, 7, 8, 9, '<end>'
      ], function() {
        send(a, [3, 4]);
        send(b, [2]);
        send(a, [5, 6]);
        send(b, [1]);
        send(a, [7, 8]);
        send(b, [false]);
        return send(a, [9, '<end>']);
      });
    });
  });
});


},{"../test-helpers.coffee":249}],231:[function(require,module,exports){
var Kefir, prop, ref, send, stream;

ref = require('../test-helpers.coffee'), stream = ref.stream, prop = ref.prop, send = ref.send, Kefir = ref.Kefir;

describe('skipWhile', function() {
  describe('stream', function() {
    it('should return stream', function() {
      return expect(stream().skipWhile(function() {
        return false;
      })).toBeStream();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = stream();
      return expect(a.skipWhile(function() {
        return false;
      })).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(stream(), ['<end>']).skipWhile(function() {
        return false;
      })).toEmit(['<end:current>']);
    });
    it('should handle events (`-> true`)', function() {
      var a;
      a = stream();
      return expect(a.skipWhile(function() {
        return true;
      })).toEmit(['<end>'], function() {
        return send(a, [1, 2, '<end>']);
      });
    });
    it('should handle events (`-> false`)', function() {
      var a;
      a = stream();
      return expect(a.skipWhile(function() {
        return false;
      })).toEmit([1, 2, 3, '<end>'], function() {
        return send(a, [1, 2, 3, '<end>']);
      });
    });
    it('should handle events (`(x) -> x < 3`)', function() {
      var a;
      a = stream();
      return expect(a.skipWhile(function(x) {
        return x < 3;
      })).toEmit([3, 4, 5, '<end>'], function() {
        return send(a, [1, 2, 3, 4, 5, '<end>']);
      });
    });
    it('shoud use id as default predicate', function() {
      var a;
      a = stream();
      return expect(a.skipWhile()).toEmit([0, 4, 5, '<end>'], function() {
        return send(a, [1, 2, 0, 4, 5, '<end>']);
      });
    });
    return it('errors should flow', function() {
      var a;
      a = stream();
      return expect(a.skipWhile()).errorsToFlow(a);
    });
  });
  return describe('property', function() {
    it('should return property', function() {
      return expect(prop().skipWhile(function() {
        return false;
      })).toBeProperty();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = prop();
      return expect(a.skipWhile(function() {
        return false;
      })).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(prop(), ['<end>']).skipWhile(function() {
        return false;
      })).toEmit(['<end:current>']);
    });
    it('should handle events and current (`-> true`)', function() {
      var a;
      a = send(prop(), [1]);
      return expect(a.skipWhile(function() {
        return true;
      })).toEmit(['<end>'], function() {
        return send(a, [2, '<end>']);
      });
    });
    it('should handle events and current (`-> false`)', function() {
      var a;
      a = send(prop(), [1]);
      return expect(a.skipWhile(function() {
        return false;
      })).toEmit([
        {
          current: 1
        }, 2, 3, '<end>'
      ], function() {
        return send(a, [2, 3, '<end>']);
      });
    });
    it('should handle events and current (`(x) -> x < 3`)', function() {
      var a;
      a = send(prop(), [1]);
      return expect(a.skipWhile(function(x) {
        return x < 3;
      })).toEmit([3, 4, 5, '<end>'], function() {
        return send(a, [2, 3, 4, 5, '<end>']);
      });
    });
    it('shoud use id as default predicate', function() {
      var a;
      a = send(prop(), [1]);
      expect(a.skipWhile()).toEmit([0, 4, 5, '<end>'], function() {
        return send(a, [2, 0, 4, 5, '<end>']);
      });
      a = send(prop(), [0]);
      return expect(a.skipWhile()).toEmit([
        {
          current: 0
        }, 2, 0, 4, 5, '<end>'
      ], function() {
        return send(a, [2, 0, 4, 5, '<end>']);
      });
    });
    return it('errors should flow', function() {
      var a;
      a = prop();
      return expect(a.skipWhile()).errorsToFlow(a);
    });
  });
});


},{"../test-helpers.coffee":249}],232:[function(require,module,exports){
var Kefir, prop, ref, send, stream;

ref = require('../test-helpers.coffee'), stream = ref.stream, prop = ref.prop, send = ref.send, Kefir = ref.Kefir;

describe('skip', function() {
  describe('stream', function() {
    it('should return stream', function() {
      return expect(stream().skip(3)).toBeStream();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = stream();
      return expect(a.skip(3)).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(stream(), ['<end>']).skip(3)).toEmit(['<end:current>']);
    });
    it('should handle events (less than `n`)', function() {
      var a;
      a = stream();
      return expect(a.skip(3)).toEmit(['<end>'], function() {
        return send(a, [1, 2, '<end>']);
      });
    });
    it('should handle events (more than `n`)', function() {
      var a;
      a = stream();
      return expect(a.skip(3)).toEmit([4, 5, '<end>'], function() {
        return send(a, [1, 2, 3, 4, 5, '<end>']);
      });
    });
    it('should handle events (n == 0)', function() {
      var a;
      a = stream();
      return expect(a.skip(0)).toEmit([1, 2, 3, '<end>'], function() {
        return send(a, [1, 2, 3, '<end>']);
      });
    });
    it('should handle events (n == -1)', function() {
      var a;
      a = stream();
      return expect(a.skip(-1)).toEmit([1, 2, 3, '<end>'], function() {
        return send(a, [1, 2, 3, '<end>']);
      });
    });
    return it('errors should flow', function() {
      var a;
      a = stream();
      return expect(a.skip(1)).errorsToFlow(a);
    });
  });
  return describe('property', function() {
    it('should return property', function() {
      return expect(prop().skip(3)).toBeProperty();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = prop();
      return expect(a.skip(3)).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(prop(), ['<end>']).skip(3)).toEmit(['<end:current>']);
    });
    it('should handle events and current (less than `n`)', function() {
      var a;
      a = send(prop(), [1]);
      return expect(a.skip(3)).toEmit(['<end>'], function() {
        return send(a, [2, '<end>']);
      });
    });
    it('should handle events and current (more than `n`)', function() {
      var a;
      a = send(prop(), [1]);
      return expect(a.skip(3)).toEmit([4, 5, '<end>'], function() {
        return send(a, [2, 3, 4, 5, '<end>']);
      });
    });
    it('should handle events and current (n == 0)', function() {
      var a;
      a = send(prop(), [1]);
      return expect(a.skip(0)).toEmit([
        {
          current: 1
        }, 2, 3, '<end>'
      ], function() {
        return send(a, [2, 3, '<end>']);
      });
    });
    it('should handle events and current (n == -1)', function() {
      var a;
      a = send(prop(), [1]);
      return expect(a.skip(-1)).toEmit([
        {
          current: 1
        }, 2, 3, '<end>'
      ], function() {
        return send(a, [2, 3, '<end>']);
      });
    });
    return it('errors should flow', function() {
      var a;
      a = prop();
      return expect(a.skip(1)).errorsToFlow(a);
    });
  });
});


},{"../test-helpers.coffee":249}],233:[function(require,module,exports){
var Kefir, prop, ref, send, stream;

ref = require('../test-helpers.coffee'), stream = ref.stream, prop = ref.prop, send = ref.send, Kefir = ref.Kefir;

describe('slidingWindow', function() {
  describe('stream', function() {
    it('should return stream', function() {
      return expect(stream().slidingWindow(1)).toBeStream();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = stream();
      return expect(a.slidingWindow(1)).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(stream(), ['<end>']).slidingWindow(1)).toEmit(['<end:current>']);
    });
    it('.slidingWindow(3) should work correctly', function() {
      var a;
      a = stream();
      return expect(a.slidingWindow(3)).toEmit([[1], [1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5], '<end>'], function() {
        return send(a, [1, 2, 3, 4, 5, '<end>']);
      });
    });
    it('.slidingWindow(3, 2) should work correctly', function() {
      var a;
      a = stream();
      return expect(a.slidingWindow(3, 2)).toEmit([[1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5], '<end>'], function() {
        return send(a, [1, 2, 3, 4, 5, '<end>']);
      });
    });
    it('.slidingWindow(3, 3) should work correctly', function() {
      var a;
      a = stream();
      return expect(a.slidingWindow(3, 3)).toEmit([[1, 2, 3], [2, 3, 4], [3, 4, 5], '<end>'], function() {
        return send(a, [1, 2, 3, 4, 5, '<end>']);
      });
    });
    it('.slidingWindow(3, 4) should work correctly', function() {
      var a;
      a = stream();
      return expect(a.slidingWindow(3, 4)).toEmit(['<end>'], function() {
        return send(a, [1, 2, 3, 4, 5, '<end>']);
      });
    });
    return it('errors should flow', function() {
      var a;
      a = stream();
      return expect(a.slidingWindow(3, 4)).errorsToFlow(a);
    });
  });
  return describe('property', function() {
    it('should return property', function() {
      return expect(prop().slidingWindow(1)).toBeProperty();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = prop();
      return expect(a.slidingWindow(1)).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(prop(), ['<end>']).slidingWindow(1)).toEmit(['<end:current>']);
    });
    it('.slidingWindow(3) should work correctly', function() {
      var a;
      a = send(prop(), [1]);
      return expect(a.slidingWindow(3)).toEmit([
        {
          current: [1]
        }, [1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5], '<end>'
      ], function() {
        return send(a, [2, 3, 4, 5, '<end>']);
      });
    });
    it('.slidingWindow(3, 2) should work correctly', function() {
      var a;
      a = send(prop(), [1]);
      return expect(a.slidingWindow(3, 2)).toEmit([[1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5], '<end>'], function() {
        return send(a, [2, 3, 4, 5, '<end>']);
      });
    });
    it('.slidingWindow(3, 3) should work correctly', function() {
      var a;
      a = send(prop(), [1]);
      return expect(a.slidingWindow(3, 3)).toEmit([[1, 2, 3], [2, 3, 4], [3, 4, 5], '<end>'], function() {
        return send(a, [2, 3, 4, 5, '<end>']);
      });
    });
    it('.slidingWindow(3, 4) should work correctly', function() {
      var a;
      a = send(prop(), [1]);
      return expect(a.slidingWindow(3, 4)).toEmit(['<end>'], function() {
        return send(a, [2, 3, 4, 5, '<end>']);
      });
    });
    return it('errors should flow', function() {
      var a;
      a = prop();
      return expect(a.slidingWindow(3, 4)).errorsToFlow(a);
    });
  });
});


},{"../test-helpers.coffee":249}],234:[function(require,module,exports){
'use strict';

var _require = require('../test-helpers.coffee');

var Kefir = _require.Kefir;
var Observable = Kefir.staticLand.Observable;


describe('Kefir.staticLand.Observable', function () {

  it('of works', function () {
    expect(Observable.of(2)).toEmit([{ current: 2 }, '<end:current>']);
  });

  it('empty works', function () {
    expect(Observable.empty()).toEmit(['<end:current>']);
  });

  it('concat works', function () {
    expect(Observable.concat(Observable.of(2), Observable.empty())).toEmit([{ current: 2 }, '<end:current>']);
  });

  it('map works', function () {
    expect(Observable.map(function (x) {
      return x * 3;
    }, Observable.of(2))).toEmit([{ current: 6 }, '<end:current>']);
  });

  it('bimap works', function () {
    expect(Observable.bimap(function (x) {
      return x;
    }, function (x) {
      return x * 3;
    }, Observable.of(2))).toEmit([{ current: 6 }, '<end:current>']);
    expect(Observable.bimap(function (x) {
      return x * 3;
    }, function (x) {
      return x;
    }, Kefir.constantError(2))).toEmit([{ currentError: 6 }, '<end:current>']);
  });

  it('ap works', function () {
    expect(Observable.ap(Observable.of(function (x) {
      return x * 3;
    }), Observable.of(2))).toEmit([{ current: 6 }, '<end:current>']);
  });

  it('chain works', function () {
    expect(Observable.chain(function (x) {
      return Observable.of(x * 3);
    }, Observable.of(2))).toEmit([{ current: 6 }, '<end:current>']);
  });
});

},{"../test-helpers.coffee":249}],235:[function(require,module,exports){
var Kefir, activate, ref, send, stream;

ref = require('../test-helpers.coffee'), stream = ref.stream, send = ref.send, activate = ref.activate, Kefir = ref.Kefir;

describe('Stream', function() {
  describe('new', function() {
    it('should create a Stream', function() {
      expect(stream()).toBeStream();
      return expect(new Kefir.Stream()).toBeStream();
    });
    it('should not be ended', function() {
      return expect(stream()).toEmit([]);
    });
    return it('should not be active', function() {
      return expect(stream()).not.toBeActive();
    });
  });
  describe('end', function() {
    it('should end when `end` sent', function() {
      var s;
      s = stream();
      return expect(s).toEmit(['<end>'], function() {
        return send(s, ['<end>']);
      });
    });
    it('should call `end` subscribers', function() {
      var log, s;
      s = stream();
      log = [];
      s.onEnd(function() {
        return log.push(1);
      });
      s.onEnd(function() {
        return log.push(2);
      });
      expect(log).toEqual([]);
      send(s, ['<end>']);
      return expect(log).toEqual([1, 2]);
    });
    it('should call `end` subscribers on already ended stream', function() {
      var log, s;
      s = stream();
      send(s, ['<end>']);
      log = [];
      s.onEnd(function() {
        return log.push(1);
      });
      s.onEnd(function() {
        return log.push(2);
      });
      return expect(log).toEqual([1, 2]);
    });
    it('should deactivate on end', function() {
      var s;
      s = stream();
      activate(s);
      expect(s).toBeActive();
      send(s, ['<end>']);
      return expect(s).not.toBeActive();
    });
    it('should stop deliver new values after end', function() {
      var s;
      s = stream();
      return expect(s).toEmit([1, 2, '<end>'], function() {
        return send(s, [1, 2, '<end>', 3]);
      });
    });
    it('calling ._emitEnd twice should work fine', function() {
      var e, err, error, s;
      err = void 0;
      try {
        s = stream();
        s._emitEnd();
        s._emitEnd();
      } catch (error) {
        e = error;
        err = e;
      }
      return expect(err && err.message).toBe(void 0);
    });
    return it('calling ._emitEnd in an end handler should work fine', function() {
      var e, err, error, s;
      err = void 0;
      try {
        s = stream();
        s.onEnd(function() {
          return s._emitEnd();
        });
        s._emitEnd();
      } catch (error) {
        e = error;
        err = e;
      }
      return expect(err && err.message).toBe(void 0);
    });
  });
  describe('active state', function() {
    it('should activate when first subscriber added (value)', function() {
      var s;
      s = stream();
      s.onValue(function() {});
      return expect(s).toBeActive();
    });
    it('should activate when first subscriber added (error)', function() {
      var s;
      s = stream();
      s.onError(function() {});
      return expect(s).toBeActive();
    });
    it('should activate when first subscriber added (end)', function() {
      var s;
      s = stream();
      s.onEnd(function() {});
      return expect(s).toBeActive();
    });
    it('should activate when first subscriber added (any)', function() {
      var s;
      s = stream();
      s.onAny(function() {});
      return expect(s).toBeActive();
    });
    return it('should deactivate when all subscribers removed', function() {
      var any1, any2, end1, end2, error1, error2, s, value1, value2;
      s = stream();
      s.onAny((any1 = function() {}));
      s.onAny((any2 = function() {}));
      s.onValue((value1 = function() {}));
      s.onValue((value2 = function() {}));
      s.onError((error1 = function() {}));
      s.onError((error2 = function() {}));
      s.onEnd((end1 = function() {}));
      s.onEnd((end2 = function() {}));
      s.offValue(value1);
      s.offValue(value2);
      s.offError(error1);
      s.offError(error2);
      s.offAny(any1);
      s.offAny(any2);
      s.offEnd(end1);
      expect(s).toBeActive();
      s.offEnd(end2);
      return expect(s).not.toBeActive();
    });
  });
  return describe('subscribers', function() {
    it('should deliver values', function() {
      var s;
      s = stream();
      return expect(s).toEmit([1, 2], function() {
        return send(s, [1, 2]);
      });
    });
    it('should deliver errors', function() {
      var s;
      s = stream();
      return expect(s).toEmit([
        {
          error: 1
        }, {
          error: 2
        }
      ], function() {
        return send(s, [
          {
            error: 1
          }, {
            error: 2
          }
        ]);
      });
    });
    it('should not deliver values to unsubscribed subscribers', function() {
      var a, b, log, s;
      log = [];
      a = function(x) {
        return log.push('a' + x);
      };
      b = function(x) {
        return log.push('b' + x);
      };
      s = stream();
      s.onValue(a);
      s.onValue(b);
      send(s, [1]);
      s.offValue(function() {});
      send(s, [2]);
      s.offValue(a);
      send(s, [3]);
      s.offValue(b);
      send(s, [4]);
      return expect(log).toEqual(['a1', 'b1', 'a2', 'b2', 'b3']);
    });
    it('should not deliver errors to unsubscribed subscribers', function() {
      var a, b, log, s;
      log = [];
      a = function(x) {
        return log.push('a' + x);
      };
      b = function(x) {
        return log.push('b' + x);
      };
      s = stream();
      s.onError(a);
      s.onError(b);
      send(s, [
        {
          error: 1
        }
      ]);
      s.offError(function() {});
      send(s, [
        {
          error: 2
        }
      ]);
      s.offError(a);
      send(s, [
        {
          error: 3
        }
      ]);
      s.offError(b);
      send(s, [
        {
          error: 4
        }
      ]);
      return expect(log).toEqual(['a1', 'b1', 'a2', 'b2', 'b3']);
    });
    it('onValue subscribers should be called with 1 argument', function() {
      var count, s;
      s = stream();
      count = null;
      s.onValue(function() {
        return count = arguments.length;
      });
      send(s, [1]);
      return expect(count).toBe(1);
    });
    it('onError subscribers should be called with 1 argument', function() {
      var count, s;
      s = stream();
      count = null;
      s.onError(function() {
        return count = arguments.length;
      });
      send(s, [
        {
          error: 1
        }
      ]);
      return expect(count).toBe(1);
    });
    it('onAny subscribers should be called with 1 arguments', function() {
      var count, s;
      s = stream();
      count = null;
      s.onAny(function() {
        return count = arguments.length;
      });
      send(s, [1]);
      return expect(count).toBe(1);
    });
    it('onEnd subscribers should be called with 0 arguments', function() {
      var count, s;
      s = stream();
      count = null;
      s.onEnd(function() {
        return count = arguments.length;
      });
      send(s, ['<end>']);
      expect(count).toBe(0);
      s.onEnd(function() {
        return count = arguments.length;
      });
      return expect(count).toBe(0);
    });
    it('should not call subscriber after unsubscribing (from another subscriber)', function() {
      var a, b, log, s;
      log = [];
      a = function() {
        return log.push('a');
      };
      b = function() {
        s.offValue(a);
        return log.push('unsub a');
      };
      s = stream();
      s.onValue(b);
      s.onValue(a);
      send(s, [1]);
      return expect(log).toEqual(['unsub a']);
    });
    return it('should not call subscribers after end (fired from another subscriber)', function() {
      var a, b, log, s;
      log = [];
      a = function() {
        return log.push('a');
      };
      b = function() {
        send(s, ['<end>']);
        return log.push('end fired');
      };
      s = stream();
      s.onValue(b);
      s.onValue(a);
      send(s, [1]);
      return expect(log).toEqual(['end fired']);
    });
  });
});


},{"../test-helpers.coffee":249}],236:[function(require,module,exports){
var prop, ref, send, stream;

ref = require('../test-helpers.coffee'), stream = ref.stream, prop = ref.prop, send = ref.send;

describe('setName', function() {
  it('should return same observable', function() {
    var a;
    a = stream();
    expect(a.setName('foo')).toBe(a);
    return expect(a.setName(stream(), 'foo')).toBe(a);
  });
  return it('should update observable name', function() {
    var a;
    a = stream();
    expect(a.toString()).toBe('[stream]');
    a.setName('foo');
    expect(a.toString()).toBe('[foo]');
    a.setName(stream().setName('foo'), 'bar');
    return expect(a.toString()).toBe('[foo.bar]');
  });
});

describe('awaiting', function() {
  it('stream and stream', function() {
    var a, b;
    a = stream();
    b = stream();
    return expect(a.awaiting(b)).toEmit([
      {
        current: false
      }, true, false, true
    ], function() {
      send(a, [1]);
      send(b, [1]);
      send(b, [1]);
      send(a, [1]);
      return send(a, [1]);
    });
  });
  it('property and stream', function() {
    var a, b;
    a = send(prop(), [1]);
    b = stream();
    return expect(a.awaiting(b)).toEmit([
      {
        current: true
      }, false, true
    ], function() {
      send(a, [1]);
      send(b, [1]);
      send(b, [1]);
      send(a, [1]);
      return send(a, [1]);
    });
  });
  return it('property and property', function() {
    var a, b;
    a = send(prop(), [1]);
    b = send(prop(), [1]);
    return expect(a.awaiting(b)).toEmit([
      {
        current: false
      }, true, false, true
    ], function() {
      send(a, [1]);
      send(b, [1]);
      send(b, [1]);
      send(a, [1]);
      return send(a, [1]);
    });
  });
});


},{"../test-helpers.coffee":249}],237:[function(require,module,exports){
var Kefir, prop, ref, send, stream;

ref = require('../test-helpers.coffee'), stream = ref.stream, prop = ref.prop, send = ref.send, Kefir = ref.Kefir;

describe('takeErrors', function() {
  describe('stream', function() {
    it('should return stream', function() {
      return expect(stream().takeErrors(3)).toBeStream();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = stream();
      return expect(a.takeErrors(3)).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(stream(), ['<end>']).takeErrors(3)).toEmit(['<end:current>']);
    });
    it('should be ended if `n` is 0', function() {
      return expect(stream().takeErrors(0)).toEmit(['<end:current>']);
    });
    it('should handle events (less than `n`)', function() {
      var a;
      a = stream();
      return expect(a.takeErrors(3)).toEmit([
        {
          error: 1
        }, {
          error: 2
        }, '<end>'
      ], function() {
        return send(a, [
          {
            error: 1
          }, {
            error: 2
          }, '<end>'
        ]);
      });
    });
    it('should handle events (more than `n`)', function() {
      var a;
      a = stream();
      return expect(a.takeErrors(3)).toEmit([
        {
          error: 1
        }, {
          error: 2
        }, {
          error: 3
        }, '<end>'
      ], function() {
        return send(a, [
          {
            error: 1
          }, {
            error: 2
          }, {
            error: 3
          }, {
            error: 4
          }, {
            error: 5
          }, '<end>'
        ]);
      });
    });
    return it('values should flow', function() {
      var a;
      a = stream();
      return expect(a.takeErrors(1)).toEmit([1, 2, 3, '<end>'], function() {
        return send(a, [1, 2, 3, '<end>']);
      });
    });
  });
  return describe('property', function() {
    it('should return property', function() {
      return expect(prop().takeErrors(3)).toBeProperty();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = prop();
      return expect(a.takeErrors(3)).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(prop(), ['<end>']).takeErrors(3)).toEmit(['<end:current>']);
    });
    it('should be ended if `n` is 0', function() {
      return expect(prop().takeErrors(0)).toEmit(['<end:current>']);
    });
    it('should handle events and current (less than `n`)', function() {
      var a;
      a = send(prop(), [
        {
          error: 1
        }
      ]);
      return expect(a.takeErrors(3)).toEmit([
        {
          currentError: 1
        }, {
          error: 2
        }, '<end>'
      ], function() {
        return send(a, [
          {
            error: 2
          }, '<end>'
        ]);
      });
    });
    it('should handle events and current (more than `n`)', function() {
      var a;
      a = send(prop(), [
        {
          error: 1
        }
      ]);
      return expect(a.takeErrors(3)).toEmit([
        {
          currentError: 1
        }, {
          error: 2
        }, {
          error: 3
        }, '<end>'
      ], function() {
        return send(a, [
          {
            error: 2
          }, {
            error: 3
          }, {
            error: 4
          }, {
            error: 5
          }, '<end>'
        ]);
      });
    });
    it('should work correctly with .constant', function() {
      return expect(Kefir.constantError(1).takeErrors(1)).toEmit([
        {
          currentError: 1
        }, '<end:current>'
      ]);
    });
    return it('values should flow', function() {
      var a;
      a = send(prop(), [1]);
      return expect(a.takeErrors(1)).toEmit([
        {
          current: 1
        }, 2, 3, 4, '<end>'
      ], function() {
        return send(a, [2, 3, 4, '<end>']);
      });
    });
  });
});


},{"../test-helpers.coffee":249}],238:[function(require,module,exports){
var Kefir, prop, ref, send, stream;

ref = require('../test-helpers.coffee'), stream = ref.stream, prop = ref.prop, send = ref.send, Kefir = ref.Kefir;

describe('takeUntilBy', function() {
  describe('common', function() {
    return it('errors should flow', function() {
      var a, b;
      a = stream();
      b = stream();
      expect(a.takeUntilBy(b)).errorsToFlow(a);
      a = stream();
      b = stream();
      expect(a.takeUntilBy(b)).errorsToFlow(b);
      a = prop();
      b = stream();
      expect(a.takeUntilBy(b)).errorsToFlow(a);
      a = prop();
      b = stream();
      expect(a.takeUntilBy(b)).errorsToFlow(b);
      a = stream();
      b = prop();
      expect(a.takeUntilBy(b)).errorsToFlow(a);
      a = stream();
      b = prop();
      expect(a.takeUntilBy(b)).errorsToFlow(b);
      a = prop();
      b = prop();
      expect(a.takeUntilBy(b)).errorsToFlow(a);
      a = prop();
      b = prop();
      return expect(a.takeUntilBy(b)).errorsToFlow(b);
    });
  });
  describe('stream, stream', function() {
    it('should return a stream', function() {
      return expect(stream().takeUntilBy(stream())).toBeStream();
    });
    it('should activate/deactivate sources', function() {
      var a, b;
      a = stream();
      b = stream();
      return expect(a.takeUntilBy(b)).toActivate(a, b);
    });
    it('should be ended if primary was ended', function() {
      return expect(send(stream(), ['<end>']).takeUntilBy(stream())).toEmit(['<end:current>']);
    });
    it('should not be ended if secondary was ended', function() {
      return expect(stream().takeUntilBy(send(stream(), ['<end>']))).toEmit([]);
    });
    it('should not end when secondary ends if there was no values from it', function() {
      var a, b;
      a = stream();
      b = stream();
      return expect(a.takeUntilBy(b)).toEmit([], function() {
        return send(b, ['<end>']);
      });
    });
    it('should end on first any value from secondary', function() {
      var a, b;
      a = stream();
      b = stream();
      return expect(a.takeUntilBy(b)).toEmit(['<end>'], function() {
        return send(b, [0]);
      });
    });
    it('should emit values from primary until first value from secondary', function() {
      var a, b;
      a = stream();
      b = stream();
      return expect(a.takeUntilBy(b)).toEmit([1, 2], function() {
        return send(a, [1, 2]);
      });
    });
    return it('should take values as expected', function() {
      var a, b;
      a = stream();
      b = stream();
      return expect(a.takeUntilBy(b)).toEmit([3, 4, '<end>'], function() {
        send(a, [3, 4]);
        send(b, [0]);
        send(a, [5, 6]);
        send(b, [false]);
        send(a, [7, 8]);
        send(b, [true]);
        return send(a, [9]);
      });
    });
  });
  describe('stream, property', function() {
    it('should return a stream', function() {
      return expect(stream().takeUntilBy(prop())).toBeStream();
    });
    it('should activate/deactivate sources', function() {
      var a, b;
      a = stream();
      b = prop();
      return expect(a.takeUntilBy(b)).toActivate(a, b);
    });
    it('should be ended if primary was ended', function() {
      return expect(send(stream(), ['<end>']).takeUntilBy(prop())).toEmit(['<end:current>']);
    });
    it('should not be ended if secondary was ended and has no current', function() {
      return expect(stream().takeUntilBy(send(prop(), ['<end>']))).toEmit([]);
    });
    it('should be ended if secondary was ended and has any current', function() {
      return expect(stream().takeUntilBy(send(prop(), [0, '<end>']))).toEmit(['<end:current>']);
    });
    it('should end on first any value from secondary', function() {
      var a, b;
      a = stream();
      b = prop();
      return expect(a.takeUntilBy(b)).toEmit(['<end>'], function() {
        return send(b, [0]);
      });
    });
    it('should not end when secondary ends there was no values from it', function() {
      var a, b;
      a = stream();
      b = prop();
      return expect(a.takeUntilBy(b)).toEmit([], function() {
        return send(b, ['<end>']);
      });
    });
    it('should emit values from primary until first value from secondary', function() {
      var a, b;
      a = stream();
      b = prop();
      return expect(a.takeUntilBy(b)).toEmit([1, 2], function() {
        return send(a, [1, 2]);
      });
    });
    return it('should take values as expected', function() {
      var a, b;
      a = stream();
      b = prop();
      return expect(a.takeUntilBy(b)).toEmit([3, 4, '<end>'], function() {
        send(a, [3, 4]);
        send(b, [0]);
        send(a, [5, 6]);
        send(b, [false]);
        send(a, [7, 8]);
        send(b, [true]);
        return send(a, [9]);
      });
    });
  });
  describe('property, stream', function() {
    it('should return a property', function() {
      return expect(prop().takeUntilBy(stream())).toBeProperty();
    });
    it('should activate/deactivate sources', function() {
      var a, b;
      a = prop();
      b = stream();
      return expect(a.takeUntilBy(b)).toActivate(a, b);
    });
    it('should be ended if primary was ended', function() {
      return expect(send(prop(), ['<end>']).takeUntilBy(stream())).toEmit(['<end:current>']);
    });
    it('should not be ended if secondary was ended', function() {
      return expect(prop().takeUntilBy(send(stream(), ['<end>']))).toEmit([]);
    });
    it('should not end when secondary ends if there was no values from it', function() {
      var a, b;
      a = prop();
      b = stream();
      return expect(a.takeUntilBy(b)).toEmit([], function() {
        return send(b, ['<end>']);
      });
    });
    it('should end on first any value from secondary', function() {
      var a, b;
      a = prop();
      b = stream();
      return expect(a.takeUntilBy(b)).toEmit(['<end>'], function() {
        return send(b, [0]);
      });
    });
    it('should emit values from primary until first value from secondary', function() {
      var a, b;
      a = prop();
      b = stream();
      return expect(a.takeUntilBy(b)).toEmit([1, 2], function() {
        return send(a, [1, 2]);
      });
    });
    return it('should take values as expected', function() {
      var a, b;
      a = send(prop(), [0]);
      b = stream();
      return expect(a.takeUntilBy(b)).toEmit([
        {
          current: 0
        }, 3, 4, '<end>'
      ], function() {
        send(a, [3, 4]);
        send(b, [1]);
        send(a, [5, 6]);
        send(b, [false]);
        send(a, [7, 8]);
        send(b, [true]);
        return send(a, [9]);
      });
    });
  });
  return describe('property, property', function() {
    it('should return a property', function() {
      return expect(prop().takeUntilBy(prop())).toBeProperty();
    });
    it('should activate/deactivate sources', function() {
      var a, b;
      a = prop();
      b = prop();
      return expect(a.takeUntilBy(b)).toActivate(a, b);
    });
    it('should be ended if primary was ended', function() {
      return expect(send(prop(), ['<end>']).takeUntilBy(prop())).toEmit(['<end:current>']);
    });
    it('should not be ended if secondary was ended and has no current', function() {
      return expect(prop().takeUntilBy(send(prop(), ['<end>']))).toEmit([]);
    });
    it('should be ended if secondary was ended and has any current', function() {
      return expect(prop().takeUntilBy(send(prop(), [0, '<end>']))).toEmit(['<end:current>']);
    });
    it('should end on first any value from secondary', function() {
      var a, b;
      a = prop();
      b = prop();
      return expect(a.takeUntilBy(b)).toEmit(['<end>'], function() {
        return send(b, [0]);
      });
    });
    it('should not end when secondary ends if there was no values from it', function() {
      var a, b;
      a = prop();
      b = prop();
      return expect(a.takeUntilBy(b)).toEmit([], function() {
        return send(b, ['<end>']);
      });
    });
    it('should emit values from primary until first value from secondary', function() {
      var a, b;
      a = prop();
      b = prop();
      return expect(a.takeUntilBy(b)).toEmit([1, 2], function() {
        return send(a, [1, 2]);
      });
    });
    return it('should take values as expected', function() {
      var a, b;
      a = send(prop(), [0]);
      b = prop();
      return expect(a.takeUntilBy(b)).toEmit([
        {
          current: 0
        }, 3, 4, '<end>'
      ], function() {
        send(a, [3, 4]);
        send(b, [1]);
        send(a, [5, 6]);
        send(b, [false]);
        send(a, [7, 8]);
        send(b, [true]);
        return send(a, [9]);
      });
    });
  });
});


},{"../test-helpers.coffee":249}],239:[function(require,module,exports){
var Kefir, prop, ref, send, stream;

ref = require('../test-helpers.coffee'), stream = ref.stream, prop = ref.prop, send = ref.send, Kefir = ref.Kefir;

describe('takeWhile', function() {
  describe('stream', function() {
    it('should return stream', function() {
      return expect(stream().takeWhile(function() {
        return true;
      })).toBeStream();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = stream();
      return expect(a.takeWhile(function() {
        return true;
      })).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(stream(), ['<end>']).takeWhile(function() {
        return true;
      })).toEmit(['<end:current>']);
    });
    it('should handle events', function() {
      var a;
      a = stream();
      return expect(a.takeWhile(function(x) {
        return x < 4;
      })).toEmit([1, 2, 3, '<end>'], function() {
        return send(a, [1, 2, 3, 4, 5, '<end>']);
      });
    });
    it('should handle events (natural end)', function() {
      var a;
      a = stream();
      return expect(a.takeWhile(function(x) {
        return x < 4;
      })).toEmit([1, 2, '<end>'], function() {
        return send(a, [1, 2, '<end>']);
      });
    });
    it('should handle events (with `-> false`)', function() {
      var a;
      a = stream();
      return expect(a.takeWhile(function() {
        return false;
      })).toEmit(['<end>'], function() {
        return send(a, [1, 2, '<end>']);
      });
    });
    it('shoud use id as default predicate', function() {
      var a;
      a = stream();
      return expect(a.takeWhile()).toEmit([1, 2, '<end>'], function() {
        return send(a, [1, 2, 0, 5, '<end>']);
      });
    });
    return it('errors should flow', function() {
      var a;
      a = stream();
      return expect(a.takeWhile()).errorsToFlow(a);
    });
  });
  return describe('property', function() {
    it('should return property', function() {
      return expect(prop().takeWhile(function() {
        return true;
      })).toBeProperty();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = prop();
      return expect(a.takeWhile(function() {
        return true;
      })).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(prop(), ['<end>']).takeWhile(function() {
        return true;
      })).toEmit(['<end:current>']);
    });
    it('should be ended if calback was `-> false` and source has a current', function() {
      return expect(send(prop(), [1]).takeWhile(function() {
        return false;
      })).toEmit(['<end:current>']);
    });
    it('should handle events', function() {
      var a;
      a = send(prop(), [1]);
      return expect(a.takeWhile(function(x) {
        return x < 4;
      })).toEmit([
        {
          current: 1
        }, 2, 3, '<end>'
      ], function() {
        return send(a, [2, 3, 4, 5, '<end>']);
      });
    });
    it('should handle events (natural end)', function() {
      var a;
      a = send(prop(), [1]);
      return expect(a.takeWhile(function(x) {
        return x < 4;
      })).toEmit([
        {
          current: 1
        }, 2, '<end>'
      ], function() {
        return send(a, [2, '<end>']);
      });
    });
    it('should handle events (with `-> false`)', function() {
      var a;
      a = prop();
      return expect(a.takeWhile(function() {
        return false;
      })).toEmit(['<end>'], function() {
        return send(a, [1, 2, '<end>']);
      });
    });
    it('shoud use id as default predicate', function() {
      var a;
      a = send(prop(), [1]);
      expect(a.takeWhile()).toEmit([
        {
          current: 1
        }, 2, '<end>'
      ], function() {
        return send(a, [2, 0, 5, '<end>']);
      });
      a = send(prop(), [0]);
      return expect(a.takeWhile()).toEmit(['<end:current>'], function() {
        return send(a, [2, 0, 5, '<end>']);
      });
    });
    return it('errors should flow', function() {
      var a;
      a = prop();
      return expect(a.takeWhile()).errorsToFlow(a);
    });
  });
});


},{"../test-helpers.coffee":249}],240:[function(require,module,exports){
var Kefir, prop, ref, send, stream;

ref = require('../test-helpers.coffee'), stream = ref.stream, prop = ref.prop, send = ref.send, Kefir = ref.Kefir;

describe('take', function() {
  describe('stream', function() {
    it('should return stream', function() {
      return expect(stream().take(3)).toBeStream();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = stream();
      return expect(a.take(3)).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(stream(), ['<end>']).take(3)).toEmit(['<end:current>']);
    });
    it('should be ended if `n` is 0', function() {
      return expect(stream().take(0)).toEmit(['<end:current>']);
    });
    it('should handle events (less than `n`)', function() {
      var a;
      a = stream();
      return expect(a.take(3)).toEmit([1, 2, '<end>'], function() {
        return send(a, [1, 2, '<end>']);
      });
    });
    it('should handle events (more than `n`)', function() {
      var a;
      a = stream();
      return expect(a.take(3)).toEmit([1, 2, 3, '<end>'], function() {
        return send(a, [1, 2, 3, 4, 5, '<end>']);
      });
    });
    return it('errors should flow', function() {
      var a;
      a = stream();
      return expect(a.take(1)).errorsToFlow(a);
    });
  });
  return describe('property', function() {
    it('should return property', function() {
      return expect(prop().take(3)).toBeProperty();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = prop();
      return expect(a.take(3)).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(prop(), ['<end>']).take(3)).toEmit(['<end:current>']);
    });
    it('should be ended if `n` is 0', function() {
      return expect(prop().take(0)).toEmit(['<end:current>']);
    });
    it('should handle events and current (less than `n`)', function() {
      var a;
      a = send(prop(), [1]);
      return expect(a.take(3)).toEmit([
        {
          current: 1
        }, 2, '<end>'
      ], function() {
        return send(a, [2, '<end>']);
      });
    });
    it('should handle events and current (more than `n`)', function() {
      var a;
      a = send(prop(), [1]);
      return expect(a.take(3)).toEmit([
        {
          current: 1
        }, 2, 3, '<end>'
      ], function() {
        return send(a, [2, 3, 4, 5, '<end>']);
      });
    });
    it('should work correctly with .constant', function() {
      return expect(Kefir.constant(1).take(1)).toEmit([
        {
          current: 1
        }, '<end:current>'
      ]);
    });
    return it('errors should flow', function() {
      var a;
      a = prop();
      return expect(a.take(1)).errorsToFlow(a);
    });
  });
});


},{"../test-helpers.coffee":249}],241:[function(require,module,exports){
var Kefir, prop, ref, send, stream;

ref = require('../test-helpers.coffee'), stream = ref.stream, prop = ref.prop, send = ref.send, Kefir = ref.Kefir;

describe('throttle', function() {
  describe('stream', function() {
    it('should return stream', function() {
      return expect(stream().throttle(100)).toBeStream();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = stream();
      return expect(a.throttle(100)).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(stream(), ['<end>']).throttle(100)).toEmit(['<end:current>']);
    });
    it('should handle events', function() {
      var a;
      a = stream();
      return expect(a.throttle(100)).toEmitInTime([[0, 1], [100, 4], [200, 5], [320, 6], [520, 7], [620, 9], [620, '<end>']], function(tick) {
        send(a, [1]);
        tick(30);
        send(a, [2]);
        tick(30);
        send(a, [3]);
        tick(30);
        send(a, [4]);
        tick(30);
        send(a, [5]);
        tick(200);
        send(a, [6]);
        tick(200);
        send(a, [7]);
        tick(30);
        send(a, [8]);
        tick(30);
        send(a, [9]);
        tick(30);
        return send(a, ['<end>']);
      });
    });
    it('should handle events {trailing: false}', function() {
      var a;
      a = stream();
      return expect(a.throttle(100, {
        trailing: false
      })).toEmitInTime([[0, 1], [120, 5], [320, 6], [520, 7], [610, '<end>']], function(tick) {
        send(a, [1]);
        tick(30);
        send(a, [2]);
        tick(30);
        send(a, [3]);
        tick(30);
        send(a, [4]);
        tick(30);
        send(a, [5]);
        tick(200);
        send(a, [6]);
        tick(200);
        send(a, [7]);
        tick(30);
        send(a, [8]);
        tick(30);
        send(a, [9]);
        tick(30);
        return send(a, ['<end>']);
      });
    });
    it('should handle events {leading: false}', function() {
      var a;
      a = stream();
      return expect(a.throttle(100, {
        leading: false
      })).toEmitInTime([[100, 4], [220, 5], [420, 6], [620, 9], [620, '<end>']], function(tick) {
        send(a, [1]);
        tick(30);
        send(a, [2]);
        tick(30);
        send(a, [3]);
        tick(30);
        send(a, [4]);
        tick(30);
        send(a, [5]);
        tick(200);
        send(a, [6]);
        tick(200);
        send(a, [7]);
        tick(30);
        send(a, [8]);
        tick(30);
        send(a, [9]);
        tick(30);
        return send(a, ['<end>']);
      });
    });
    it('should handle events {leading: false, trailing: false}', function() {
      var a;
      a = stream();
      return expect(a.throttle(100, {
        leading: false,
        trailing: false
      })).toEmitInTime([[120, 5], [320, 6], [520, 7], [610, '<end>']], function(tick) {
        send(a, [1]);
        tick(30);
        send(a, [2]);
        tick(30);
        send(a, [3]);
        tick(30);
        send(a, [4]);
        tick(30);
        send(a, [5]);
        tick(200);
        send(a, [6]);
        tick(200);
        send(a, [7]);
        tick(30);
        send(a, [8]);
        tick(30);
        send(a, [9]);
        tick(30);
        return send(a, ['<end>']);
      });
    });
    return it('errors should flow', function() {
      var a;
      a = stream();
      return expect(a.throttle(100)).errorsToFlow(a);
    });
  });
  return describe('property', function() {
    it('should return property', function() {
      return expect(prop().throttle(100)).toBeProperty();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = prop();
      return expect(a.throttle(100)).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(prop(), ['<end>']).throttle(100)).toEmit(['<end:current>']);
    });
    it('should handle events', function() {
      var a;
      a = send(prop(), [0]);
      return expect(a.throttle(100)).toEmitInTime([
        [
          0, {
            current: 0
          }
        ], [0, 1], [100, 4], [200, 5], [320, 6], [520, 7], [620, 9], [620, '<end>']
      ], function(tick) {
        send(a, [1]);
        tick(30);
        send(a, [2]);
        tick(30);
        send(a, [3]);
        tick(30);
        send(a, [4]);
        tick(30);
        send(a, [5]);
        tick(200);
        send(a, [6]);
        tick(200);
        send(a, [7]);
        tick(30);
        send(a, [8]);
        tick(30);
        send(a, [9]);
        tick(30);
        return send(a, ['<end>']);
      });
    });
    it('should handle events {trailing: false}', function() {
      var a;
      a = send(prop(), [0]);
      return expect(a.throttle(100, {
        trailing: false
      })).toEmitInTime([
        [
          0, {
            current: 0
          }
        ], [0, 1], [120, 5], [320, 6], [520, 7], [610, '<end>']
      ], function(tick) {
        send(a, [1]);
        tick(30);
        send(a, [2]);
        tick(30);
        send(a, [3]);
        tick(30);
        send(a, [4]);
        tick(30);
        send(a, [5]);
        tick(200);
        send(a, [6]);
        tick(200);
        send(a, [7]);
        tick(30);
        send(a, [8]);
        tick(30);
        send(a, [9]);
        tick(30);
        return send(a, ['<end>']);
      });
    });
    it('should handle events {leading: false}', function() {
      var a;
      a = send(prop(), [0]);
      return expect(a.throttle(100, {
        leading: false
      })).toEmitInTime([
        [
          0, {
            current: 0
          }
        ], [100, 4], [220, 5], [420, 6], [620, 9], [620, '<end>']
      ], function(tick) {
        send(a, [1]);
        tick(30);
        send(a, [2]);
        tick(30);
        send(a, [3]);
        tick(30);
        send(a, [4]);
        tick(30);
        send(a, [5]);
        tick(200);
        send(a, [6]);
        tick(200);
        send(a, [7]);
        tick(30);
        send(a, [8]);
        tick(30);
        send(a, [9]);
        tick(30);
        return send(a, ['<end>']);
      });
    });
    it('should handle events {leading: false, trailing: false}', function() {
      var a;
      a = send(prop(), [0]);
      return expect(a.throttle(100, {
        leading: false,
        trailing: false
      })).toEmitInTime([
        [
          0, {
            current: 0
          }
        ], [120, 5], [320, 6], [520, 7], [610, '<end>']
      ], function(tick) {
        send(a, [1]);
        tick(30);
        send(a, [2]);
        tick(30);
        send(a, [3]);
        tick(30);
        send(a, [4]);
        tick(30);
        send(a, [5]);
        tick(200);
        send(a, [6]);
        tick(200);
        send(a, [7]);
        tick(30);
        send(a, [8]);
        tick(30);
        send(a, [9]);
        tick(30);
        return send(a, ['<end>']);
      });
    });
    return it('errors should flow', function() {
      var a;
      a = prop();
      return expect(a.throttle(100)).errorsToFlow(a);
    });
  });
});


},{"../test-helpers.coffee":249}],242:[function(require,module,exports){
(function (global){
var Promise1, Promise2, _global, originalGlobalPromise, prop, ref, send, stream;

ref = require('../test-helpers.coffee'), stream = ref.stream, prop = ref.prop, send = ref.send;

Promise1 = function(cb) {
  var promise;
  promise = {
    type: 1,
    fulfilled: false,
    rejected: false
  };
  cb(function(x) {
    promise.fulfilled = true;
    return promise.result = x;
  }, function(x) {
    promise.rejected = true;
    return promise.result = x;
  });
  return promise;
};

Promise2 = function(cb) {
  var promise;
  promise = {
    type: 2,
    fulfilled: false,
    rejected: false
  };
  cb(function(x) {
    promise.fulfilled = true;
    return promise.result = x;
  }, function(x) {
    promise.rejected = true;
    return promise.result = x;
  });
  return promise;
};

_global = null;

if (typeof global !== 'undefined') {
  _global = global;
}

if (typeof self !== 'undefined') {
  _global = self;
}

originalGlobalPromise = _global.Promise;

describe('toPromise', function() {
  beforeEach(function() {
    return _global.Promise = Promise2;
  });
  afterEach(function() {
    return _global.Promise = originalGlobalPromise;
  });
  describe('stream', function() {
    it('should return a promise', function() {
      expect(stream().toPromise().type).toBe(2);
      return expect(stream().toPromise(Promise1).type).toBe(1);
    });
    it('should not fulfill/reject if obs ends without value', function() {
      var promise;
      promise = send(stream(), ['<end>']).toPromise();
      expect(promise.fulfilled || promise.rejected).toBe(false);
      promise = send(stream(), ['<end>']).toPromise(Promise1);
      return expect(promise.fulfilled || promise.rejected).toBe(false);
    });
    it('should fulfill with latest value on end', function() {
      var a, promise;
      a = stream();
      promise = a.toPromise();
      send(a, [
        1, {
          error: -1
        }, 2, '<end>'
      ]);
      expect(promise.fulfilled).toBe(true);
      expect(promise.result).toBe(2);
      a = stream();
      promise = a.toPromise(Promise1);
      send(a, [1, 2, '<end>']);
      expect(promise.fulfilled).toBe(true);
      return expect(promise.result).toBe(2);
    });
    it('should reject with latest error on end', function() {
      var a, promise;
      a = stream();
      promise = a.toPromise();
      send(a, [
        {
          error: -1
        }, 1, {
          error: -2
        }, '<end>'
      ]);
      expect(promise.rejected).toBe(true);
      expect(promise.result).toBe(-2);
      a = stream();
      promise = a.toPromise(Promise1);
      send(a, [
        {
          error: -1
        }, 1, {
          error: -2
        }, '<end>'
      ]);
      expect(promise.rejected).toBe(true);
      return expect(promise.result).toBe(-2);
    });
    return it('should throw when called without Promise constructor and there is no global promise', function() {
      var e, error, error1;
      _global.Promise = void 0;
      error = null;
      try {
        stream().toPromise();
      } catch (error1) {
        e = error1;
        error = e;
      }
      return expect(error.message).toBe('There isn\'t default Promise, use shim or parameter');
    });
  });
  return describe('property', function() {
    it('should handle currents (resolved)', function() {
      var promise;
      promise = send(prop(), [1, '<end>']).toPromise();
      expect(promise.fulfilled).toBe(true);
      expect(promise.result).toBe(1);
      promise = send(prop(), [1, '<end>']).toPromise(Promise1);
      expect(promise.fulfilled).toBe(true);
      return expect(promise.result).toBe(1);
    });
    return it('should handle currents (rejected)', function() {
      var promise;
      promise = send(prop(), [
        {
          error: -1
        }, '<end>'
      ]).toPromise();
      expect(promise.rejected).toBe(true);
      expect(promise.result).toBe(-1);
      promise = send(prop(), [
        {
          error: -1
        }, '<end>'
      ]).toPromise(Promise1);
      expect(promise.rejected).toBe(true);
      return expect(promise.result).toBe(-1);
    });
  });
});


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../test-helpers.coffee":249}],243:[function(require,module,exports){
var Kefir, activate, deactivate, prop, ref, send, stream;

ref = require('../test-helpers.coffee'), stream = ref.stream, prop = ref.prop, send = ref.send, Kefir = ref.Kefir, activate = ref.activate, deactivate = ref.deactivate;

describe('toProperty', function() {
  describe('stream', function() {
    it('should return property', function() {
      expect(stream().toProperty(function() {
        return 0;
      })).toBeProperty();
      return expect(stream().toProperty()).toBeProperty();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = stream();
      return expect(a.toProperty()).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(stream(), ['<end>']).toProperty()).toEmit(['<end:current>']);
    });
    it('should be ended if source was ended (with current)', function() {
      return expect(send(stream(), ['<end>']).toProperty(function() {
        return 0;
      })).toEmit([
        {
          current: 0
        }, '<end:current>'
      ]);
    });
    it('should handle events', function() {
      var a, p;
      a = stream();
      p = a.toProperty(function() {
        return 0;
      });
      expect(p).toEmit([
        {
          current: 0
        }, 1, {
          error: 3
        }, 2, '<end>'
      ], function() {
        return send(a, [
          1, {
            error: 3
          }, 2, '<end>'
        ]);
      });
      return expect(p).toEmit([
        {
          current: 2
        }, '<end:current>'
      ]);
    });
    it('should call callback on each activation', function() {
      var a, count, p;
      count = 0;
      a = stream();
      p = a.toProperty(function() {
        return count++;
      });
      activate(p);
      expect(count).toBe(1);
      deactivate(p);
      expect(count).toBe(1);
      activate(p);
      return expect(count).toBe(2);
    });
    it('should reset value by getting new from the callback on each activation', function() {
      var a, getCurrent, p;
      getCurrent = function(p) {
        var getter, result;
        result = null;
        getter = function(x) {
          return result = x;
        };
        p.onValue(getter);
        p.offValue(getter);
        return result;
      };
      a = stream();
      p = a.toProperty(function() {
        return 0;
      });
      expect(getCurrent(p)).toBe(0);
      activate(p);
      send(a, [1]);
      expect(getCurrent(p)).toBe(1);
      deactivate(p);
      return expect(getCurrent(p)).toBe(0);
    });
    return it('should throw when called with not a function', function() {
      var e, err, error;
      err = null;
      try {
        stream().toProperty(1);
      } catch (error) {
        e = error;
        err = e;
      }
      return expect(err.message).toBe('You should call toProperty() with a function or no arguments.');
    });
  });
  return describe('property', function() {
    it('should return property', function() {
      expect(prop().toProperty(function() {
        return 0;
      })).toBeProperty();
      return expect(prop().toProperty()).toBeProperty();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = prop();
      return expect(a.toProperty(function() {
        return 0;
      })).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      expect(send(prop(), ['<end>']).toProperty(function() {
        return 0;
      })).toEmit([
        {
          current: 0
        }, '<end:current>'
      ]);
      return expect(send(prop(), [1, '<end>']).toProperty(function() {
        return 0;
      })).toEmit([
        {
          current: 1
        }, '<end:current>'
      ]);
    });
    it('should handle events', function() {
      var a, b;
      a = send(prop(), [1]);
      b = a.toProperty(function() {
        return 0;
      });
      expect(b).toEmit([
        {
          current: 1
        }, 2, {
          error: 3
        }, '<end>'
      ], function() {
        return send(a, [
          2, {
            error: 3
          }, '<end>'
        ]);
      });
      expect(b).toEmit([
        {
          currentError: 3
        }, '<end:current>'
      ]);
      a = prop();
      b = a.toProperty(function() {
        return 0;
      });
      expect(b).toEmit([
        {
          current: 0
        }, 2, {
          error: 3
        }, 4, '<end>'
      ], function() {
        return send(a, [
          2, {
            error: 3
          }, 4, '<end>'
        ]);
      });
      return expect(b).toEmit([
        {
          current: 4
        }, '<end:current>'
      ]);
    });
    return it('if original property has no current, and .toProperty called with no arguments, then result should have no current', function() {
      return expect(prop().toProperty()).toEmit([]);
    });
  });
});


},{"../test-helpers.coffee":249}],244:[function(require,module,exports){
var Kefir, comp, noop, prop, ref, send, stream, testWithLib,
  slice = [].slice;

ref = require('../test-helpers.coffee'), stream = ref.stream, prop = ref.prop, send = ref.send, Kefir = ref.Kefir;

comp = function() {
  var fns;
  fns = 1 <= arguments.length ? slice.call(arguments, 0) : [];
  return function(x) {
    var f, i, len, ref1;
    ref1 = fns.slice(0).reverse();
    for (i = 0, len = ref1.length; i < len; i++) {
      f = ref1[i];
      x = f(x);
    }
    return x;
  };
};

testWithLib = function(name, t) {
  return describe("with " + name + " implementation", function() {
    describe('stream', function() {
      it('`map` should work', function() {
        var a;
        a = stream();
        return expect(a.transduce(t.map(function(x) {
          return x * 2;
        }))).toEmit([2, 4, 6, '<end>'], function() {
          return send(a, [1, 2, 3, '<end>']);
        });
      });
      it('`filter` should work', function() {
        var a;
        a = stream();
        return expect(a.transduce(t.filter(function(x) {
          return x % 2 === 0;
        }))).toEmit([2, 4, '<end>'], function() {
          return send(a, [1, 2, 3, 4, '<end>']);
        });
      });
      it('`take` should work', function() {
        var a;
        a = stream();
        expect(a.transduce(t.take(2))).toEmit([1, 2, '<end>'], function() {
          return send(a, [1, 2, 3, 4]);
        });
        a = stream();
        return expect(a.transduce(t.take(2))).toEmit([1, '<end>'], function() {
          return send(a, [1, '<end>']);
        });
      });
      it('`map.filter.take` should work', function() {
        var a, tr;
        tr = comp(t.map(function(x) {
          return x + 10;
        }), t.filter(function(x) {
          return x % 2 === 0;
        }), t.take(2));
        a = stream();
        return expect(a.transduce(tr)).toEmit([12, 14, '<end>'], function() {
          return send(a, [1, 2, 3, 4, 5, 6]);
        });
      });
      if (t.partitionAll) {
        it('`partitionAll` should work', function() {
          var a;
          a = stream();
          expect(a.transduce(t.partitionAll(2))).toEmit([[1, 2], [3, 4], '<end>'], function() {
            return send(a, [1, 2, 3, 4, '<end>']);
          });
          a = stream();
          return expect(a.transduce(t.partitionAll(2))).toEmit([[1, 2], [3], '<end>'], function() {
            return send(a, [1, 2, 3, '<end>']);
          });
        });
        return it('`take.partitionAll` should work', function() {
          var a, tr;
          tr = comp(t.take(3), t.partitionAll(2));
          a = stream();
          expect(a.transduce(tr)).toEmit([[1, 2], [3], '<end>'], function() {
            return send(a, [1, 2, 3, 4, '<end>']);
          });
          tr = comp(t.take(2), t.partitionAll(2));
          a = stream();
          return expect(a.transduce(tr)).toEmit([[1, 2], '<end>'], function() {
            return send(a, [1, 2, 3, 4, '<end>']);
          });
        });
      }
    });
    return describe('property', function() {
      it('`map` should work', function() {
        var a;
        a = send(prop(), [1]);
        return expect(a.transduce(t.map(function(x) {
          return x * 2;
        }))).toEmit([
          {
            current: 2
          }, 4, 6, '<end>'
        ], function() {
          return send(a, [2, 3, '<end>']);
        });
      });
      it('`filter` should work', function() {
        var a;
        a = send(prop(), [1]);
        expect(a.transduce(t.filter(function(x) {
          return x % 2 === 0;
        }))).toEmit([2, 4, '<end>'], function() {
          return send(a, [2, 3, 4, '<end>']);
        });
        a = send(prop(), [2]);
        return expect(a.transduce(t.filter(function(x) {
          return x % 2 === 0;
        }))).toEmit([
          {
            current: 2
          }, 4, '<end>'
        ], function() {
          return send(a, [1, 3, 4, '<end>']);
        });
      });
      it('`take` should work', function() {
        var a;
        a = send(prop(), [1]);
        expect(a.transduce(t.take(2))).toEmit([
          {
            current: 1
          }, 2, '<end>'
        ], function() {
          return send(a, [2, 3, 4]);
        });
        a = send(prop(), [1]);
        return expect(a.transduce(t.take(3))).toEmit([
          {
            current: 1
          }, 2, '<end>'
        ], function() {
          return send(a, [2, '<end>']);
        });
      });
      it('`map.filter.take` should work', function() {
        var a, tr;
        tr = comp(t.map(function(x) {
          return x + 10;
        }), t.filter(function(x) {
          return x % 2 === 0;
        }), t.take(2));
        a = send(prop(), [1]);
        expect(a.transduce(tr)).toEmit([12, 14, '<end>'], function() {
          return send(a, [2, 3, 4, 5, 6]);
        });
        a = send(prop(), [2]);
        return expect(a.transduce(tr)).toEmit([
          {
            current: 12
          }, 14, '<end>'
        ], function() {
          return send(a, [1, 3, 4, 5, 6]);
        });
      });
      if (t.partitionAll) {
        it('`partitionAll` should work', function() {
          var a;
          a = send(prop(), [1]);
          expect(a.transduce(t.partitionAll(2))).toEmit([[1, 2], [3, 4], '<end>'], function() {
            return send(a, [2, 3, 4, '<end>']);
          });
          a = send(prop(), [1]);
          return expect(a.transduce(t.partitionAll(2))).toEmit([[1, 2], [3], '<end>'], function() {
            return send(a, [2, 3, '<end>']);
          });
        });
        return it('`take.partitionAll` should work', function() {
          var a, tr;
          tr = comp(t.take(3), t.partitionAll(2));
          a = send(prop(), [1]);
          expect(a.transduce(tr)).toEmit([[1, 2], [3], '<end>'], function() {
            return send(a, [2, 3, 4, '<end>']);
          });
          tr = comp(t.take(2), t.partitionAll(2));
          a = send(prop(), [1]);
          return expect(a.transduce(tr)).toEmit([[1, 2], '<end>'], function() {
            return send(a, [2, 3, 4, '<end>']);
          });
        });
      }
    });
  });
};

noop = function(x) {
  return x;
};

describe('transduce', function() {
  describe('with `noop` transducer', function() {
    describe('stream', function() {
      it('should return stream', function() {
        return expect(stream().transduce(noop)).toBeStream();
      });
      it('should activate/deactivate source', function() {
        var a;
        a = stream();
        return expect(a.transduce(noop)).toActivate(a);
      });
      it('should be ended if source was ended', function() {
        return expect(send(stream(), ['<end>']).transduce(noop)).toEmit(['<end:current>']);
      });
      return it('should handle events', function() {
        var a;
        a = stream();
        return expect(a.transduce(noop)).toEmit([
          1, 2, {
            error: 4
          }, 3, '<end>'
        ], function() {
          return send(a, [
            1, 2, {
              error: 4
            }, 3, '<end>'
          ]);
        });
      });
    });
    return describe('property', function() {
      it('should return property', function() {
        return expect(prop().transduce(noop)).toBeProperty();
      });
      it('should activate/deactivate source', function() {
        var a;
        a = prop();
        return expect(a.transduce(noop)).toActivate(a);
      });
      it('should be ended if source was ended', function() {
        return expect(send(prop(), ['<end>']).transduce(noop)).toEmit(['<end:current>']);
      });
      return it('should handle events and current', function() {
        var a;
        a = send(prop(), [1]);
        expect(a.transduce(noop)).toEmit([
          {
            current: 1
          }, 2, {
            error: 4
          }, 3, '<end>'
        ], function() {
          return send(a, [
            2, {
              error: 4
            }, 3, '<end>'
          ]);
        });
        a = send(prop(), [
          {
            error: 0
          }
        ]);
        return expect(a.transduce(noop)).toEmit([
          {
            currentError: 0
          }, 2, {
            error: 4
          }, 3, '<end>'
        ], function() {
          return send(a, [
            2, {
              error: 4
            }, 3, '<end>'
          ]);
        });
      });
    });
  });
  testWithLib('Cognitect Labs', require('transducers-js'));
  return testWithLib('James Long\'s', require('transducers.js'));
});


},{"../test-helpers.coffee":249,"transducers-js":172,"transducers.js":173}],245:[function(require,module,exports){
var Kefir, handler, prop, ref, send, stream;

ref = require('../test-helpers.coffee'), stream = ref.stream, prop = ref.prop, send = ref.send, Kefir = ref.Kefir;

handler = function(x) {
  return {
    convert: x < 0,
    error: x * 3
  };
};

describe('valuesToErrors', function() {
  describe('stream', function() {
    it('should return stream', function() {
      return expect(stream().valuesToErrors(function() {})).toBeStream();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = stream();
      return expect(a.valuesToErrors(function() {})).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(stream(), ['<end>']).valuesToErrors(function() {})).toEmit(['<end:current>']);
    });
    it('should handle events', function() {
      var a;
      a = stream();
      return expect(a.valuesToErrors(handler)).toEmit([
        1, {
          error: -6
        }, {
          error: -3
        }, {
          error: -12
        }, 5, '<end>'
      ], function() {
        return send(a, [
          1, -2, {
            error: -3
          }, -4, 5, '<end>'
        ]);
      });
    });
    return it('default handler should convert all values', function() {
      var a;
      a = stream();
      return expect(a.valuesToErrors()).toEmit([
        {
          error: 1
        }, {
          error: -2
        }, {
          error: -3
        }, {
          error: -4
        }, {
          error: 5
        }, '<end>'
      ], function() {
        return send(a, [
          1, -2, {
            error: -3
          }, -4, 5, '<end>'
        ]);
      });
    });
  });
  return describe('property', function() {
    it('should return property', function() {
      return expect(prop().valuesToErrors(function() {})).toBeProperty();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = prop();
      return expect(a.valuesToErrors(function() {})).toActivate(a);
    });
    it('should be ended if source was ended', function() {
      return expect(send(prop(), ['<end>']).valuesToErrors(function() {})).toEmit(['<end:current>']);
    });
    it('should handle events', function() {
      var a;
      a = send(prop(), [1]);
      return expect(a.valuesToErrors(handler)).toEmit([
        {
          current: 1
        }, {
          error: -6
        }, {
          error: -3
        }, {
          error: -12
        }, 5, '<end>'
      ], function() {
        return send(a, [
          -2, {
            error: -3
          }, -4, 5, '<end>'
        ]);
      });
    });
    return it('should handle currents', function() {
      var a;
      a = send(prop(), [2]);
      expect(a.valuesToErrors(handler)).toEmit([
        {
          current: 2
        }
      ]);
      a = send(prop(), [-2]);
      expect(a.valuesToErrors(handler)).toEmit([
        {
          currentError: -6
        }
      ]);
      a = send(prop(), [
        {
          error: -2
        }
      ]);
      return expect(a.valuesToErrors(handler)).toEmit([
        {
          currentError: -2
        }
      ]);
    });
  });
});


},{"../test-helpers.coffee":249}],246:[function(require,module,exports){
var Kefir, prop, ref, send, stream;

ref = require('../test-helpers.coffee'), stream = ref.stream, prop = ref.prop, send = ref.send, Kefir = ref.Kefir;

describe('withHandler', function() {
  var duplicate, emitEventMirror, mirror;
  mirror = function(emitter, event) {
    switch (event.type) {
      case 'value':
        return emitter.emit(event.value);
      case 'error':
        return emitter.error(event.value);
      case 'end':
        return emitter.end();
    }
  };
  emitEventMirror = function(emitter, event) {
    return emitter.emitEvent(event);
  };
  duplicate = function(emitter, event) {
    if (event.type === 'value') {
      emitter.emit(event.value);
      if (!event.current) {
        return emitter.emit(event.value);
      }
    } else if (event.type === 'error') {
      emitter.error(event.value);
      if (!event.current) {
        return emitter.error(event.value);
      }
    } else {
      return emitter.end();
    }
  };
  describe('stream', function() {
    it('should return stream', function() {
      return expect(stream().withHandler(function() {})).toBeStream();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = stream();
      return expect(a.withHandler(function() {})).toActivate(a);
    });
    it('should not be ended if source was ended (by default)', function() {
      return expect(send(stream(), ['<end>']).withHandler(function() {})).toEmit([]);
    });
    it('should be ended if source was ended (with `mirror` handler)', function() {
      return expect(send(stream(), ['<end>']).withHandler(mirror)).toEmit(['<end:current>']);
    });
    it('should handle events (with `duplicate` handler)', function() {
      var a;
      a = stream();
      return expect(a.withHandler(duplicate)).toEmit([
        1, 1, {
          error: 3
        }, {
          error: 3
        }, 2, 2, '<end>'
      ], function() {
        return send(a, [
          1, {
            error: 3
          }, 2, '<end>'
        ]);
      });
    });
    it('should automatically preserve isCurent (end)', function() {
      var a;
      a = stream();
      expect(a.withHandler(mirror)).toEmit(['<end>'], function() {
        return send(a, ['<end>']);
      });
      return expect(a.withHandler(mirror)).toEmit(['<end:current>']);
    });
    return it('should support emitter.emitEvent', function() {
      var a;
      a = stream();
      return expect(a.withHandler(emitEventMirror)).toEmit([
        1, {
          error: 3
        }, 2, '<end>'
      ], function() {
        return send(a, [
          1, {
            error: 3
          }, 2, '<end>'
        ]);
      });
    });
  });
  return describe('property', function() {
    it('should return property', function() {
      return expect(prop().withHandler(function() {})).toBeProperty();
    });
    it('should activate/deactivate source', function() {
      var a;
      a = prop();
      return expect(a.withHandler(function() {})).toActivate(a);
    });
    it('should not be ended if source was ended (by default)', function() {
      return expect(send(prop(), ['<end>']).withHandler(function() {})).toEmit([]);
    });
    it('should be ended if source was ended (with `mirror` handler)', function() {
      return expect(send(prop(), ['<end>']).withHandler(mirror)).toEmit(['<end:current>']);
    });
    it('should handle events and current (with `duplicate` handler)', function() {
      var a;
      a = send(prop(), [1]);
      expect(a.withHandler(duplicate)).toEmit([
        {
          current: 1
        }, 2, 2, {
          error: 4
        }, {
          error: 4
        }, 3, 3, '<end>'
      ], function() {
        return send(a, [
          2, {
            error: 4
          }, 3, '<end>'
        ]);
      });
      a = send(prop(), [
        {
          error: 0
        }
      ]);
      return expect(a.withHandler(duplicate)).toEmit([
        {
          currentError: 0
        }, 2, 2, {
          error: 4
        }, {
          error: 4
        }, 3, 3, '<end>'
      ], function() {
        return send(a, [
          2, {
            error: 4
          }, 3, '<end>'
        ]);
      });
    });
    it('should support emitter.emitEvent', function() {
      var a;
      a = send(prop(), [1]);
      expect(a.withHandler(emitEventMirror)).toEmit([
        {
          current: 1
        }, 2, {
          error: 4
        }, 3, '<end>'
      ], function() {
        return send(a, [
          2, {
            error: 4
          }, 3, '<end>'
        ]);
      });
      return expect(send(prop(), [
        {
          error: -1
        }
      ]).withHandler(emitEventMirror)).toEmit([
        {
          currentError: -1
        }
      ]);
    });
    it('should automatically preserve isCurent (end)', function() {
      var a;
      a = prop();
      expect(a.withHandler(mirror)).toEmit(['<end>'], function() {
        return send(a, ['<end>']);
      });
      return expect(a.withHandler(mirror)).toEmit(['<end:current>']);
    });
    it('should automatically preserve isCurent (value)', function() {
      var a, savedEmitter;
      a = prop();
      expect(a.withHandler(mirror)).toEmit([1], function() {
        return send(a, [1]);
      });
      expect(a.withHandler(mirror)).toEmit([
        {
          current: 1
        }
      ]);
      savedEmitter = null;
      return expect(a.withHandler(function(emitter, event) {
        mirror(emitter, event);
        return savedEmitter = emitter;
      })).toEmit([
        {
          current: 1
        }, 2
      ], function() {
        return savedEmitter.emit(2);
      });
    });
    return it('should automatically preserve isCurent (error)', function() {
      var a, savedEmitter;
      a = prop();
      expect(a.withHandler(mirror)).toEmit([
        {
          error: 1
        }
      ], function() {
        return send(a, [
          {
            error: 1
          }
        ]);
      });
      expect(a.withHandler(mirror)).toEmit([
        {
          currentError: 1
        }
      ]);
      savedEmitter = null;
      return expect(a.withHandler(function(emitter, event) {
        mirror(emitter, event);
        return savedEmitter = emitter;
      })).toEmit([
        {
          currentError: 1
        }, {
          error: 2
        }
      ], function() {
        return savedEmitter.emit({
          error: 2
        });
      });
    });
  });
});


},{"../test-helpers.coffee":249}],247:[function(require,module,exports){
var Kefir;

Kefir = require('../../dist/kefir');

describe('withInterval', function() {
  it('should return stream', function() {
    return expect(Kefir.withInterval(100, function() {})).toBeStream();
  });
  it('should work as expected', function() {
    var fn, i;
    i = 0;
    fn = function(emitter) {
      i++;
      if (i === 2) {
        emitter.error(-1);
      } else {
        emitter.emit(i);
        emitter.emit(i * 2);
      }
      if (i === 3) {
        return emitter.end();
      }
    };
    return expect(Kefir.withInterval(100, fn)).toEmitInTime([
      [100, 1], [100, 2], [
        200, {
          error: -1
        }
      ], [300, 3], [300, 6], [300, '<end>']
    ]);
  });
  return it('should support emitter.emitEvent', function() {
    var fn, i;
    i = 0;
    fn = function(emitter) {
      i++;
      if (i === 2) {
        emitter.emitEvent({
          type: 'error',
          value: -1,
          current: false
        });
      } else {
        emitter.emitEvent({
          type: 'value',
          value: i,
          current: true
        });
        emitter.emitEvent({
          type: 'value',
          value: i * 2,
          current: false
        });
      }
      if (i === 3) {
        return emitter.emitEvent({
          type: 'end',
          value: void 0,
          current: false
        });
      }
    };
    return expect(Kefir.withInterval(100, fn)).toEmitInTime([
      [100, 1], [100, 2], [
        200, {
          error: -1
        }
      ], [300, 3], [300, 6], [300, '<end>']
    ]);
  });
});


},{"../../dist/kefir":1}],248:[function(require,module,exports){
var Kefir, activate, deactivate, prop, ref, send, stream,
  slice = [].slice;

ref = require('../test-helpers.coffee'), stream = ref.stream, prop = ref.prop, send = ref.send, activate = ref.activate, deactivate = ref.deactivate, Kefir = ref.Kefir;

describe('zip', function() {
  it('should return stream', function() {
    expect(Kefir.zip([])).toBeStream();
    expect(Kefir.zip([stream(), prop()])).toBeStream();
    expect(stream().zip(stream())).toBeStream();
    return expect(prop().zip(prop())).toBeStream();
  });
  it('should be ended if empty array provided', function() {
    return expect(Kefir.zip([])).toEmit(['<end:current>']);
  });
  it('should be ended if array of ended observables provided', function() {
    var a, b, c;
    a = send(stream(), ['<end>']);
    b = send(prop(), ['<end>']);
    c = send(stream(), ['<end>']);
    expect(Kefir.zip([a, b, c])).toEmit(['<end:current>']);
    return expect(a.zip(b)).toEmit(['<end:current>']);
  });
  it('should be ended and has current if array of ended properties provided and each of them has current', function() {
    var a, b, c;
    a = send(prop(), [1, '<end>']);
    b = send(prop(), [2, '<end>']);
    c = send(prop(), [3, '<end>']);
    expect(Kefir.zip([a, b, c])).toEmit([
      {
        current: [1, 2, 3]
      }, '<end:current>'
    ]);
    return expect(a.zip(b)).toEmit([
      {
        current: [1, 2]
      }, '<end:current>'
    ]);
  });
  it('should activate sources', function() {
    var a, b, c;
    a = stream();
    b = prop();
    c = stream();
    expect(Kefir.zip([a, b, c])).toActivate(a, b, c);
    return expect(a.zip(b)).toActivate(a, b);
  });
  it('should handle events and current from observables', function() {
    var a, b, c;
    a = stream();
    b = send(prop(), [0]);
    c = stream();
    expect(Kefir.zip([a, b, c])).toEmit([[1, 0, 3], [4, 2, 5], [6, 9, 8], '<end>'], function() {
      send(a, [1]);
      send(b, [2]);
      send(c, [3]);
      send(a, [4]);
      send(c, [5]);
      send(a, [6, 7]);
      send(c, [8]);
      send(b, [9, '<end>']);
      send(a, ['<end>']);
      return send(c, ['<end>']);
    });
    a = stream();
    b = send(prop(), [0]);
    return expect(a.zip(b)).toEmit([[1, 0], [3, 2], '<end>'], function() {
      send(b, [2]);
      send(a, [1, 3, '<end>']);
      return send(b, ['<end>']);
    });
  });
  it('should support arrays', function() {
    var a, b, c;
    a = [1, 4, 6, 7];
    b = send(prop(), [0]);
    c = stream();
    expect(Kefir.zip([a, b, c])).toEmit([[1, 0, 3], [4, 2, 5], [6, 9, 8], '<end>'], function() {
      send(b, [2]);
      send(c, [3]);
      send(c, [5]);
      send(c, [8]);
      send(b, [9, '<end>']);
      return send(c, ['<end>']);
    });
    a = [1, 3];
    b = send(prop(), [0]);
    return expect(b.zip(a)).toEmit([
      {
        current: [0, 1]
      }, [2, 3], '<end>'
    ], function() {
      send(b, [2]);
      return send(b, ['<end>']);
    });
  });
  it('should work with arrays only', function() {
    return expect(Kefir.zip([[1, 2, 3], [4, 5], [6, 7, 8, 9]])).toEmit([
      {
        current: [1, 4, 6]
      }, {
        current: [2, 5, 7]
      }, '<end:current>'
    ]);
  });
  it('should accept optional combinator function', function() {
    var a, b, c, join;
    join = function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return args.join('+');
    };
    a = stream();
    b = send(prop(), [0]);
    c = stream();
    expect(Kefir.zip([a, b, c], join)).toEmit(['1+0+3', '4+2+5', '6+9+8', '<end>'], function() {
      send(a, [1]);
      send(b, [2]);
      send(c, [3]);
      send(a, [4]);
      send(c, [5]);
      send(a, [6, 7]);
      send(c, [8]);
      send(b, [9, '<end>']);
      send(a, ['<end>']);
      return send(c, ['<end>']);
    });
    a = stream();
    b = send(prop(), [0]);
    return expect(a.zip(b, join)).toEmit(['1+0', '3+2', '<end>'], function() {
      send(b, [2]);
      send(a, [1, 3, '<end>']);
      return send(b, ['<end>']);
    });
  });
  it('errors should flow', function() {
    var a, b, c;
    a = stream();
    b = prop();
    c = stream();
    expect(Kefir.zip([a, b, c])).errorsToFlow(a);
    a = stream();
    b = prop();
    c = stream();
    expect(Kefir.zip([a, b, c])).errorsToFlow(b);
    a = stream();
    b = prop();
    c = stream();
    return expect(Kefir.zip([a, b, c])).errorsToFlow(c);
  });
  it('when activating second time and has 2+ properties in sources, should emit current value at most once', function() {
    var a, b, cb;
    a = send(prop(), [0]);
    b = send(prop(), [1]);
    cb = Kefir.zip([a, b]);
    activate(cb);
    deactivate(cb);
    return expect(cb).toEmit([
      {
        current: [0, 1]
      }
    ]);
  });
  return it('should work correctly when unsuscribing after one sync event', function() {
    var a, a0, b, b0, c, c1;
    a0 = stream();
    a = a0.toProperty(function() {
      return 1;
    });
    b0 = stream();
    b = b0.toProperty(function() {
      return 1;
    });
    c = Kefir.zip([a, b]);
    activate(c1 = c.take(2));
    send(b0, [1, 1]);
    send(a0, [1]);
    deactivate(c1);
    activate(c.take(1));
    return expect(b).not.toBeActive();
  });
});


},{"../test-helpers.coffee":249}],249:[function(require,module,exports){
var Kefir, _activateHelper, logItem, shakeTimers, sinon,
  slice = [].slice;

Kefir = require("../dist/kefir");

sinon = require('sinon');

Kefir.dissableDeprecationWarnings();

exports.Kefir = Kefir;

logItem = function(event, isCurrent) {
  if (event.type === 'value') {
    if (isCurrent) {
      return {
        current: event.value
      };
    } else {
      return event.value;
    }
  } else if (event.type === 'error') {
    if (isCurrent) {
      return {
        currentError: event.value
      };
    } else {
      return {
        error: event.value
      };
    }
  } else {
    if (isCurrent) {
      return '<end:current>';
    } else {
      return '<end>';
    }
  }
};

exports.watch = function(obs) {
  var fn, isCurrent, log, unwatch;
  log = [];
  fn = function(event) {
    return log.push(logItem(event, isCurrent));
  };
  unwatch = function() {
    return obs.offAny(fn);
  };
  isCurrent = true;
  obs.onAny(fn);
  isCurrent = false;
  return {
    log: log,
    unwatch: unwatch
  };
};

exports.watchWithTime = function(obs) {
  var isCurrent, log, startTime;
  startTime = new Date();
  log = [];
  isCurrent = true;
  obs.onAny(function(event) {
    return log.push([new Date() - startTime, logItem(event, isCurrent)]);
  });
  isCurrent = false;
  return log;
};

exports.send = function(obs, events) {
  var event, j, len;
  for (j = 0, len = events.length; j < len; j++) {
    event = events[j];
    if (event === '<end>') {
      obs._emitEnd();
    }
    if (typeof event === 'object' && 'error' in event) {
      obs._emitError(event.error);
    } else {
      obs._emitValue(event);
    }
  }
  return obs;
};

_activateHelper = function() {};

exports.activate = function(obs) {
  obs.onEnd(_activateHelper);
  return obs;
};

exports.deactivate = function(obs) {
  obs.offEnd(_activateHelper);
  return obs;
};

exports.prop = function() {
  return new Kefir.Property();
};

exports.stream = function() {
  return new Kefir.Stream();
};

shakeTimers = function(clock) {
  var ids, timers;
  ids = Object.keys(clock.timers);
  timers = ids.map(function(id) {
    return clock.timers[id];
  });
  timers.sort(function(a, b) {
    if (a.callAt < b.callAt) {
      return -1;
    }
    if (a.callAt > b.callAt) {
      return 1;
    }
    if (a.immediate && !b.immediate) {
      return -1;
    }
    if (!a.immediate && b.immediate) {
      return 1;
    }
    if (a.createdAt < b.createdAt) {
      return 1;
    }
    if (a.createdAt > b.createdAt) {
      return -1;
    }
    if (a.id < b.id) {
      return 1;
    }
    if (a.id > b.id) {
      return -1;
    }
  });
  ids.sort(function(a, b) {
    return a - b;
  });
  return timers.forEach(function(timer, i) {
    var id;
    id = ids[i];
    timer.createdAt = 0;
    timer.id = id;
    return clock.timers[id] = timer;
  });
};

exports.withFakeTime = function(cb, reverseSimultaneous) {
  var clock, tick;
  if (reverseSimultaneous == null) {
    reverseSimultaneous = false;
  }
  clock = sinon.useFakeTimers(10000);
  tick = function(t) {
    if (reverseSimultaneous) {
      shakeTimers(clock);
    }
    return clock.tick(t);
  };
  cb(tick, clock);
  return clock.restore();
};

exports.inBrowser = (typeof window !== "undefined" && window !== null) && (typeof document !== "undefined" && document !== null);

exports.withDOM = function(cb) {
  var div;
  div = document.createElement('div');
  document.body.appendChild(div);
  cb(div);
  return document.body.removeChild(div);
};

exports.shakyTimeTest = function(testCb) {
  it('[shaky time test: normal run]', function() {
    var expectToEmitOverShakyTime;
    expectToEmitOverShakyTime = function(stream, expectedLog, cb, timeLimit) {
      return expect(stream).toEmitInTime(expectedLog, cb, timeLimit);
    };
    return testCb(expectToEmitOverShakyTime);
  });
  return it('[shaky time test: reverse run]', function() {
    var expectToEmitOverShakyTime;
    expectToEmitOverShakyTime = function(stream, expectedLog, cb, timeLimit) {
      return expect(stream).toEmitInTime(expectedLog, cb, timeLimit, true);
    };
    return testCb(expectToEmitOverShakyTime);
  });
};

beforeEach(function() {
  return this.addMatchers({
    toBeProperty: function() {
      this.message = function() {
        return "Expected " + (this.actual.toString()) + " to be instance of Property";
      };
      return this.actual instanceof Kefir.Property;
    },
    toBeStream: function() {
      this.message = function() {
        return "Expected " + (this.actual.toString()) + " to be instance of Stream";
      };
      return this.actual instanceof Kefir.Stream;
    },
    toBePool: function() {
      this.message = function() {
        return "Expected " + (this.actual.toString()) + " to be instance of Pool";
      };
      return this.actual instanceof Kefir.Pool;
    },
    toBeActive: function() {
      return this.actual._active;
    },
    toEmit: function(expectedLog, cb) {
      var log, ref, unwatch;
      ref = exports.watch(this.actual), log = ref.log, unwatch = ref.unwatch;
      if (typeof cb === "function") {
        cb();
      }
      unwatch();
      this.message = function() {
        return "Expected to emit " + (jasmine.pp(expectedLog)) + ", actually emitted " + (jasmine.pp(log));
      };
      return this.env.equals_(expectedLog, log);
    },
    errorsToFlow: function(source) {
      var expectedLog, log, ref, unwatch;
      expectedLog = this.isNot ? [] : [
        {
          error: -2
        }, {
          error: -3
        }
      ];
      if (this.actual instanceof Kefir.Property) {
        exports.activate(this.actual);
        exports.send(source, [
          {
            error: -1
          }
        ]);
        exports.deactivate(this.actual);
        if (!this.isNot) {
          expectedLog.unshift({
            currentError: -1
          });
        }
      } else if (source instanceof Kefir.Property) {
        exports.send(source, [
          {
            error: -1
          }
        ]);
        if (!this.isNot) {
          expectedLog.unshift({
            currentError: -1
          });
        }
      }
      ref = exports.watch(this.actual), log = ref.log, unwatch = ref.unwatch;
      exports.send(source, [
        {
          error: -2
        }, {
          error: -3
        }
      ]);
      unwatch();
      if (this.isNot) {
        this.message = function() {
          return "Expected errors not to flow (i.e. to emit [], actually emitted " + (jasmine.pp(log)) + ")";
        };
        return !this.env.equals_(expectedLog, log);
      } else {
        this.message = function() {
          return "Expected errors to flow (i.e. to emit " + (jasmine.pp(expectedLog)) + ", actually emitted " + (jasmine.pp(log)) + ")";
        };
        return this.env.equals_(expectedLog, log);
      }
    },
    toEmitInTime: function(expectedLog, cb, timeLimit, reverseSimultaneous) {
      var log;
      if (timeLimit == null) {
        timeLimit = 10000;
      }
      if (reverseSimultaneous == null) {
        reverseSimultaneous = false;
      }
      log = null;
      exports.withFakeTime((function(_this) {
        return function(tick) {
          log = exports.watchWithTime(_this.actual);
          if (typeof cb === "function") {
            cb(tick);
          }
          return tick(timeLimit);
        };
      })(this), reverseSimultaneous);
      this.message = function() {
        return "Expected to emit " + (jasmine.pp(expectedLog)) + ", actually emitted " + (jasmine.pp(log));
      };
      return this.env.equals_(expectedLog, log);
    },
    toActivate: function() {
      var andOp, check, correctResults, name, notNotStr, notStr, obs, obss, orOp, tests;
      obss = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      orOp = function(a, b) {
        return a || b;
      };
      andOp = function(a, b) {
        return a && b;
      };
      notStr = (this.isNot ? 'not ' : '');
      notNotStr = (this.isNot ? '' : 'not ');
      tests = {};
      tests["some activated at start"] = true;
      tests["some " + notNotStr + "activated"] = true;
      tests["some " + notNotStr + "deactivated"] = true;
      tests["some " + notNotStr + "activated at second try"] = true;
      tests["some " + notNotStr + "deactivated at second try"] = true;
      correctResults = {};
      correctResults["some activated at start"] = true;
      correctResults["some " + notNotStr + "activated"] = true;
      correctResults["some " + notNotStr + "deactivated"] = true;
      correctResults["some " + notNotStr + "activated at second try"] = true;
      correctResults["some " + notNotStr + "deactivated at second try"] = true;
      if (this.isNot) {
        correctResults["some " + notNotStr + "activated"] = false;
        correctResults["some " + notNotStr + "activated at second try"] = false;
      }
      check = function(test, conditions) {
        var condition, j, k, len, len1;
        if (correctResults[test] === true) {
          for (j = 0, len = conditions.length; j < len; j++) {
            condition = conditions[j];
            if (!condition) {
              tests[test] = false;
              return;
            }
          }
        } else {
          for (k = 0, len1 = conditions.length; k < len1; k++) {
            condition = conditions[k];
            if (condition) {
              return;
            }
          }
          return tests[test] = false;
        }
      };
      check("some activated at start", (function() {
        var j, len, results;
        results = [];
        for (j = 0, len = obss.length; j < len; j++) {
          obs = obss[j];
          results.push(!obs._active);
        }
        return results;
      })());
      exports.activate(this.actual);
      check("some " + notNotStr + "activated", (function() {
        var j, len, results;
        results = [];
        for (j = 0, len = obss.length; j < len; j++) {
          obs = obss[j];
          results.push(obs._active);
        }
        return results;
      })());
      exports.deactivate(this.actual);
      check("some " + notNotStr + "deactivated", (function() {
        var j, len, results;
        results = [];
        for (j = 0, len = obss.length; j < len; j++) {
          obs = obss[j];
          results.push(!obs._active);
        }
        return results;
      })());
      exports.activate(this.actual);
      check("some " + notNotStr + "activated at second try", (function() {
        var j, len, results;
        results = [];
        for (j = 0, len = obss.length; j < len; j++) {
          obs = obss[j];
          results.push(obs._active);
        }
        return results;
      })());
      exports.deactivate(this.actual);
      check("some " + notNotStr + "deactivated at second try", (function() {
        var j, len, results;
        results = [];
        for (j = 0, len = obss.length; j < len; j++) {
          obs = obss[j];
          results.push(!obs._active);
        }
        return results;
      })());
      this.message = function() {
        var failedTest, name, obssNames;
        failedTest = ((function() {
          var results;
          results = [];
          for (name in tests) {
            if (tests[name] !== correctResults[name]) {
              results.push(name);
            }
          }
          return results;
        })()).join(', ');
        obssNames = ((function() {
          var j, len, results;
          results = [];
          for (j = 0, len = obss.length; j < len; j++) {
            obs = obss[j];
            results.push(obs.toString());
          }
          return results;
        })()).join(', ');
        return "Expected " + (this.actual.toString()) + " to " + notStr + "activate: " + obssNames + " (" + failedTest + ")";
      };
      for (name in tests) {
        if (tests[name] !== correctResults[name]) {
          return this.isNot;
        }
      }
      return !this.isNot;
    }
  });
});


},{"../dist/kefir":1,"sinon":144}]},{},[215,234,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,235,236,237,238,239,240,241,242,243,244,245,246,247,248]);
