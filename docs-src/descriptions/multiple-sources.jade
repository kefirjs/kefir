h2#combine-observables Combine observables



+descr-method('combine', 'combine', 'Kefir.combine(obss, [passiveObss], [combinator])', 'obs.combine(otherObs, [combinator])').
  Returns a stream.
  Combines two or more observables together. On each value from any source
  observable (#[b obss] array), emits a combined value, generated by the #[b combinator]
  function from the latest values from each source observable. The #[b combinator]
  function is called with the latest values as arguments.
  If no #[b combinator] is provided, it emits an array containing the latest values.

pre.javascript(title='example')
  :escapehtml
    var a = Kefir.sequentially(100, [1, 3]);
    var b = Kefir.sequentially(100, [2, 4]).delay(40);

    var result = Kefir.combine([a, b], (a, b) => a + b);
    result.log();

pre(title='console output')
  :escapehtml
    > [combine] <value> 3
    > [combine] <value> 5
    > [combine] <value> 7
    > [combine] <end>

pre(title='events in time').
  a:       ----1----3X
  b:       ------2----4X

  result:  ------3--5-7X
div

p.
  You can also pass part of the source observables as #[b passiveObss] in a second array,
  the result stream won't emit on values from #[b passiveObss],
  but all the values will be available in the combinator function.

pre.javascript(title='example')
  :escapehtml
    var a = Kefir.sequentially(100, [1, 3]);
    var b = Kefir.sequentially(100, [2, 4]).delay(40);
    var c = Kefir.sequentially(60, [5, 6, 7]);

    var result = Kefir.combine([a, b], [c], (a, b, c) => a + b + c);
    result.log();

pre(title='console output')
  :escapehtml
    > [combine] <value> 9
    > [combine] <value> 12
    > [combine] <value> 14
    > [combine] <end>

pre(title='events in time').
  a:       ----1----3X
  b:       ------2----4X
  c:       --5--6--7X

  result:  ------•--•-•X
                 9 12 14

div

p.
  Also, #[b combine] supports passing objects as both #[b obss] #[i and] #[b passiveObss].
  The #[b combinator] function will then be called with a single argument, a new object with
  the latest value from each observable. If no #[b combinator] is provided, it emits
  the object containing latest values.

pre.javascript(title='example')
  :escapehtml
    var aStream = Kefir.sequentially(100, [1, 3]);
    var bStream = Kefir.sequentially(100, [2, 4]).delay(40);

    var result = Kefir.combine({ a: aStream, b: bStream });
    result.log();

pre(title='console output')
  :escapehtml
    > [combine] <value> { a: 1, b: 2 }
    > [combine] <value> { a: 3, b: 2 }
    > [combine] <value> { a: 3, b: 4 }
    > [combine] <end>

pre(title='events in time').
  a:       ----1----3X
  b:       ------2----4X

  result:  ------•--•-•X

p.
  #[img(data-emoji="point_up")] If there are duplicate keys in both #[b obss]
  #[i and] #[b passiveObss], only the latest values from #[b obss] will appear
  in the combined object for the duplicated keys.

p.
  The result stream emits a value only when it has at least one value from each of source observables.
  Ends when all the active source observables (#[b obss] array) end.

p.
  You can also combine two observables by calling #[tt a.combine(b, combinator)] if you like.



+descr-method('zip', 'zip', 'Kefir.zip(sources, [combinator])', 'obs.zip(otherObs, [combinator])').
  Creates a stream with values from #[b sources]
  lined up with each other. For example if you have two sources with values
  #[tt [1, 2, 3]] and #[tt [4, 5, 6, 7]], the result stream will emit
  #[tt [1, 4]], #[tt [2, 5]], and #[tt [3, 6]].
  The result stream will emit the next value only when it has at least one value
  from each source.

p.
  You can also provide a #[b combinator] function. In this case, instead
  of emitting an array of values, they will be passed to #[b combinator] as arguments,
  and the returned value will be emitted (same as in #[a(href="#combine") combine])

p.
  Also in #[b zip] you can pass ordinary arrays along with observables
  in the #[b sources], e.g. #[tt Kefir.zip([obs,&nbsp;[1,&nbsp;2,&nbsp;3]],&nbsp;fn)].
  In other words, #[b sources] is an array of observables and arrays,
  or only observables of course.

p.
  The result stream ends when all sources end.

pre.javascript(title='example')
  :escapehtml
    var a = Kefir.sequentially(100, [0, 1, 2, 3]);
    var b = Kefir.sequentially(160, [4, 5, 6]);
    var c = Kefir.sequentially(100, [8, 9]).delay(260).toProperty(() => 7);
    var result = Kefir.zip([a, b, c]);
    result.log();

pre(title='console output')
  :escapehtml
    > [zip] <value> [0, 4, 7]
    > [zip] <value> [1, 5, 8]
    > [zip] <value> [2, 6, 9]
    > [zip] <end>

pre(title='events in time').
  a:    ----0----1----2----3X
  b:    -------4-------5-------6X
  c:   7-----------------8----9X

  abc:  -------•---------•-----•X
         [0,4,7]   [1,5,8]     [2,6,9]
div

p.
  #[img(data-emoji="point_up")] This method sometimes is used incorrectly instead of
  #[a(href='#combine') combine]. Please make sure you understand the difference
  and are making right choice.



+descr-method('merge', 'merge', 'Kefir.merge(obss)', 'obs.merge(otherObs)').
  Merges several #[b obss] observables into a single stream
  i.e., simply repeats values from each source observable.
  Ends when all #[b obss] observables end.

p.
  You can also merge two observables by calling #[tt a.merge(b)], if you like.

pre.javascript(title='example')
  :escapehtml
    var a = Kefir.sequentially(100, [0, 1, 2]);
    var b = Kefir.sequentially(100, [0, 1, 2]).delay(30);
    var c = Kefir.sequentially(100, [0, 1, 2]).delay(60);
    var abc = Kefir.merge([a, b, c]);
    abc.log();

pre(title='console output')
  :escapehtml
    > [merge] <value> 0
    > [merge] <value> 0
    > [merge] <value> 0
    > [merge] <value> 1
    > [merge] <value> 1
    > [merge] <value> 1
    > [merge] <value> 2
    > [merge] <value> 2
    > [merge] <value> 2
    > [merge] <end>

pre(title='events in time').
  a:    ----------0---------1---------2X
  b:    ------------0---------1---------2X
  c:    --------------0---------1---------2X

  abc:  ----------0-0-0-----1-1-1-----2-2-2X
div




+descr-method('concat', 'concat', 'Kefir.concat(obss)', 'obs.concat(otherObs)').
  Concatenates several #[b obss] observables into one stream. Like #[a(href="#merge") merge],
  but switches to the next source only after the previous one end.

pre.javascript(title='example')
  :escapehtml
    var a = Kefir.sequentially(100, [0, 1, 2]);
    var b = Kefir.sequentially(100, [3, 4, 5]);

    var abc = Kefir.concat([a, b]);
    abc.log();

pre(title='console output')
  :escapehtml
    > [concat] <value> 0
    > [concat] <value> 1
    > [concat] <value> 2
    > [concat] <value> 3
    > [concat] <value> 4
    > [concat] <value> 5
    > [concat] <end>

pre(title='events in time').
  a:    ---0---1---2X
  b:                ---3---4---5X

  abc:  ---0---1---2---3---4---5X
div

p.
  #[img(data-emoji="point_up")] This method sometimes is used incorrectly instead of
  #[a(href='#merge') merge]. Please make sure you understand the difference
  and are making right choice.


+descr-method('pool', 'pool', 'Kefir.pool()').
  #[b Pool] is like #[a(href="#merge") merge] to which you
  can dynamically add and remove sources.
  When you create a new #[b pool] it has no sources. Then you can
  add observables to it using the #[b plug] method,
  and remove them using #[b unplug]. #[b Pool] never ends.

pre.javascript(title='example')
  :escapehtml
    var a = Kefir.sequentially(100, [0, 1, 2]);
    var b = Kefir.sequentially(100, [0, 1, 2]).delay(30);
    var c = Kefir.sequentially(100, [0, 1, 2]).delay(60);
    var pool = Kefir.pool();
    pool.plug(a);
    pool.plug(b);
    pool.plug(c);
    pool.log();

pre(title='console output')
  :escapehtml
    > [pool] <value> 0
    > [pool] <value> 0
    > [pool] <value> 0
    > [pool] <value> 1
    > [pool] <value> 1
    > [pool] <value> 1
    > [pool] <value> 2
    > [pool] <value> 2
    > [pool] <value> 2

pre(title='events in time').
  a:    ----------0---------1---------2X
  b:    ------------0---------1---------2X
  c:    --------------0---------1---------2X

  pool: ----------0-0-0-----1-1-1-----2-2-2
div




+descr-method('repeat', 'repeat', 'Kefir.repeat(generator)').
  Calls the #[b generator] function which is supposed to return an observable.
  Emits values and errors from the spawned observable; when it ends,
  calls #[b generator] again to get a new one and so on.

p.
  The #[b generator] function is called with one argument — iteration number
  starting from #[tt 0]. If a falsy value is returned
  from the #[b generator], the stream ends.

pre.javascript(title='example')
  :escapehtml
    var result = Kefir.repeat(i => {
      if (i < 3) {
        return Kefir.sequentially(100, [i, i]);
      } else {
        return false;
      }
    });
    result.log();

pre(title='console output')
  :escapehtml
    > [repeat] <value> 0
    > [repeat] <value> 0
    > [repeat] <value> 1
    > [repeat] <value> 1
    > [repeat] <value> 2
    > [repeat] <value> 2
    > [repeat] <end>

pre(title='events in time').
  spawned 1:  ---0---0X
  spawned 2:          ---1---1X
  spawned 3:                  ---2---2X

  result:     ---0---0---1---1---2---2X
div

p.
  #[img(data-emoji="point_up")] Note that with this method
  it is possible to create an infinite loop. Consider this example:

pre.javascript(title='example')
  :escapehtml
    var result = Kefir.repeat(() => Kefir.constant(1));

    // When we subscribe to it (directly or via .log)
    // we already are in an infinite loop.
    result.log();

    // But if we limit it with .take or something it'll work just fine.
    // So the `result` stream defined like this
    // may still make sense, depending on how we use it.
    result.take(10).log();

p.
  It is even more dangerous if #[b generator] constantly returns an ended observable
  with no values (e.g. #[a(href='#never') never]).
  In this case, #[tt .take] won't help, because you'll never get any single
  value from it, but #[b generator] will be called over and over.
  The only escape path here is to define an escape condition in the
  #[b generator]:

pre.javascript(title='example')
  :escapehtml
    var result = Kefir.repeat(i => {

      // Defining that a new observable will be spawned at most 10 times
      if (i >= 10) {
        return false;
      }

      return Kefir.never();
    });

p.
  So just be careful when using #[b repeat],
  it's a little dangerous but it is still a great method.




+descr-method('flat-map', 'flatMap', 'obs.flatMap([transform])').
  Works similar to <a href="#flatten">flatten</a>,
  but instead of arrays, it handles observables. Like in #[b flatten] you can
  either provide a #[b transform] function which will return observables,
  or you can use the source #[b obs] observable that already emits observables.

p.
  Always returns a stream.

p.
  #[b flatMap] ends when #[b obs] and all spawned observables end.

pre.javascript(title='example')
  :escapehtml
    var source = Kefir.sequentially(100, [1, 2, 3]);
    var result = source.flatMap(x => Kefir.interval(40, x).take(4));
    result.log();

pre(title='console output')
  :escapehtml
    > [sequentially.flatMap] <value> 1
    > [sequentially.flatMap] <value> 1
    > [sequentially.flatMap] <value> 1
    > [sequentially.flatMap] <value> 2
    > [sequentially.flatMap] <value> 1
    > [sequentially.flatMap] <value> 2
    > [sequentially.flatMap] <value> 2
    > [sequentially.flatMap] <value> 3
    > [sequentially.flatMap] <value> 2
    > [sequentially.flatMap] <value> 3
    > [sequentially.flatMap] <value> 3
    > [sequentially.flatMap] <value> 3
    > [sequentially.flatMap] <end>

pre(title='events in time').
  source:      ----------1---------2---------3X

  spawned 1:             ---1---1---1---1X
  spawned 2:                       ---2---2---2---2X
  spawned 3:                                 ---3---3---3---3X

  result:      -------------1---1---1-2-1-2---2-3-2-3---3---3X
div




+descr-method('flat-map-latest', 'flatMapLatest', 'obs.flatMapLatest([fn])').
  Like #[b flatMap], but repeats events only from the latest added observable
  i.e., switching from one observable to another.

pre.javascript(title='example')
  :escapehtml
    var source = Kefir.sequentially(100, [1, 2, 3]);
    var result = source.flatMapLatest(x => Kefir.interval(40, x).take(4));
    result.log();

pre(title='console output')
  :escapehtml
    > [sequentially.flatMapLatest] <value> 1
    > [sequentially.flatMapLatest] <value> 1
    > [sequentially.flatMapLatest] <value> 2
    > [sequentially.flatMapLatest] <value> 2
    > [sequentially.flatMapLatest] <value> 3
    > [sequentially.flatMapLatest] <value> 3
    > [sequentially.flatMapLatest] <value> 3
    > [sequentially.flatMapLatest] <value> 3
    > [sequentially.flatMapLatest] <end>

pre(title='events in time').
  source:      ----------1---------2---------3X

  spawned 1:             ---1---1---1---1X
  spawned 2:                       ---2---2---2---2X
  spawned 3:                                 ---3---3---3---3X

  result:      -------------1---1-----2---2-----3---3---3---3X
div



+descr-method('flat-map-first', 'flatMapFirst', 'obs.flatMapFirst([fn])').
  Like #[b flatMap], but adds a new observable only if the previous one ended.
  Otherwise, it just ignores the new observable.

pre.javascript(title='example')
  :escapehtml
    var source = Kefir.sequentially(100, [1, 2, 3]);
    var result = source.flatMapFirst(x => Kefir.interval(40, x).take(4));
    result.log();

pre(title='console output')
  :escapehtml
    > [sequentially.flatMapFirst] <value> 1
    > [sequentially.flatMapFirst] <value> 1
    > [sequentially.flatMapFirst] <value> 1
    > [sequentially.flatMapFirst] <value> 1
    > [sequentially.flatMapFirst] <value> 3
    > [sequentially.flatMapFirst] <value> 3
    > [sequentially.flatMapFirst] <value> 3
    > [sequentially.flatMapFirst] <value> 3
    > [sequentially.flatMapFirst] <end>

pre(title='events in time').
  source:      ----------1---------2---------3X

  spawned 1:             ---1---1---1---1X
  spawned 2:                       ---2---2---2---2X
  spawned 3:                                 ---3---3---3---3X

  result:      -------------1---1---1---1-------3---3---3---3X
div



+descr-method('flat-map-concat', 'flatMapConcat', 'obs.flatMapConcat([fn])').
  Like #[a(href='#flat-map-first') flatMapFirst], but instead of ignoring new observables
  (if the previous one is still alive), it adds them to the queue.
  Then, when the current source ends, it takes the oldest observable from the queue,
  and switches to it.

pre.javascript(title='example')
  :escapehtml
    var source = Kefir.sequentially(100, [1, 2, 3]);
    var result = source.flatMapConcat(x => Kefir.interval(40, x).take(4));
    result.log();

pre(title='console output')
  :escapehtml
    > [sequentially.flatMapConcat] <value> 1
    > [sequentially.flatMapConcat] <value> 1
    > [sequentially.flatMapConcat] <value> 1
    > [sequentially.flatMapConcat] <value> 1
    > [sequentially.flatMapConcat] <value> 2
    > [sequentially.flatMapConcat] <value> 2
    > [sequentially.flatMapConcat] <value> 2
    > [sequentially.flatMapConcat] <value> 2
    > [sequentially.flatMapConcat] <value> 3
    > [sequentially.flatMapConcat] <value> 3
    > [sequentially.flatMapConcat] <value> 3
    > [sequentially.flatMapConcat] <value> 3
    > [sequentially.flatMapConcat] <end>

pre(title='events in time').
  source:      ----------1---------2---------3X

  spawned 1:             ---1---1---1---1X
  spawned 2:                             ---2---2---2---2X
  spawned 3:                                             ---3---3---3---3X

  result:      -------------1---1---1---1---2---2---2---2---3---3---3---3X
div



+descr-method('flat-map-with-concurrency-limit', 'flatMapConcurLimit', 'obs.flatMapConcurLimit([fn], limit)').
  Like #[a(href='#flat-map-concat') flatMapConcat], but with a configurable number of concurent sources.
  In other words #[b flatMapConcat] is #[tt flatMapConcurLimit(fn, 1)].

pre.javascript(title='example')
  :escapehtml
    var source = Kefir.sequentially(100, [1, 2, 3]);
    var result = source.flatMapConcurLimit(x => Kefir.interval(40, x).take(6), 2);
    result.log();

pre(title='console output')
  :escapehtml
    > [sequentially.flatMapConcurLimit] <value> 1
    > [sequentially.flatMapConcurLimit] <value> 1
    > [sequentially.flatMapConcurLimit] <value> 1
    > [sequentially.flatMapConcurLimit] <value> 2
    > [sequentially.flatMapConcurLimit] <value> 1
    > [sequentially.flatMapConcurLimit] <value> 2
    > [sequentially.flatMapConcurLimit] <value> 1
    > [sequentially.flatMapConcurLimit] <value> 2
    > [sequentially.flatMapConcurLimit] <value> 1
    > [sequentially.flatMapConcurLimit] <value> 2
    > [sequentially.flatMapConcurLimit] <value> 3
    > [sequentially.flatMapConcurLimit] <value> 2
    > [sequentially.flatMapConcurLimit] <value> 3
    > [sequentially.flatMapConcurLimit] <value> 2
    > [sequentially.flatMapConcurLimit] <value> 3
    > [sequentially.flatMapConcurLimit] <value> 3
    > [sequentially.flatMapConcurLimit] <value> 3
    > [sequentially.flatMapConcurLimit] <value> 3
    > [sequentially.flatMapConcurLimit] <end>

pre(title='events in time').
  source:      ----------1---------2---------3X

  spawned 1:             ---1---1---1---1---1---1X
  spawned 2:                       ---2---2---2---2---2---2X
  spawned 3:                                     ---3---3---3---3---3---3X

  result:      -------------1---1---1-2-1-2-1-2-1-2-3-2-3-2-3---3---3---3X
div




+descr-method('flat-map-errors', 'flatMapErrors', 'obs.flatMapErrors([transform])').
  Same as #[a(href='#flat-map') flatMap],
  but operates on #[a(href='#about-errors') errors] while #[b values] just flow through.

pre.javascript(title='example')
  :escapehtml
    var source = Kefir.sequentially(100, [1, 2]).flatMap(Kefir.constantError);
    var result = source.flatMapErrors(x => Kefir.interval(40, x).take(2));
    result.log();

pre(title='console output')
  :escapehtml
    > [sequentially.flatMap.flatMapErrors] <value> 1
    > [sequentially.flatMap.flatMapErrors] <value> 1
    > [sequentially.flatMap.flatMapErrors] <value> 2
    > [sequentially.flatMap.flatMapErrors] <value> 2
    > [sequentially.flatMap.flatMapErrors] <end>

pre(title='events in time').
  source:      ----------e---------eX
                         1         2

  spawned 1:             ---1---1X
  spawned 2:                       ---2---2X

  result:      -------------1---1-----2---2X
div
