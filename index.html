<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Kefir.js — fast and light Reactive Programming library for JavaScript inspired by Bacon.js and RxJS</title><meta name="viewport" content="width=device-width, initial-scale=1"><style type="text/css">html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block;vertical-align:baseline}audio:not([controls]){display:none;height:0}[hidden],template{display:none}a{background:0 0}a:active,a:hover{outline:0}abbr[title]{border-bottom:1px dotted}b,strong{font-weight:700}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sup{top:-.5em}sub{bottom:-.25em}img{border:0}svg:not(:root){overflow:hidden}figure{margin:1em 40px}hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}pre{overflow:auto}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}button{overflow:visible}button,select{text-transform:none}button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}button[disabled],html input[disabled]{cursor:default}button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}input{line-height:normal}input[type=checkbox],input[type=radio]{box-sizing:border-box;padding:0}input[type=number]::-webkit-inner-spin-button,input[type=number]::-webkit-outer-spin-button{height:auto}input[type=search]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}input[type=search]::-webkit-search-cancel-button,input[type=search]::-webkit-search-decoration{-webkit-appearance:none}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{border:0;padding:0}textarea{overflow:auto}optgroup{font-weight:700}table{border-collapse:collapse;border-spacing:0}td,th{padding:0}figure{margin:1em 0}figure img{max-width:100%}body{font-size:14px;line-height:22px;background:#f4f4f4;color:#000;min-width:700px}a{color:#476cff;text-decoration:none}a:hover{text-decoration:underline}p{margin:20px 0}h2{padding-top:1em}h2{font-size:20px}h2 small,h2 sup,h2 sub{font-weight:normal}h1 small{color:#b1b1b1;line-height:2}h1 sup{font-weight:normal}table,tr,td{margin:0;padding:0}td,th{padding:2px 14px 2px 0}th{text-align:left}table .rule{padding:5px 0}table .rule:after{content:'';display:block;border-bottom:solid 1px #ddd}ul{list-style-type:square;padding:0 0 0 20px}li{margin-bottom:10px}code,pre,tt{font-family:Monaco, Consolas, "Lucida Console", monospace;font-size:12px;line-height:18px;font-style:normal}tt{padding:0px 3px;background:#fbfbfb;border:1px solid #ddd;zoom:1;font-size:.8em}code{margin-left:20px}pre{font-size:12px;padding:2px 2px 2px 12px;border-left:2px solid #DFDFDF;margin:0 0 30px;overflow:auto;background:#fbfbfb;position:relative}pre[title]:after{content:attr(title);position:absolute;top:0;right:0;padding:0 .5em;font-size:.8em;color:#8b8b8b;background:rgba(251, 251, 251, 0.9)}pre + pre{margin-top:-10px}.sidebar{background:#fff;position:fixed;top:0;left:0;bottom:0;width:240px;overflow-y:auto;overflow-x:hidden;-webkit-overflow-scrolling:touch;padding:15px 30px 30px;border-right:1px solid #bbb;box-shadow:0 0 20px #ccc;font-family:"Lucida Grande", "Lucida Sans Unicode", Helvetica, Arial, sans-serif}@media (max-width: 1200px){.sidebar{width:170px}}.sidebar a{color:inherit}.toc-title{display:block;font-weight:bold;margin-top:20px;line-height:1.2;margin-bottom:10px}.toc-section{font-size:11px;line-height:14px;margin:5px 0 0 0;padding-left:0px;list-style-type:none}.toc-section li{margin:0 0 3px 0}.toc-section a{text-decoration:none}.toc-section a:hover{text-decoration:underline}.container{max-width:680px;margin:40px 10px 50px 330px;font-family:Helvetica, Arial, sans-serif}@media (max-width: 1200px){.container{margin-left:260px}}.header{font-size:16px;line-height:30px;font-weight:bold;color:inherit}.alias,.shorthand{display:block;margin-left:1em;margin-bottom:.4em}.alias:before,.shorthand:before{content:'Alias:';font-family:Helvetica, Arial, sans-serif;font-style:italic;font-size:1.1em;font-weight:bold;margin-right:.5em}.shorthand:before{content:'Shorthand for:'}p[id]{margin-top:4em}h2[id]:not(.no-extra-padding){margin-top:3em}h2[id] + p[id]{margin-top:3em}.logo-img{width:60px;height:60px;vertical-align:bottom;margin-bottom:-4px}[data-emoji]{width:20px;height:20px;visibility:hidden}[data-emoji][src]{visibility:visible}</style></head><body><div class="sidebar"><a href="#" class="toc-title">Kefir.js</a><ul class="toc-section"><li><a href="#installation">Installation</a></li><li><a href="#jquery">jQuery plugin</a></li><li><a href="#demos">Demos</a></li></ul><a href="#about-observables" class="toc-title">Intro to  Streams and Properties</a><a href="#create-stream" class="toc-title">Create a stream</a><ul class="toc-section"><li>- <a href="#emitter">emitter</a></li><li>- <a href="#never">never</a></li><li>- <a href="#later">later</a></li><li>- <a href="#interval">interval</a></li><li>- <a href="#sequentially">sequentially</a></li><li>- <a href="#repeatedly">repeatedly</a></li><li>- <a href="#from-poll">fromPoll</a></li><li>- <a href="#with-interval">withInterval</a></li><li>- <a href="#from-callback">fromCallback</a></li><li>- <a href="#from-node-callback">fromNodeCallback</a></li><li>- <a href="#from-event">fromEvent</a></li><li>- <a href="#from-sub-unsub">fromSubUnsub</a></li><li>- <a href="#from-binder">fromBinder</a></li></ul><a href="#create-property" class="toc-title">Create a property</a><ul class="toc-section"><li>- <a href="#constant">constant</a></li><li>- <a href="#constant-error">constantError</a></li><li>- <a href="#from-promise">fromPromise</a></li></ul><a href="#convert" class="toc-title">Convert observables</a><ul class="toc-section"><li>- <a href="#to-property">toProperty</a></li><li>- <a href="#changes">changes</a></li></ul><a href="#main-methods" class="toc-title">Main observable methods</a><ul class="toc-section"><li>- <a href="#on-value">onValue</a></li><li>- <a href="#off-value">offValue</a></li><li>- <a href="#on-error">onError</a></li><li>- <a href="#off-error">offError</a></li><li>- <a href="#on-end">onEnd</a></li><li>- <a href="#off-end">offEnd</a></li><li>- <a href="#on-any">onAny</a></li><li>- <a href="#off-any">offAny</a></li><li>- <a href="#log">log</a></li><li>- <a href="#off-log">offLog</a></li></ul><a href="#modify" class="toc-title">Modify an observable</a><ul class="toc-section"><li>- <a href="#map">map</a></li><li>- <a href="#map-to">mapTo</a></li><li>- <a href="#pluck">pluck</a></li><li>- <a href="#invoke">invoke</a></li><li>- <a href="#not">not</a></li><li>- <a href="#timestamp">timestamp</a></li><li>- <a href="#tap">tap</a></li><li>- <a href="#filter">filter</a></li><li>- <a href="#take">take</a></li><li>- <a href="#take-while">takeWhile</a></li><li>- <a href="#skip">skip</a></li><li>- <a href="#skip-while">skipWhile</a></li><li>- <a href="#skip-duplicates">skipDuplicates</a></li><li>- <a href="#diff">diff</a></li><li>- <a href="#scan">scan</a></li><li>- <a href="#reduce">reduce</a></li><li>- <a href="#map-end">mapEnd</a></li><li>- <a href="#skip-end">skipEnd</a></li><li>- <a href="#sliding-window">slidingWindow</a></li><li>- <a href="#buffer-while">bufferWhile</a></li><li>- <a href="#delay">delay</a></li><li>- <a href="#throttle">throttle</a></li><li>- <a href="#debounce">debounce</a></li><li>- <a href="#flatten">flatten</a></li><li>- <a href="#transduce">transduce</a></li><li>- <a href="#with-handler">withHandler</a></li><li>- <a href="#values-to-errors">valuesToErrors</a></li><li>- <a href="#errors-to-values">errorsToValues</a></li><li>- <a href="#map-errors">mapErrors</a></li><li>- <a href="#filter-errors">filterErrors</a></li><li>- <a href="#skip-errors">skipErrors</a></li><li>- <a href="#skip-values">skipValues</a></li><li>- <a href="#end-on-error">endOnError</a></li></ul><a href="#combine-observables" class="toc-title">Combine observables</a><ul class="toc-section"><li>- <a href="#combine">combine</a></li><li>- <a href="#and">and</a></li><li>- <a href="#or">or</a></li><li>- <a href="#sampled-by">sampledBy</a></li><li>- <a href="#zip">zip</a></li><li>- <a href="#merge">merge</a></li><li>- <a href="#concat">concat</a></li><li>- <a href="#pool">pool</a></li><li>- <a href="#bus">bus</a></li><li>- <a href="#flat-map">flatMap</a></li><li>- <a href="#flat-map-latest">flatMapLatest</a></li><li>- <a href="#flat-map-first">flatMapFirst</a></li><li>- <a href="#flat-map-concat">flatMapConcat</a></li><li>- <a href="#flat-map-with-concurrency-limit">flatMapConcurLimit</a></li></ul><a href="#combine-two" class="toc-title">Combine two observables</a><ul class="toc-section"><li>- <a href="#filter-by">filterBy</a></li><li>- <a href="#take-while-by">takeWhileBy</a></li><li>- <a href="#skip-while-by">skipWhileBy</a></li><li>- <a href="#skip-until-by">skipUntilBy</a></li><li>- <a href="#take-until-by">takeUntilBy</a></li><li>- <a href="#buffer-by">bufferBy</a></li><li>- <a href="#buffer-while-by">bufferWhileBy</a></li><li>- <a href="#awaiting">awaiting</a></li></ul><a href="#active-state" class="toc-title">Active state</a><a href="#emitter-object" class="toc-title">Emitter object</a><a href="#about-errors" class="toc-title">Errors</a><a href="#current-in-streams" class="toc-title">Current values/errors in streams</a></div><div class="container"><h1><img src="Kefir.svg" class="logo-img"> Kefir.js <sup>1.0.0 (<a href="https://github.com/pozadi/kefir/blob/master/changelog.md">changelog</a>)</sup></h1><p>Kefir &mdash; is a Reactive Programming
library for JavaScript inspired by
<a href="https://github.com/baconjs/bacon.js">Bacon.js</a>
and
<a href="http://reactive-extensions.github.io/RxJS/">RxJS</a>,
with focus on high performance and low memory usage.

</p><p>Kefir has a
<a href="https://github.com/pozadi/kefir">
  <img data-emoji="octocat"> GitHub repository</a>, where you can
<a href="https://github.com/pozadi/kefir/pulls">send pull requests</a>,
<a href="https://github.com/pozadi/kefir/issues">report bugs</a>,
and have fun reading
<a href="https://github.com/pozadi/kefir/tree/master/src">source code</a>.
</p><p>If you spot a typo or grammar error, or know how to improve this documentation,
please help the project by
<a href="https://github.com/pozadi/kefir/issues/new">filing an issue</a>
or sending a pull request.
</p><h2 id="installation">Installation</h2><p>Kefir available as NPM and Bower packages, as well as simple files download.
</p><h3 id="npm">NPM</h3><pre>npm install kefir
</pre><h3 id="bower">Bower</h3><pre>bower install kefir
</pre><h3 id="downloads">Downloads <sup>(1.0.0)</sup></h3><table><tr><th rowspan="1" valign="top">For Development</th><td><a href="dist/kefir.js">kefir.js</a></td><td><i>~ 50 kb</i></td></tr><tr><th rowspan="2" valign="top">For Production</th><td><a href="dist/kefir.min.js">kefir.min.js</a></td><td><i>~ 7 kb (when gzipped)</i></td></tr><tr><td><a href="dist/kefir.min.js.map">kefir.min.js.map</a></td><td>source map file, in case you need one</td></tr><tr><td colspan="3" class="rule"></td></tr><tr><th>All files</th><td><a href="https://github.com/pozadi/kefir/archive/1.0.0.zip">kefir-1.0.0.zip</a></td><td>... including documentation, demos, tests, source maps, etc.</td></tr></table><h2 id="jquery">jQuery plugin</h2><p>If you are going to use Kefir together with jQuery, you might be interested in the
<a href="https://github.com/pozadi/kefir-jquery">kefir-jquery</a> plugin.
It contains two handy methods <tt>$().asKefirStream</tt> and <tt>$().asKefirProperty</tt>
for creating streams and properties from events of jQuery object.

</p><h2 id="demos">Demos</h2><ul><li><a href="demos/counter.html">Counter</a>  — most basic example</li><li><a href="demos/position.html">Position</a> — another basic example</li><li><a href="demos/custom-stream.html">Custom stream</a> — how to create a custom event stream from any source of events</li><li><a href="demos/tree.html">Tree</a> — Bacon.js vs Kefir.js perfomance comparison, and also nice tree animation demo</li></ul><p><img data-emoji="information_desk_person">
Also, almost any code snippet below can be run in browser console, on this page.
So you can play with Kefir right now, just open up browser console.</p><h2 id="about-observables">Intro to Streams and Properties</h2><p>Kefir supports two types of observables — streams and properties.
Stream represents a stream of events. And property represents a value,
that changes over time. The value of a property changes in response of events,
which means that any stream may be easily converted to a property.
</p><figure><img src="docs-src/images/stream-and-property.png"></figure><p>In practice, the only difference between two types of observables
is that property may have a current value. The process of subscribing
to values in both types is the same, you call the <a href="#on-value">onValue</a>
method, passing to it a callback function. But when you subscribe
to a property which a has current value, the callback is called
immediately (synchronously) with the current value of the property.</p><h2 id="create-stream">Create a stream</h2><p id="emitter"><a href="#emitter" class="header">emitter</a><code>Kefir.emitter()</code><br/>Creates an emitter, that is ordinary stream, but also has additional methods:
<tt>.emit(value)</tt>, <tt>.error(error)</tt>, and <tt>.end()</tt>.
Once an emitter was created, one can easily emit all three kind of events to it,
using these methods.
</p><pre title="example">var emitter = Kefir.emitter();
emitter.log(); // log events to console (see <a href="#log">log</a>)
emitter.emit(1);
emitter.error('Oops!');
emitter.end();
</pre><pre title="console output">&gt; [emitter] &lt;value&gt; 1
&gt; [emitter] &lt;error&gt; Oops!
&gt; [emitter] &lt;end&gt;
</pre><pre title="events in time">emitter:  ----1----e----X
                   Oops!</pre><div></div><p><img data-emoji="point_up"> <b>Emitter</b> is the easiest way
to create general purpose streams,
but it doesn't give you control over the <a href="#active-state">active state</a>
of the stream — it doesn't allows you to monitor if the stream has subscribers or not,
and sub/unsub to your original source or doing other resource management based on
whether stream has subscribers or not. If you want to have that control, you should use
<a href="#from-binder">fromBinder</a> or <a href="#from-sub-unsub">fromSubUnsub</a>.



</p><p id="never"><a href="#never" class="header">never</a><code>Kefir.never()</code><br/>Creates a stream, that already ended and will never produce any events.
</p><pre title="example">var stream = Kefir.never();
stream.log();
</pre><pre title="console output">&gt; [never] &lt;end:current&gt;
</pre><pre title="events in time">stream:  X</pre><div></div><p id="later"><a href="#later" class="header">later</a><code>Kefir.later(wait, value)</code><br/>Creates a stream, that produces a single <b>value</b>
after <b>wait</b> milliseconds, then ends.
</p><pre title="example">var stream = Kefir.later(1000, 1);
stream.log();
</pre><pre title="console output (after 1 second)">&gt; [later] &lt;value&gt; 1
&gt; [later] &lt;end&gt;
</pre><pre title="events in time">stream:  ----1X</pre><div></div><p id="interval"><a href="#interval" class="header">interval</a><code>Kefir.interval(interval, value)</code><br/>Creates a stream, that produces the same <b>value</b>
each <b>interval</b> milliseconds. Never ends.
</p><pre title="example">var stream = Kefir.interval(1000, 1);
stream.log();
</pre><pre title="console output">&gt; [interval] &lt;value&gt; 1
&gt; [interval] &lt;value&gt; 1
&gt; [interval] &lt;value&gt; 1
...
</pre><pre title="events in time">stream:  ----1----1----1----1---</pre><div></div><p id="sequentially"><a href="#sequentially" class="header">sequentially</a><code>Kefir.sequentially(interval, values)</code><br/>Creates a stream containing given <b>values</b> (array),
delivered with given <b>interval</b> in milliseconds.
Ends after all <b>values</b> are delivered.
</p><pre title="example">var stream = Kefir.sequentially(1000, [1, 2, 3]);
stream.log();
</pre><pre title="console output">&gt; [sequentially] &lt;value&gt; 1
&gt; [sequentially] &lt;value&gt; 2
&gt; [sequentially] &lt;value&gt; 3
&gt; [sequentially] &lt;end&gt;
</pre><pre title="events in time">stream:  ----1----2----3X</pre><div></div><p id="repeatedly"><a href="#repeatedly" class="header">repeatedly</a><code>Kefir.repeatedly(interval, values)</code><br/>Creates a stream, that produces given <b>values</b> (array),
with given <b>interval</b> in milliseconds.
When all values emitted, it begins to produce them again from the start.
Never ends.
</p><pre title="example">var stream = Kefir.repeatedly(1000, [1, 2, 3]);
stream.log();
</pre><pre title="console output">&gt; [repeatedly] &lt;value&gt; 1
&gt; [repeatedly] &lt;value&gt; 2
&gt; [repeatedly] &lt;value&gt; 3
&gt; [repeatedly] &lt;value&gt; 1
&gt; [repeatedly] &lt;value&gt; 2
&gt; [repeatedly] &lt;value&gt; 3
&gt; [repeatedly] &lt;value&gt; 1
...
</pre><pre title="events in time">stream:  ----1----2----3----1----2----3----1---</pre><div></div><p id="from-poll"><a href="#from-poll" class="header">fromPoll</a><code>Kefir.fromPoll(interval, fn)</code><br/>Creates a stream, that polls given <b>fn</b> function,
with given <b>interval</b> in milliseconds,
and emits values returned by <b>fn</b>.
Never ends.
</p><pre title="example">var start = new Date();
var stream = Kefir.fromPoll(1000, function(){ return new Date() - start });
stream.log();
</pre><pre title="console output">&gt; [fromPoll] &lt;value&gt; 1001
&gt; [fromPoll] &lt;value&gt; 2002
&gt; [fromPoll] &lt;value&gt; 3004
&gt; [fromPoll] &lt;value&gt; 4006
&gt; [fromPoll] &lt;value&gt; 5007
&gt; [fromPoll] &lt;value&gt; 6007
...
</pre><pre title="events in time">stream:  ----•----•----•----•---
          1001 2002 3004 4006</pre><div></div><p id="with-interval"><a href="#with-interval" class="header">withInterval</a><code>Kefir.withInterval(interval, handler)</code><br/>General method to create an interval based stream.
Creates a stream, that call given <b>handler</b> function,
with given <b>interval</b> in milliseconds.
The <b>handler</b> function is called with one argument —
<a href="#emitter-object">emitter object</a>.
</p><pre title="example">var start = new Date();
var stream = Kefir.withInterval(1000, function(emitter) {
  var time = new Date() - start;
  if (time &lt; 4000) {
    emitter.emit(time);   // emit a value
  } else {
    emitter.end();        // end the stream
  }
});
stream.log();
</pre><pre title="console output">&gt; [withInterval] &lt;value&gt; 1002
&gt; [withInterval] &lt;value&gt; 2003
&gt; [withInterval] &lt;value&gt; 3005
&gt; [withInterval] &lt;end&gt;
</pre><pre title="events in time">stream:  ----•----•----•----X
          1002 2003 3005</pre><div></div><p>You may call <b>emitter</b> methods several times on each interval tick,
or not call them at all.


</p><p id="from-callback"><a href="#from-callback" class="header">fromCallback</a><code>Kefir.fromCallback(fn)</code><br/>Convert a function than accepts a <b>callback</b>
as the first argument to a stream.
Emits at most one value when <b>callback</b> is called then ends.
The <b>fn</b> function will be called at most once,
when first subscriber will be added to the stream.
</p><pre title="example">var stream = Kefir.fromCallback(function(callback) {
  // we use setTimeout here just to simulate some asynchronous activity
  setTimeout(function() {  callback(1)  }, 1000);
});
stream.log();
</pre><pre title="console output">&gt; [fromCallback] &lt;value&gt; 1
&gt; [fromCallback] &lt;end&gt;
</pre><pre title="events in time">stream:  ----1X</pre><div></div><p id="from-node-callback"><a href="#from-node-callback" class="header">fromNodeCallback</a><code>Kefir.fromNodeCallback(fn)</code><br/>Similar to <a href="#from-callback">fromCallback</a>,
but the <b>callback</b> passed to <b>fn</b>
is a node.js style callback — <tt>callback(error,&nbsp;result)</tt>.
If the <b>error</b> argument of the <b>callback</b> is truthy,
an error will be emitted from the result stream, in other case a value.
The stream will end after first value or error.
</p><pre title="example">var stream = Kefir.fromNodeCallback(function(callback) {
  // we use setTimeout here just to simulate some asynchronous activity
  setTimeout(function() {  callback(null, 1)  }, 1000);
});
stream.log();
</pre><pre title="console output">&gt; [fromNodeCallback] &lt;value&gt; 1
&gt; [fromNodeCallback] &lt;end&gt;
</pre><pre title="events in time">stream:  ----1X</pre><div></div><p id="from-event"><a href="#from-event" class="header">fromEvent</a><code>Kefir.fromEvent(target, eventName, [transform])</code><br/>Creates a stream from events on a DOM EventTarget or Node.JS EventEmitter
object, or an object that supports event listeners using <tt>on/off</tt> methods (e.g. jQuery object).
</p><p>If <b>transform</b> function provided, it will be called on each event
with same arguments and context (<tt>this</tt>) as the event listener callback.
And the value returned by <b>transform</b> will be emitted from stream.
If no <b>transform</b> function provided, first argument of callback is emitted by default,
i.e. <tt>function(x) {return x}</tt> used as <b>transform</b>.
</p><pre title="example">var stream = Kefir.fromEvent(document.body, &#x27;click&#x27;);
stream.log()
</pre><pre title="console output">&gt; [fromEvent] &lt;value&gt; MouseEvent {dataTransfer: null, y: 474, x: 551 ...}
&gt; [fromEvent] &lt;value&gt; MouseEvent {dataTransfer: null, y: 361, x: 751 ...}
&gt; [fromEvent] &lt;value&gt; MouseEvent {dataTransfer: null, y: 444, x: 1120 ...}
</pre><pre title="events in time">stream:  ----•-----------•----•---
    MouseEvent   MouseEvent   MouseEvent</pre><div></div><p>Note that it uses <tt>addEventListener()</tt> for DOM events,
which is not supported by IE8. If you need IE8 support use
<a href="#jquery">jQuery plugin</a> or call <b>fromEvent</b>
on a jQuery object, e.g. <tt>Kefir.fromEvent($('.foo'), 'click')</tt>.


</p><p id="from-sub-unsub"><a href="#from-sub-unsub" class="header">fromSubUnsub</a><code>Kefir.fromSubUnsub(subscribe, unsubscribe, [transform])</code><br/>Creates a stream from <b>subscribe</b> and <b>unsubscribe</b> functions.
The <b>subscribe</b> function is called on each <a href="#active-state">activation</a> with callback as argument,
giving you an opportunity to subscribe with this callback to an original source of values.
When all subscribers from the stream removed, the <b>unsubscribe</b> function is called
with the same callback, so you can unsubscribe from your original source.
</p><p>You can also provide an <b>transform</b> function, which will work the same way as in
<a href="#from-event">fromEvent</a>.
</p><pre title="example">function subscribe(callback) {
  document.body.addEventListener(&#x27;click&#x27;, callback);
}

function unsubscribe(callback) {
  document.body.removeEventListener(&#x27;click&#x27;, callback);
}

function transform(event) {
  return event.type + &#x27; on &#x27; + this.tagName;
}

var stream = Kefir.fromSubUnsub(subscribe, unsubscribe, transform);
stream.log();
</pre><pre title="console output">&gt; [fromBinder] &lt;value&gt; click on BODY
&gt; [fromBinder] &lt;value&gt; click on BODY
&gt; [fromBinder] &lt;value&gt; click on BODY
</pre><pre title="events in time">stream:  ----•--------------•----•---
  'click on...'  'click on...'  'click on...'</pre><div></div><p id="from-binder"><a href="#from-binder" class="header">fromBinder</a><code>Kefir.fromBinder(subscribe)</code><br/>Another method for creation general purpose stream,
along with <a href="#emitter">emitter</a>.
Unlike <b>emitter</b> it gives you control over
<a href="#active-state">active state</a> of the stream.
</p><p>Creates a stream which call <b>subscribe</b> function on each
<a href="#active-state">activation</a>, passing to it an
<a href="#emitter-object">emitter object</a>.
Then you can call <b>emitter</b> methods at any time to emit events.
You can also return an <b>unsubscribe</b> function from the <b>subscribe</b> function.
If a function is returned from <b>subscribe</b>, it will be called on <b>deactivation</b> of the stream.
</p><pre title="example">var stream = Kefir.fromBinder(function(emitter) {
  console.log(&#x27;!activation&#x27;);
  var i = 0;
  var intervalId = setInterval(function() {
    emitter.emit(++i);
  }, 1000);
  return function() {
    console.log(&#x27;!deactivation&#x27;);
    clearInterval(intervalId);
  }
});
stream.log();
setTimeout(function() {
  stream.offLog(); // turn off logging to deactivate stream
}, 3500);
</pre><pre title="console output">&gt; !activation
&gt; [fromBinder] &lt;value&gt; 1
&gt; [fromBinder] &lt;value&gt; 2
&gt; [fromBinder] &lt;value&gt; 3
&gt; !deactivation
</pre><pre title="events in time">stream:  ----1----2----3---</pre><div></div><p>See also <a href="demos/custom-stream.html">Custom stream demo</a>
as another <b>fromBinder</b> usage example.
</p><p><img data-emoji="point_up"> Note that if you call <b>emitter</b> methods
synchronously in <b>subscribe</b> function, the callback passed to <b>on*</b> methods
(<b>onValue</b> etc.) will be also called synchronously.
And only first subscriber will get values emitted synchronously
(but if you convert stream to a property, this value will became property
current value, and all subscribers will get it).
</p><pre title="example">var stream = Kefir.fromBinder(function(emitter) {
  emitter.emit(1); // synchronous call
  setTimeout(function() {emitter.emit(2)}, 0); // asynchronous call
});
console.log(&#x27;about to add first subscriber&#x27;);
stream.onValue(function(x) {console.log(&#x27;first:&#x27;, x)});
console.log(&#x27;first subscriber added&#x27;);
stream.onValue(function(x) {console.log(&#x27;second:&#x27;, x)});
console.log(&#x27;second subscriber added&#x27;);
</pre><pre title="console output">&gt; about to add first subscriber
&gt; first: 1
&gt; first subscriber added
&gt; second subscriber added
&gt; first: 2
&gt; second: 2</pre><div></div><h2 id="create-property">Create a property</h2><p id="constant"><a href="#constant" class="header">constant</a><code>Kefir.constant(value)</code><br/>Creates an ended property, with specified <b>current value</b>.
</p><pre title="example">var property = Kefir.constant(1);
property.log();
</pre><pre title="console output">&gt; [constant] &lt;value:current&gt; 1
&gt; [constant] &lt;end:current&gt;
</pre><pre title="events in time">property: 1X</pre><div></div><p id="constant-error"><a href="#constant-error" class="header">constantError</a><code>Kefir.constantError(error)</code><br/>Creates an ended property, with specified <b>current error</b>.
</p><pre title="example">var property = Kefir.constantError(1);
property.log();
</pre><pre title="console output">&gt; [constantError] &lt;error:current&gt; 1
&gt; [constantError] &lt;end:current&gt;
</pre><pre title="events in time">property: eX</pre><div></div><p id="from-promise"><a href="#from-promise" class="header">fromPromise</a><code>Kefir.fromPromise(promise)</code><br/>Converts a promise to a property.
</p><pre title="example">var myPromise = {
  then: function(onSuccess, onError) {
    var fulfill = function() {  onSuccess(1)  };
    setTimeout(fulfill, 1000);
  }
};

var result = Kefir.fromPromise(myPromise);
result.log();
</pre><pre title="console output">&gt; [fromPromise] &lt;value&gt; 1
&gt; [fromPromise] &lt;end&gt;
</pre><pre title="events in time">result:  ----1X</pre><div></div><h2 id="convert">Convert observables</h2><p id="to-property"><a href="#to-property" class="header">toProperty</a><code>stream.toProperty([current])</code><br/>Converts a stream to a property.
Accepts optional <b>current</b> argument, which becomes current value of the
property.
</p><p>You can also call <b>toProperty</b> on a property.
If called on a property that already has a current value,
just returns same property with same current value.
But if source property has no current value,
specified value will be the current value of the result property.
</p><pre title="example">var source = Kefir.sequentially(100, [1, 2, 3]);
var result = source.toProperty(0);
result.log();
</pre><pre title="console output">&gt; [sequentially.toProperty] &lt;value:current&gt; 0
&gt; [sequentially.toProperty] &lt;value&gt; 1
&gt; [sequentially.toProperty] &lt;value&gt; 2
&gt; [sequentially.toProperty] &lt;value&gt; 3
&gt; [sequentially.toProperty] &lt;end&gt;
</pre><pre title="events in time">source:  ----1----2----3X
result: 0----1----2----3X</pre><div></div><p id="changes"><a href="#changes" class="header">changes</a><code>property.changes()</code><br/>Converts a property to a stream.
If property has current value, it will be ignored
(stream's subscribers won't get it).
</p><p>If you call <b>changes</b> on a stream, it'll just return same stream.
</p><pre title="example">var source = Kefir.sequentially(100, [1, 2, 3]);
var property = source.toProperty(0);
var result = property.changes();
result.log();
</pre><pre title="console output">&gt; [sequentially.toProperty.changes] &lt;value&gt; 1
&gt; [sequentially.toProperty.changes] &lt;value&gt; 2
&gt; [sequentially.toProperty.changes] &lt;value&gt; 3
&gt; [sequentially.toProperty.changes] &lt;end&gt;
</pre><pre title="events in time">property: 0----1----2----3X
result:    ----1----2----3X</pre><div></div><h2 id="main-methods">Main observable methods</h2><p id="on-value"><a href="#on-value" class="header">onValue</a><code>obs.onValue(callback)</code><br/>Subscribes <b>callback</b> to values on an observable.
</p><p>If called on a property, which has a current value,
<b>callback</b> will be called immediately (synchronously)
with that value.
</p><pre title="example">var stream = Kefir.sequentially(1000, [1, 2]);
stream.onValue(function(x) {
  console.log('value:', x);
});
</pre><pre title="console output">&gt; value: 1
&gt; value: 2
</pre><p id="off-value"><a href="#off-value" class="header">offValue</a><code>obs.offValue(callback)</code><br/>Unsubscribes <b>callback</b> from values on an observable.

</p><p id="on-error"><a href="#on-error" class="header">onError</a><code>obs.onError(callback)</code><br/>Subscribes <b>callback</b> to <a href="#about-errors">errors</a> on an observable.
</p><p>If called on a property, which has a current error,
<b>callback</b> will be called immediately (synchronously)
with that error.
</p><pre title="example">var stream = Kefir.sequentially(1000, [1, 2]).valuesToErrors();
stream.onError(function(x) {
  console.log('error:', x);
});
</pre><pre title="console output">&gt; error: 1
&gt; error: 2
</pre><p id="off-error"><a href="#off-error" class="header">offError</a><code>obs.offError(callback)</code><br/>Unsubscribes <b>callback</b> from errors on an observable.

</p><p id="on-end"><a href="#on-end" class="header">onEnd</a><code>obs.onEnd(callback)</code><br/>Subscribes <b>callback</b> to ending off an observable.
</p><p>If observable already ended, <b>callback</b> will be called immediately (synchronously).
</p><pre title="example">var stream = Kefir.sequentially(1000, [1, 2]);
stream.onEnd(function() {
  console.log('stream ended');
});
</pre><pre title="console output">&gt; stream ended
</pre><p id="off-end"><a href="#off-end" class="header">offEnd</a><code>obs.offEnd(callback)</code><br/>Unsubscribes <b>callback</b> from ending off an observable.
</p><p id="on-any"><a href="#on-any" class="header">onAny</a><code>obs.onAny(callback)</code><br/>Subscribes <b>callback</b> to all three types of events.
Callback is called with <b>event object</b> as argument. Each event object
contains three attributes — <b>type</b>, <b>value</b>, and <b>current</b>.
</p><ul><li><b>type</b> — a <tt>'value'</tt>, <tt>'error'</tt>, or <tt>'end'</tt> string</li><li><b>value</b> — the emitted <b>value</b> or <b>error</b> (<tt>undefined</tt> if <tt>event.type === 'end'</tt>)</li><li><b>current</b> — a boolean, that equals <tt>true</tt> if callback is called with current value/error of a property, or if the event represents an <b>end</b> of already ended observable (note that <a href="#current-in-streams">stremas also may emit current</a> values or errors)</li></ul><pre title="example">var stream = Kefir.sequentially(1000, [1, 2]);
stream.onAny(function(event) {
  console.log('event:', event);
});
</pre><pre title="console output">&gt; event: Object {type: &quot;value&quot;, value: 1, current: false}
&gt; event: Object {type: &quot;error&quot;, value: 2, current: false}
&gt; event: Object {type: &quot;end&quot;, value: undefined, current: false}
</pre><p id="off-any"><a href="#off-any" class="header">offAny</a><code>obs.offAny(callback)</code><br/>Unsubscribes an <b>onAny</b> subscriber.
</p><p id="log"><a href="#log" class="header">log</a><code>obs.log([name])</code><br/>Turns on logging of any events to browser console.
Accepts optional <b>name</b> argument that will be shown in the log if provided.
</p><pre title="example">var stream = Kefir.sequentially(1000, [1, 2]);
stream.log('my stream');
</pre><pre title="console output">&gt; my stream &lt;value&gt; 1
&gt; my stream &lt;value&gt; 2
&gt; my stream &lt;end&gt;
</pre><p id="off-log"><a href="#off-log" class="header">offLog</a><code>obs.offLog([name])</code><br/>Turns off logging. If <b>.log</b> was called with a <b>name</b> argument,
<b>offLog</b> must be called with the same <b>name</b> argument.</p><h2 id="modify">Modify an observable</h2><p>All methods in this section create a new observable of same type* from an original one.
The new observable applies some transformation to each event from original one
and emits result of transformation.
In most cases a transformation is applied only to <b>value</b> events,
but <b>end</b> and <b>error</b> events just passes through untouched.
</p><p><b>*</b> For example if original observable was a stream,
then new one also will be a stream. Same for properties.
This rule has one exception for <a href="#scan">scan</a> method,
that always returns a property.


</p><p id="map"><a href="#map" class="header">map</a><code>obs.map(fn)</code><br/>Applies given <b>fn</b> function to each value from original observable
and emits value returned by <b>fn</b>.
</p><pre title="example">var source = Kefir.sequentially(100, [1, 2, 3]);
var result = source.map(function(x) {  return x + 1  });
result.log();
</pre><pre title="console output">&gt; [sequentially.map] &lt;value&gt; 2
&gt; [sequentially.map] &lt;value&gt; 3
&gt; [sequentially.map] &lt;value&gt; 4
&gt; [sequentially.map] &lt;end&gt;</pre><div></div><pre title="events in time">source: ---1---2---3X
result: ---2---3---4X</pre><div></div><p id="map-to"><a href="#map-to" class="header">mapTo</a><code>obs.mapTo(value)</code><code class="shorthand">obs.map(function() {return value})</code>On each value from original observable emits given <b>value</b>.
</p><pre title="example">var source = Kefir.sequentially(100, [1, 2, 3]);
var result = source.mapTo(5);
result.log();
</pre><pre title="console output">&gt; [sequentially.mapTo] &lt;value&gt; 5
&gt; [sequentially.mapTo] &lt;value&gt; 5
&gt; [sequentially.mapTo] &lt;value&gt; 5
&gt; [sequentially.mapTo] &lt;end&gt;
</pre><pre title="events in time">source: ---1---2---3X
result: ---5---5---5X</pre><div></div><p id="pluck"><a href="#pluck" class="header">pluck</a><code>obs.pluck(propertyName)</code><code class="shorthand">obs.map(function(x) {return x.foo})</code>On each value from original observable emits <tt>value[propertyName]</tt>.
</p><pre title="example">var source = Kefir.sequentially(100, [{num: 1}, {num: 2}, {num: 3}]);
var result = source.pluck('num');
result.log();
</pre><pre title="console output">&gt; [sequentially.pluck] &lt;value&gt; 1
&gt; [sequentially.pluck] &lt;value&gt; 2
&gt; [sequentially.pluck] &lt;value&gt; 3
&gt; [sequentially.pluck] &lt;end&gt;</pre><div></div><pre title="events in time">source: --------•--------•--------•X
          {num:1}  {num:2}  {num:3}
result: --------1--------2--------3X</pre><div></div><p id="invoke"><a href="#invoke" class="header">invoke</a><code>obs.invoke(methodName)</code><code class="shorthand">obs.map(function(x) {return x.foo()})</code>Just like <b>.pluck</b>, but instead of emitting <tt>value[propertyName]</tt>
it emits <tt>value[methodName]()</tt>,
i.e. calls method <b>methodName</b> of each value object
and emits whatever it returns.
</p><pre title="example">var source = Kefir.sequentially(100, [
  {foo: function(){return 1}},
  {foo: function(){return 2}},
  {foo: function(){return 3}}
]);
var result = source.invoke('foo');
result.log();
</pre><pre title="console output">&gt; [sequentially.invoke] &lt;value&gt; 1
&gt; [sequentially.invoke] &lt;value&gt; 2
&gt; [sequentially.invoke] &lt;value&gt; 3
&gt; [sequentially.invoke] &lt;end&gt;
</pre><pre title="events in time">source: ------------•------------•------------•X
          {foo:()=&gt;1}  {foo:()=&gt;2}  {foo:()=&gt;3}
result: ------------1------------2------------3X</pre><div></div><p id="not"><a href="#not" class="header">not</a><code>obs.not()</code><code class="shorthand">obs.map(function(x) {return !x})</code>Inverts every value from original observable using <tt>!</tt> operator.
</p><pre title="example">var source = Kefir.sequentially(100, [true, false, true]);
var result = source.not();
result.log();
</pre><pre title="console output">&gt; [sequentially.not] &lt;value&gt; false
&gt; [sequentially.not] &lt;value&gt; true
&gt; [sequentially.not] &lt;value&gt; false
&gt; [sequentially.not] &lt;end&gt;
</pre><pre title="events in time">source: ---t---f---tX
result: ---f---t---fX</pre><div></div><p>See also <a href="#and">and</a>, <a href="#or">or</a>.


</p><p id="timestamp"><a href="#timestamp" class="header">timestamp</a><code>obs.timestamp()</code><code class="shorthand">obs.map(function(x) {return {value: x, time: new Date().getTime()}})</code>Wraps each value to object with timestamp of the event.
</p><pre title="example">var source = Kefir.sequentially(100, [1, 2]);
var result = source.timestamp();
result.log();
</pre><pre title="console output">&gt; [sequentially.timestamp] &lt;value&gt; Object {value: 1, time: 1413022203878}
&gt; [sequentially.timestamp] &lt;value&gt; Object {value: 2, time: 1413022203980}
&gt; [sequentially.timestamp] &lt;end&gt;
</pre><pre title="events in time">source: --------1--------2X
result: --------•--------•X
  {value:1,time:...}    {value:2,time:...}</pre><div></div><p id="tap"><a href="#tap" class="header">tap</a><code>obs.tap(fn)</code><br/>Just like <b>.map</b> applies given <b>fn</b>
function to each value from original observable, but emits original value
(not what <b>fn</b> returns).
</p><pre title="example">var source = Kefir.sequentially(100, [1, 2, 3]);
var result = source.tap(function(x) {
  console.log('from tap fn:', x);
  return 5; // will be ignored
});
result.log();
</pre><pre title="console output">&gt; from tap fn: 1
&gt; [sequentially.tap] &lt;value&gt; 1
&gt; from tap fn: 2
&gt; [sequentially.tap] &lt;value&gt; 2
&gt; from tap fn: 3
&gt; [sequentially.tap] &lt;value&gt; 3
&gt; [sequentially.tap] &lt;end&gt;
</pre><pre title="events in time">source: ---1---2---3X
result: ---1---2---3X</pre><div></div><p id="filter"><a href="#filter" class="header">filter</a><code>obs.filter([predicate])</code><br/>Filters values from original observable
using given <b>predicate</b> function.
</p><p>If no <b>predicate</b> provided <tt>function(x) {return x}</tt> will be used.
</p><pre title="example">var source = Kefir.sequentially(100, [1, 2, 3]);
var result = source.filter(function(x) {  return x &gt; 1  });
result.log();
</pre><pre title="console output">&gt; [sequentially.filter] &lt;value&gt; 2
&gt; [sequentially.filter] &lt;value&gt; 3
&gt; [sequentially.filter] &lt;end&gt;
</pre><pre title="events in time">source: ---1---2---3X
result: -------2---3X</pre><div></div><p>See also <a href="#filter-by">filterBy</a>.


</p><p id="take"><a href="#take" class="header">take</a><code>obs.take(n)</code><br/>Emits first <b>n</b> values from original observable, then ends.
</p><pre title="example">var source = Kefir.sequentially(100, [1, 2, 3]);
var result = source.take(2);
result.log();
</pre><pre title="console output">&gt; [sequentially.take] &lt;value&gt; 1
&gt; [sequentially.take] &lt;value&gt; 2
&gt; [sequentially.take] &lt;end&gt;
</pre><pre title="events in time">source: ---1---2---3X
result: ---1---2X</pre><div></div><p id="take-while"><a href="#take-while" class="header">takeWhile</a><code>obs.takeWhile([predicate])</code><br/>Emits values from original observable until given <b>predicate</b>
function applied to a value returns false.
Ends when <b>predicate</b> returns false.
</p><p>If no <b>predicate</b> provided <tt>function(x) {return x}</tt> will be used.
</p><pre title="example">var source = Kefir.sequentially(100, [1, 2, 3]);
var result = source.takeWhile(function(x) {  return x &lt; 3  });
result.log();
</pre><pre title="console output">&gt; [sequentially.takeWhile] &lt;value&gt; 1
&gt; [sequentially.takeWhile] &lt;value&gt; 2
&gt; [sequentially.takeWhile] &lt;end&gt;
</pre><pre title="events in time">source: ---1---2---3X
result: ---1---2---X</pre><div></div><p>See also <a href="#take-while-by">takeWhileBy</a>.

</p><p id="skip"><a href="#skip" class="header">skip</a><code>obs.skip(n)</code><br/>Skips first <b>n</b> values from original observable, then emits all rest.
</p><pre title="example">var source = Kefir.sequentially(100, [1, 2, 3]);
var result = source.skip(2);
result.log();
</pre><pre title="console output">&gt; [sequentially.skip] &lt;value&gt; 3
&gt; [sequentially.skip] &lt;end&gt;
</pre><pre title="events in time">source: ---1---2---3X
result: -----------3X</pre><div></div><p id="skip-while"><a href="#skip-while" class="header">skipWhile</a><code>obs.skipWhile([predicate])</code><br/>Skips values from original observable until given <b>predicate</b>
function applied to a value returns false,
then stops applying <b>predicate</b> to values and emits all of them.
</p><p>If no <b>predicate</b> provided <tt>function(x) {return x}</tt> will be used.
</p><pre title="example">var source = Kefir.sequentially(100, [1, 3, 2]);
var result = source.skipWhile(function(x) {  return x &lt; 3  });
result.log();
</pre><pre title="console output">&gt; [sequentially.skipWhile] &lt;value&gt; 3
&gt; [sequentially.skipWhile] &lt;value&gt; 2
&gt; [sequentially.skipWhile] &lt;end&gt;
</pre><pre title="events in time">source: ---1---3---2X
result: -------3---2X</pre><div></div><p>See also <a href="#skip-while-by">skipWhileBy</a>.


</p><p id="skip-duplicates"><a href="#skip-duplicates" class="header">skipDuplicates</a><code>obs.skipDuplicates([comparator])</code><br/>Skips duplicate values using <tt>===</tt> for comparison.
Accepts optional <b>comparator</b> function,
that, if provided, is used for comparison instead of <tt>===</tt>.
</p><pre title="example">var source = Kefir.sequentially(100, [1, 2, 2, 3, 1]);
var result = source.skipDuplicates();
result.log();
</pre><pre title="console output">&gt; [sequentially.skipDuplicates] &lt;value&gt; 1
&gt; [sequentially.skipDuplicates] &lt;value&gt; 2
&gt; [sequentially.skipDuplicates] &lt;value&gt; 3
&gt; [sequentially.skipDuplicates] &lt;value&gt; 1
&gt; [sequentially.skipDuplicates] &lt;end&gt;
</pre><pre title="events in time">source: ---1---2---2---3---1X
result: ---1---2-------3---1X</pre><div></div><p>With custom <b>comparator</b> function:</p><pre title="example">var source = Kefir.sequentially(100, [1, 2, 2.1, 3, 1]);
var result = source.skipDuplicates(function(a, b) {
  return Math.round(a) === Math.round(b);
});
result.log();
</pre><pre title="console output">&gt; [sequentially.skipDuplicates] &lt;value&gt; 1
&gt; [sequentially.skipDuplicates] &lt;value&gt; 2
&gt; [sequentially.skipDuplicates] &lt;value&gt; 3
&gt; [sequentially.skipDuplicates] &lt;value&gt; 1
&gt; [sequentially.skipDuplicates] &lt;end&gt;
</pre><pre title="events in time">source: ---1---2---•---3---1X
                 2.1
result: ---1---2-------3---1X</pre><div></div><p id="diff"><a href="#diff" class="header">diff</a><code>obs.diff([fn], [seed])</code><br/>On each value from original observable calls <b>fn</b>
function with previous and current value as arguments.
At first time calls <b>fn</b> with <b>seed</b> and current value.
Emits whatever <b>fn</b> returns.
</p><p>If no <b>seed</b> provided the first value will be used as a seed,
and result observable won't emit on first value.
</p><p>If no <b>fn</b> function provided, <tt>function(a, b) {return [a, b]}</tt> will be used.
If you want to omit <b>fn</b> but provide <b>seed</b>, pass <tt>null</tt> as <b>fn</b>.
</p><pre title="example">var source = Kefir.sequentially(100, [1, 2, 2, 3]);
var result = source.diff(function(prev, next) {
  return next - prev;
}, 0);
result.log();
</pre><pre title="console output">&gt; [sequentially.diff] &lt;value&gt; 1
&gt; [sequentially.diff] &lt;value&gt; 1
&gt; [sequentially.diff] &lt;value&gt; 0
&gt; [sequentially.diff] &lt;value&gt; 1
&gt; [sequentially.diff] &lt;end&gt;
</pre><pre title="events in time">source: ---1---2---2---3X
result: ---1---1---0---1X</pre><div></div><p id="scan"><a href="#scan" class="header">scan</a><code>obs.scan(fn, [seed])</code><br/>On each value from original
observable calls <b>fn</b> function with
previous result returned by <b>fn</b> and
current value emitted by original observable.
At first time calls <b>fn</b> with <b>seed</b> as previous result.
Emits whatever <b>fn</b> returns. Always creates a property.
</p><p>If no <b>seed</b> provided the first value will be used as a seed.
</p><pre title="example">var source = Kefir.sequentially(100, [1, 2, 2, 3]);
var result = source.scan(function(prev, next) {
  return next + prev;
}, 0);
result.log();
</pre><pre title="console output">&gt; [sequentially.scan] &lt;value:current&gt; 0
&gt; [sequentially.scan] &lt;value&gt; 1
&gt; [sequentially.scan] &lt;value&gt; 3
&gt; [sequentially.scan] &lt;value&gt; 5
&gt; [sequentially.scan] &lt;value&gt; 8
&gt; [sequentially.scan] &lt;end&gt;
</pre><pre title="events in time">source:  ---1---2---2---3X
result: 0---1---3---5---8X</pre><div></div><p id="reduce"><a href="#reduce" class="header">reduce</a><code>obs.reduce(fn, [seed])</code><br/>Similar to <b>.scan</b>, but emits only last result just before end.
</p><pre title="example">var source = Kefir.sequentially(100, [1, 2, 2, 3]);
var result = source.reduce(function(prev, next) {
  return next + prev;
}, 0);
result.log();
</pre><pre title="console output">&gt; [sequentially.reduce] &lt;value&gt; 8
&gt; [sequentially.reduce] &lt;end&gt;
</pre><pre title="events in time">source:  ---1---2---2---3 X
result:  ----------------8X</pre><div></div><p id="map-end"><a href="#map-end" class="header">mapEnd</a><code>obs.mapEnd(fn)</code><br/>Allows you to insert additional value just before observable end.
<b>fn</b> will be called on <b>obs</b> end with no arguments,
and whatever it return will be emitted in result stream before end.
</p><pre title="example">var source = Kefir.sequentially(100, [1, 2, 3]);
var result = source.mapEnd(function() {  return 0  });
result.log();
</pre><pre title="console output">&gt; [sequentially.mapEnd] &lt;value&gt; 1
&gt; [sequentially.mapEnd] &lt;value&gt; 2
&gt; [sequentially.mapEnd] &lt;value&gt; 3
&gt; [sequentially.mapEnd] &lt;value&gt; 0
&gt; [sequentially.mapEnd] &lt;end&gt;
</pre><pre title="events in time">source:  ---1---2---3 X
result:  ---1---3---30X</pre><div></div><p id="skip-end"><a href="#skip-end" class="header">skipEnd</a><code>obs.skipEnd()</code><br/>Ignores end of source observable.
</p><pre title="example">var source = Kefir.sequentially(100, [1, 2, 3]);
var result = source.skipEnd();
result.log();
</pre><pre title="console output">&gt; [sequentially.skipEnd] &lt;value&gt; 1
&gt; [sequentially.skipEnd] &lt;value&gt; 2
&gt; [sequentially.skipEnd] &lt;value&gt; 3
</pre><pre title="events in time">source:  ---1---2---3X
result:  ---1---2---3---</pre><div></div><p id="sliding-window"><a href="#sliding-window" class="header">slidingWindow</a><code>obs.slidingWindow(max, [min])</code><br/>Will emit arrays containing the last <b>n</b> values from <b>obs</b> observable,
where <b>n</b> is between <b>max</b> and <b>min</b> arguments.
By default <b>min</b> equals <tt>0</tt>.
</p><pre title="example">var source = Kefir.sequentially(100, [1, 2, 3, 4, 5]);
var result = source.slidingWindow(3, 2)
result.log();
</pre><pre title="console output">&gt; [sequentially.slidingWindow] &lt;value&gt; [1, 2]
&gt; [sequentially.slidingWindow] &lt;value&gt; [1, 2, 3]
&gt; [sequentially.slidingWindow] &lt;value&gt; [2, 3, 4]
&gt; [sequentially.slidingWindow] &lt;value&gt; [3, 4, 5]
&gt; [sequentially.slidingWindow] &lt;end&gt;
</pre><pre title="events in time">source:  --------1--------2--------3--------4--------5X
result:  -----------------•--------•--------•--------•X
                      [1,2]  [1,2,3]  [2,3,4]  [3,4,5]</pre><div></div><p id="buffer-while"><a href="#buffer-while" class="header">bufferWhile</a><code>obs.bufferWhile([predicate], [options])</code><br/>Passes every value from source observable to <b>predicate</b> function,
if it returns <tt>true</tt> adds value to the buffer, otherwise flushes the buffer.
Also flushes the buffer before end, but you can disable that
by passing <tt>{flushOnEnd: false}</tt> as <b>options</b>.
</p><p>The default <b>predicate</b> is <tt>function(x) {return x}</tt>.
If you want to omit <b>predicate</b> but pass <b>options</b>,
pass <tt>null</tt> as a <b>predicate</b>.
</p><pre title="example">var source = Kefir.sequentially(100, [1, 2, 3, 4, 5]);
var result = source.bufferWhile(function(x) {return x !== 3});
result.log();
</pre><pre title="console output">&gt; [sequentially.bufferWhile] &lt;value&gt; [1, 2, 3]
&gt; [sequentially.bufferWhile] &lt;value&gt; [4, 5]
&gt; [sequentially.bufferWhile] &lt;end&gt;
</pre><pre title="events in time">source:  ---1---2---3---4---5 X
result:  -----------•--------•X
              [1,2,3]    [4,5]</pre><div></div><p id="delay"><a href="#delay" class="header">delay</a><code>obs.delay(wait)</code><br/>Delays all events by <b>wait</b> milliseconds,
with exception for current value of property,
or current end for already ended observable. Doesn't delay <a href="#about-errors">errors</a>.
</p><pre title="example">var source = Kefir.sequentially(200, [1, 2, 3]);
var result = source.delay(100);
result.log();

</pre><pre title="console output">&gt; [sequentially.delay] &lt;value&gt; 1
&gt; [sequentially.delay] &lt;value&gt; 2
&gt; [sequentially.delay] &lt;value&gt; 3
&gt; [sequentially.delay] &lt;end&gt;
</pre><pre title="events in time">source:  -----1-----2-----3X
result:  --------1-----2-----3X</pre><div></div><p id="throttle"><a href="#throttle" class="header">throttle</a><code>obs.throttle(wait, [options])</code><br/>Return new throttled version of original observable, which will emit values
only at most once per every <b>wait</b> milliseconds.
If used on a property current value will always pass intact without any delay.
</p><p>Accepts optional <b>options</b> object similar to
<a href="http://underscorejs.org/#throttle" target="_blank">underscore.throttle</a>.
By default, will emit event as soon as it comes for the first time, and,
if any new events will come during the wait period,
will emit last of them as soon as that period is over.
If you'd like to disable the leading-edge emit,
pass <tt>{leading: false}</tt>, and if you'd like to disable the emit
on the trailing-edge, pass <tt>{trailing: false}</tt>.
</p><pre title="example">var source = Kefir.sequentially(750, [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]);
var result = stream.throttle(2500);
result.log();
</pre><pre title="console output">&gt; [sequentially.throttle] &lt;value&gt; 1
&gt; [sequentially.throttle] &lt;value&gt; 4
&gt; [sequentially.throttle] &lt;value&gt; 7
&gt; [sequentially.throttle] &lt;value&gt; 0
&gt; [sequentially.throttle] &lt;end&gt;</pre><div></div><pre title="events in time">source:  --1--2--3--4--5--6--7--8--9--0X
result:  --1---------4---------7---------0X</pre><div></div><p id="debounce"><a href="#debounce" class="header">debounce</a><code>obs.debounce(wait, [options])</code><br/>Creates new debounced version of original observable.
Will emit a value only after <b>wait</b> milliseconds period of no events.
Pass <tt>{immediate: true}</tt> as an <b>options</b> object to cause
observable to emit value on leading instead of the
trailing edge of the <b>wait</b> interval.
If used on a property current value will always pass intact without any delay.
</p><pre title="example">var source = Kefir.sequentially(100, [1, 2, 3, 0, 0, 0, 4, 5, 6]);
source = source.filter(function(x) {return x &gt; 0});
var result = source.debounce(250);
result.log();
</pre><pre title="console output">&gt; [sequentially.filter.debounce] &lt;value&gt; 3
&gt; [sequentially.filter.debounce] &lt;value&gt; 6
&gt; [sequentially.filter.debounce] &lt;end&gt;</pre><div></div><pre title="events in time">source:  ---1---2---3---------------4---5---6X
result:  ----------------------3---------------------6X</pre><div></div><p id="flatten"><a href="#flatten" class="header">flatten</a><code>obs.flatten([transformer])</code><br/>For this method it's expected that source observable emits arrays.
The result observable will emit each element of those arrays.
</p><pre title="example">var source = Kefir.sequentially(100, [[1], [], [2,3]]);
var result = source.flatten();
result.log();
</pre><pre title="console output">&gt; [sequentially.flatten] &lt;value&gt; 1
&gt; [sequentially.flatten] &lt;value&gt; 2
&gt; [sequentially.flatten] &lt;value&gt; 3
&gt; [sequentially.flatten] &lt;end&gt;
</pre><pre title="events in time">source:  --------•--------•-------- •X
               [1]       []     [2,3]
result:  --------1-----------------23X</pre><div></div><p>You can also provide the <b>transformer</b> function
which will be applied to each value from <b>obs</b> observable,
and supposed to return an array. This makes <b>flatten</b>
pretty powerful transformation method.
It allows you to do three kinds
of transformations on each value: change value (like map), skip value (like filter),
and respond with several values to a single value.
If you want to skip a value, return an empty array,
change the value — return array with a single new value,
emit several values — return them in array.
</p><pre title="example">var source = Kefir.sequentially(100, [1, 2, 3, 4]);
var result = source.flatten(function(x) {
  if (x % 2 === 0) {
    return [x * 10];
  } else {
    return [];
  }
});
result.log();
</pre><pre title="console output">&gt; [sequentially.flatten] &lt;value&gt; 20
&gt; [sequentially.flatten] &lt;value&gt; 40
&gt; [sequentially.flatten] &lt;end&gt;
</pre><pre title="events in time">source:  ---1---2---3---4X
result:  -------•-------•X
               20      40</pre><div></div><p>See also <a href="#flat-map">flatMap</a>





</p><p id="transduce"><a href="#transduce" class="header">transduce</a><code>obs.transduce(transducer)</code><br/>This method allows you to use transducers in Kefir.
It supports any transducers implementation that follows
<a href="https://github.com/cognitect-labs/transducers-js#the-transducer-protocol">the transducer protocol</a>, for example
<a href="https://github.com/cognitect-labs/transducers-js">cognitect-labs/transducers-js</a> or
<a href="https://github.com/jlongster/transducers.js">jlongster/transducers.js</a>.
To learn more about transducers please visit those libraries pages.
</p><p>In the example the
<a href="https://github.com/cognitect-labs/transducers-js">cognitect-labs/transducers-js</a>
library is used.
</p><pre title="example">var t = transducers;
var source = Kefir.sequentially(100, [1, 2, 3, 4, 5, 6]);
var myTransducer = t.comp(
  t.map(function(x) {return x + 10}),
  t.filter(function(x) {return x % 2 === 0}),
  t.take(2)
);
var result = source.transduce(myTransducer);
result.log();
</pre><pre title="console output">&gt; [sequentially.transduce] &lt;value&gt; 12
&gt; [sequentially.transduce] &lt;value&gt; 14
&gt; [sequentially.transduce] &lt;end&gt;
</pre><pre title="events in time">source:  ---1---2---3---4---5---6X
result:  -------•-------•X
               12      14</pre><div></div><p id="with-handler"><a href="#with-handler" class="header">withHandler</a><code>obs.withHandler(handler)</code><br/>The most general transformation method. All other transformation methods above
can be implemented via <b>withHandler</b>.
Will call <b>handler</b> function on each event from <b>obs</b> observable
passing to it two arguments: an <a href="#emitter-object">emitter object</a>,
and an event object (with same format as in <a href="#on-any">onAny</a> callback).
</p><p>By default will not emit any values or errors, and will not end when <b>obs</b>
observable ends. Instead you should implement desired behaviour in
<b>handler</b> function, i.e. analyse <b>event object</b> and call
<b>emitter</b> methods if necessary. You can call
<b>emitter</b> methods several times in each <b>handler</b> execution,
and you can also call them at any time later, for example to implement
<a href="#delay">delay</a>.
</p><pre title="example">var source = Kefir.sequentially(100, [0, 1, 2, 3]);
var result = source.withHandler(function(emitter, event) {
  if (event.type === &#x27;end&#x27;) {
    emitter.emit(&#x27;bye&#x27;);
    emitter.end();
  }
  if (event.type === &#x27;value&#x27;) {
    for (var i = 0; i &lt; event.value; i++) {
      emitter.emit(event.value);
    }
  }
});
result.log();
</pre><pre title="console output">&gt; [sequentially.withHandler] &lt;value&gt; 1
&gt; [sequentially.withHandler] &lt;value&gt; 2
&gt; [sequentially.withHandler] &lt;value&gt; 2
&gt; [sequentially.withHandler] &lt;value&gt; 3
&gt; [sequentially.withHandler] &lt;value&gt; 3
&gt; [sequentially.withHandler] &lt;value&gt; 3
&gt; [sequentially.withHandler] &lt;value&gt; bye
&gt; [sequentially.withHandler] &lt;end&gt;</pre><div></div><pre title="events in time">source:  ---0---1--- 2---  3 X
result:  -------•---••---••••X
                1   22   333bye</pre><div></div><p id="values-to-errors"><a href="#values-to-errors" class="header">valuesToErrors</a><code>obs.valuesToErrors([handler])</code><br/>Converts values to errors. By default it converts all values to errors,
but you can specify a custom <b>handler</b> function to change that.
The <b>handler</b> function is called with one argument — a value,
and must return an object with two properties <tt>{convert: Boolean, error: AnyType}</tt>,
if <b>convert</b> set to <tt>true</tt>, specified <b>error</b> will be emitted,
otherwise original value will be emitted, and the <b>error</b> property will be ignored.
</p><pre title="example">var source = Kefir.sequentially(100, [0, -1, 2, -3]);
var result = source.valuesToErrors(function(x) {
  return {
    convert: x &lt; 0,
    error: x * 2
  };
});
result.log();
</pre><pre title="console output">&gt; [sequentially.valuesToErrors] &lt;value&gt; 0
&gt; [sequentially.valuesToErrors] &lt;error&gt; -2
&gt; [sequentially.valuesToErrors] &lt;value&gt; 2
&gt; [sequentially.valuesToErrors] &lt;error&gt; -6
&gt; [sequentially.valuesToErrors] &lt;end&gt;
</pre><pre title="events in time">source:  ---•---•---•---•X
            0  -1   2  -3
result:  ---•---e---•---eX
            0  -2   2  -6</pre><div></div><p id="errors-to-values"><a href="#errors-to-values" class="header">errorsToValues</a><code>obs.errorsToValues([handler])</code><br/>Same as <a href="#values-to-errors">valuesToErrors</a> but vice versa.
</p><pre title="example">var source = Kefir.sequentially(100, [0, -1, 2, -3]).valuesToErrors();
var result = source.errorsToValues(function(x) {
  return {
    convert: x &gt;= 0,
    value: x * 2
  };
});
result.log();
</pre><pre title="console output">&gt; [sequentially.valuesToErrors.errorsToValues] &lt;value&gt; 0
&gt; [sequentially.valuesToErrors.errorsToValues] &lt;error&gt; -1
&gt; [sequentially.valuesToErrors.errorsToValues] &lt;value&gt; 4
&gt; [sequentially.valuesToErrors.errorsToValues] &lt;error&gt; -3
&gt; [sequentially.valuesToErrors.errorsToValues] &lt;end&gt;
</pre><pre title="events in time">source:  ---e---e---e---eX
            0  -1   2  -3
result:  ---•---e---•---eX
            0  -1   4  -3</pre><div></div><p id="map-errors"><a href="#map-errors" class="header">mapErrors</a><code>obs.mapErrors(fn)</code><br/>Applies given <b>fn</b> function to each error from original observable
and emits error returned by <b>fn</b>.
</p><pre title="example">var source = Kefir.sequentially(100, [0, 1, 2, 3]).valuesToErrors();
var result = source.mapErrors(function(x) {
  return x * 2;
});
result.log();
</pre><pre title="console output">&gt; [sequentially.valuesToErrors.mapErrors] &lt;error&gt; 0
&gt; [sequentially.valuesToErrors.mapErrors] &lt;error&gt; 2
&gt; [sequentially.valuesToErrors.mapErrors] &lt;error&gt; 4
&gt; [sequentially.valuesToErrors.mapErrors] &lt;error&gt; 6
&gt; [sequentially.valuesToErrors.mapErrors] &lt;end&gt;
</pre><pre title="events in time">source:  ---e---e---e---eX
            0   1   2   3
result:  ---e---e---e---eX
            0   2   4   6</pre><div></div><p id="filter-errors"><a href="#filter-errors" class="header">filterErrors</a><code>obs.filterErrors([predicate])</code><br/>Filters errors from original observable
using given <b>predicate</b> function.
</p><p>If no <b>predicate</b> provided <tt>function(x) {return x}</tt> will be used.
</p><pre title="example">var source = Kefir.sequentially(100, [0, 1, 2, 3]).valuesToErrors();
var result = source.filterErrors(function(x) {
  return (x % 2) === 0;
});
result.log();
</pre><pre title="console output">&gt; [sequentially.valuesToErrors.filterErrors] &lt;error&gt; 0
&gt; [sequentially.valuesToErrors.filterErrors] &lt;error&gt; 2
&gt; [sequentially.valuesToErrors.filterErrors] &lt;end&gt;
</pre><pre title="events in time">source:  ---e---e---e---eX
            0   1   2   3
result:  ---e-------e----X
            0       2</pre><div></div><p id="skip-errors"><a href="#skip-errors" class="header">skipErrors</a><code>obs.skipErrors()</code><br/>Ignores all errors from original observable, emitting only values and end.
</p><pre title="example">var source = Kefir.sequentially(100, [0, -1, 2, -3])
  .valuesToErrors(function(x) {
    return {convert: x &lt; 0, error: x};
  });
var result = source.skipErrors()
result.log();
</pre><pre title="console output">&gt; [sequentially.valuesToErrors.skipErrors] &lt;value&gt; 0
&gt; [sequentially.valuesToErrors.skipErrors] &lt;value&gt; 2
&gt; [sequentially.valuesToErrors.skipErrors] &lt;end&gt;
</pre><pre title="events in time">source:  ---•---e---•---eX
            0  -1   2  -3
result:  ---•-------•----X
            0       2</pre><div></div><p id="skip-values"><a href="#skip-values" class="header">skipValues</a><code>obs.skipValues()</code><br/>Ignores all values from original observable, emitting only errors and end.
</p><pre title="example">var source = Kefir.sequentially(100, [0, -1, 2, -3])
  .valuesToErrors(function(x) {
    return {convert: x &lt; 0, error: x};
  });
var result = source.skipValues()
result.log();
</pre><pre title="console output">&gt; [sequentially.valuesToErrors.skipValues] &lt;error&gt; -1
&gt; [sequentially.valuesToErrors.skipValues] &lt;error&gt; -3
&gt; [sequentially.valuesToErrors.skipValues] &lt;end&gt;
</pre><pre title="events in time">source:  ---•---e---•---eX
            0  -1   2  -3
result:  -------e-------eX
               -1      -3</pre><div></div><p id="end-on-error"><a href="#end-on-error" class="header">endOnError</a><code>obs.endOnError()</code><br/>Makes observable end on first error.
</p><pre title="example">var source = Kefir.sequentially(100, [0, -1, 2, -3])
  .valuesToErrors(function(x) {
    return {convert: x &lt; 0, error: x};
  });
var result = source.endOnError()
result.log();
</pre><pre title="console output">&gt; [sequentially.valuesToErrors.endOnError] &lt;value&gt; 0
&gt; [sequentially.valuesToErrors.endOnError] &lt;error&gt; -1
&gt; [sequentially.valuesToErrors.endOnError] &lt;end&gt;
</pre><pre title="events in time">source:  ---•---e---•---eX
            0  -1   2  -3
result:  ---•---eX
            0  -1</pre><div></div><h2 id="combine-observables">Combine observables</h2><p id="combine"><a href="#combine" class="header">combine</a><code>Kefir.combine(obss, [fn])</code><code class="alias">obs.combine(otherObs, [fn])</code>Returns a stream.
Combines two or more observables together. On each value from any of source
observables (<b>obss</b> array) emits combined value, generated by <b>fn</b>
function from latest values from each source observable. <b>Fn</b>
is called with latest values as arguments.
If no <b>fn</b> provided, it emits an array containing latest values.
</p><p>It emits a value only when all source observables have emitted at least once.
Ends when all source observables ends.
</p><p>You can also combine two observables by calling <tt>a.combine(b, fn)</tt> if you like.
</p><pre title="example">var foo = Kefir.emitter();
var bar = Kefir.emitter();
var sum = Kefir.combine([foo, bar], function(f, b) {
  return f + b;
});
foo.log('foo');
bar.log('bar');
sum.log();

foo.emit(1);
bar.emit(2);
foo.emit(3);
bar.end();
foo.end();
</pre><pre title="console output">&gt; foo &lt;value&gt; 1
&gt; bar &lt;value&gt; 2
&gt; [combine] &lt;value&gt; 3
&gt; foo &lt;value&gt; 3
&gt; [combine] &lt;value&gt; 5
&gt; bar &lt;end&gt;
&gt; foo &lt;end&gt;
&gt; [combine] &lt;end&gt;
</pre><pre title="events in time">foo:  --1-----3-----X
bar:  -----2-----X

sum:  -----3--5-----X</pre><div></div><p id="and"><a href="#and" class="header">and</a><code>Kefir.and(obss)</code><code class="alias">obs.and(otherObs)</code>Combines <b>obss</b> observables using <tt>&amp;&amp;</tt> (logical and) operator.
</p><pre title="example">var a = Kefir.emitter();
var b = Kefir.emitter();
var c = Kefir.emitter();
var isAllTrue = Kefir.and([a, b, c]);
isAllTrue.log();

a.emit(true);
b.emit(false);
c.emit(true);
b.emit(true);
a.emit(false);
</pre><pre title="console output">&gt; [and] &lt;value&gt; false
&gt; [and] &lt;value&gt; true
&gt; [and] &lt;value&gt; false
</pre><pre title="events in time">a:          --t-----------f--
b:          -----f-----t-----
c:          --------t--------

isAllTrue:  --------f--t--f--</pre><div></div><p>See also <a href="#not">not</a>.

</p><p id="or"><a href="#or" class="header">or</a><code>Kefir.or(obss)</code><code class="alias">obs.or(otherObs)</code>Combines <b>obss</b> observables using <tt>||</tt> (logical or) operator.
</p><pre title="example">var a = Kefir.emitter();
var b = Kefir.emitter();
var c = Kefir.emitter();
var isAnyTrue = Kefir.or([a, b, c]);
isAnyTrue.log();

a.emit(true);
b.emit(false);
c.emit(true);
b.emit(true);
a.emit(false);
</pre><pre title="console output">&gt; [or] &lt;value&gt; true
&gt; [or] &lt;value&gt; true
&gt; [or] &lt;value&gt; true
</pre><pre title="events in time">a:          --t-----------f--
b:          -----f-----t-----
c:          --------t--------

isAnyTrue:  --------t--t--t--</pre><div></div><p>See also <a href="#not">not</a>.

</p><p id="sampled-by"><a href="#sampled-by" class="header">sampledBy</a><code>Kefir.sampledBy(passiveObss, activeObss, [fn])</code><code class="alias">obs.sampledBy(otherObs, [fn])</code>Like <a href="#combine">combine</a>, but instead of one array of source
observables it accepts two — <b>passiveObss</b> and <b>activeObss</b>,
then works just like <b>combine</b> except emits values only on values
from <b>activeObss</b>. But in <b>fn</b>
function you have values from both <b>passiveObss</b> and <b>activeObss</b>.
</p><p>If no <b>fn</b> provided emits an array of latest values, just like <b>combine</b>.
Actually <b>combine</b> is a <b>sampledBy</b> with empty array as <b>passiveObss</b>,
and all source observables as <b>activeObss</b>.
</p><p>Ends when all of <b>activeObss</b> ends.
</p><pre title="example">var a = Kefir.repeatedly(100, [0, 1, 2]);
var b = Kefir.repeatedly(100, [0, 1, 2]).delay(20);
var c = Kefir.sequentially(100, [0, 1, 2]).delay(40);
var d = Kefir.sequentially(100, [0, 1, 2]).delay(60);
var sum = Kefir.sampledBy([a, b], [c, d], function(_a, _b, _c, _d) {
  return _a + _b + _c + _d;
});
sum.log();
</pre><pre title="console output">&gt; [sampledBy] &lt;value&gt; 0
&gt; [sampledBy] &lt;value&gt; 3
&gt; [sampledBy] &lt;value&gt; 4
&gt; [sampledBy] &lt;value&gt; 7
&gt; [sampledBy] &lt;value&gt; 8
&gt; [sampledBy] &lt;end&gt;
</pre><pre title="events in time">a:    ----------0---------1---------2---------0-----
b:    ------------0---------1---------2---------0---
c:    --------------0---------1---------2X
d:    ----------------0---------1---------2X

sum:  ----------------0-------3-4-------7-8X
</pre><p>As you can see on a graph, <b>sampledBy</b> emits only on events
from <b>active sources</b>, and only when it has at least one value from each source.
Also it not waits for <b>passive sources</b> to end, only for active.
</p><p>You can also sample one observable by another like this <tt>a.sampledBy(b, fn)</tt>,
it is an equivalent of <tt>Kefir.sampledBy([a], [b], fn)</tt>.
If you omit <b>fn</b>, <tt>function(a, b) {return a}</tt> will be used in
<tt>a.sampledBy(b)</tt>.


</p><p id="zip"><a href="#zip" class="header">zip</a><code>Kefir.zip(sources, [combinator])</code><code class="alias">obs.zip(otherObs, [combinator])</code>Creates a stream with values from <b>sources</b>
lined up with each other. For example if you have two sources with values
<tt>[1, 2, 3]</tt> and <tt>[4, 5, 6, 7]</tt>, the result stream will emit
<tt>[1, 4]</tt>, <tt>[2, 5]</tt>, and <tt>[3, 6]</tt>.
The result stream will emit next value only when it has at least one value
from each of sources.
</p><p>You can also provide a <b>combinator</b> function, in this case instead
of emitting array of values, they will be passed to <b>combinator</b> as arguments,
and returned value will be emitted (same as in <a href="#combine">combine</a>,
<a href="#sampled-by">sampledBy</a>, etc.)
</p><p>Also in <b>zip</b> you can pass ordinary arrays along with observables
in <b>sources</b>, e.g. <tt>Kefir.zip([obs,&nbsp;[1,&nbsp;2,&nbsp;3]],&nbsp;fn)</tt>.
In other words, <b>sources</b> is an array of observables and arrays,
or only observables of course.
</p><p>The result stream ends when all sources end.
</p><pre title="example">var a = Kefir.sequentially(100, [0, 1, 2, 3]);
var b = Kefir.sequentially(160, [4, 5, 6]);
var c = Kefir.sequentially(100, [8, 9]).delay(260).toProperty(7);
var result = Kefir.zip([a, b, c]);
result.log();
</pre><pre title="console output">&gt; [zip] &lt;value&gt; [0, 4, 7]
&gt; [zip] &lt;value&gt; [1, 5, 8]
&gt; [zip] &lt;value&gt; [2, 6, 9]
&gt; [zip] &lt;end&gt;
</pre><pre title="events in time">a:    ----0----1----2----3X
b:    -------4-------5-------6X
c:   7-----------------8----9X

abc:  -------•---------•-----•X
       [0,4,7]   [1,5,8]     [2,6,9]</pre><div></div><p id="merge"><a href="#merge" class="header">merge</a><code>Kefir.merge(obss)</code><code class="alias">obs.merge(otherObs)</code>Merges several <b>obss</b> observables into single stream,
i.e. simply repeats values from each source observable.
Ends when all <b>obss</b> observables ends.
</p><p>You can also merge two observables by calling <tt>a.merge(b)</tt>, if you like.
</p><pre title="example">var a = Kefir.sequentially(100, [0, 1, 2]);
var b = Kefir.sequentially(100, [0, 1, 2]).delay(30);
var c = Kefir.sequentially(100, [0, 1, 2]).delay(60);
var abc = Kefir.merge([a, b, c]);
abc.log();
</pre><pre title="console output">&gt; [merge] &lt;value&gt; 0
&gt; [merge] &lt;value&gt; 0
&gt; [merge] &lt;value&gt; 0
&gt; [merge] &lt;value&gt; 1
&gt; [merge] &lt;value&gt; 1
&gt; [merge] &lt;value&gt; 1
&gt; [merge] &lt;value&gt; 2
&gt; [merge] &lt;value&gt; 2
&gt; [merge] &lt;value&gt; 2
&gt; [merge] &lt;end&gt;
</pre><pre title="events in time">a:    ----------0---------1---------2X
b:    ------------0---------1---------2X
c:    --------------0---------1---------2X

abc:  ----------0-0-0-----1-1-1-----2-2-2X</pre><div></div><p id="concat"><a href="#concat" class="header">concat</a><code>Kefir.concat(obss)</code><code class="alias">obs.concat(otherObs)</code>Concatenates several <b>obss</b> observables into one stream. Like <a href="#merge">merge</a>,
but it starts emitting values from next source only after previous source ends,
ignoring any values from next sources before that.
</p><pre title="example">var a = Kefir.emitter();
var b = Kefir.emitter();
var c = Kefir.emitter();

var abc = Kefir.concat([a, b, c]);
abc.log();

a.emit(0).emit(1);
b.emit(0);
a.emit(2).end();
c.emit(0);
b.emit(1);
c.emit(1);
b.emit(2).end();
c.emit(2).end();
</pre><pre title="console output">&gt; [concat] &lt;value&gt; 0
&gt; [concat] &lt;value&gt; 1
&gt; [concat] &lt;value&gt; 2
&gt; [concat] &lt;value&gt; 1
&gt; [concat] &lt;value&gt; 2
&gt; [concat] &lt;value&gt; 2
&gt; [concat] &lt;end&gt;
</pre><pre title="events in time">a:    ---0---1---2X
b:    ---------0-----1---2X
c:    -------------0---1---2X

abc:  ---0---1---2---1---2-2X</pre><div></div><p id="pool"><a href="#pool" class="header">pool</a><code>Kefir.pool()</code><br/><b>Pool</b> is like <a href="#merge">merge</a> to which you
can dynamically add and remove sources.
When you create a new <b>pool</b> it has no sources, then you can
add observables to it using <b>plug</b> method,
and remove using <b>unplug</b>. <b>Pool</b> never ends.
</p><pre title="example">var a = Kefir.emitter();
var b = Kefir.emitter();

var pool = Kefir.pool();
pool.log();

a.emit(1);
b.emit(1);
pool.plug(a);
a.emit(2);
b.emit(2);
pool.plug(b);
a.emit(3);
b.emit(3);
pool.unplug(a);
a.emit(4);
b.emit(4);
a.end();
b.end();
</pre><pre title="console output">&gt; [pool] &lt;value&gt; 2
&gt; [pool] &lt;value&gt; 3
&gt; [pool] &lt;value&gt; 3
&gt; [pool] &lt;value&gt; 4
</pre><pre title="events in time">a:       ---1-----2-----3----4-----X
b:       ----1------2------3----4---X

plug:    ------a------b------------------
unplug:  -------------------a------------

pool:    ---------2-----3--3----4--------
</pre><p>In this graph <b>plug</b> and <b>unplug</b> shown just to illustrate
moments when we plug and unplug sources, don't be confused that
there is some <b>plug</b> or <b>unplug</b> streams somewhere.


</p><p id="bus"><a href="#bus" class="header">bus</a><code>Kefir.bus()</code><br/><b>Bus</b> is a pool with <a href="#emitter">emitter</a> methods.
You can emit values from it directly. It is the best choice to expose
an input from a module, so module users could easily send events to your
module directly or by plugging an observable.
</p><pre title="example">var bus = Kefir.bus();
var emitter = Kefir.emitter();
bus.log();

bus.plug(emitter);
bus.emit(1);
emitter.emit(2);
bus.end();
</pre><pre title="console output">&gt; [bus] &lt;value&gt; 1
&gt; [bus] &lt;value&gt; 2
&gt; [bus] &lt;end&gt;</pre><div></div><p id="flat-map"><a href="#flat-map" class="header">flatMap</a><code>obs.flatMap([transform])</code><br/>Works similar to <a href="#flatten">flatten</a>,
but instead of array handles observables. Like in <b>flatten</b> you can
either provide a <b>transform</b> function which will return observables,
or you can use source <b>obs</b> observable that already emits observables.
</p><p><b>flatMap</b> ends when <b>obs</b> and all spawned observables ends.
</p><pre title="example">var source = Kefir.sequentially(100, [1, 2, 3]);
var result = source.flatMap(function(x) {
  return Kefir.interval(40, x).take(4);
});
result.log();
</pre><pre title="console output">&gt; [sequentially.flatMap] &lt;value&gt; 1
&gt; [sequentially.flatMap] &lt;value&gt; 1
&gt; [sequentially.flatMap] &lt;value&gt; 1
&gt; [sequentially.flatMap] &lt;value&gt; 2
&gt; [sequentially.flatMap] &lt;value&gt; 1
&gt; [sequentially.flatMap] &lt;value&gt; 2
&gt; [sequentially.flatMap] &lt;value&gt; 2
&gt; [sequentially.flatMap] &lt;value&gt; 3
&gt; [sequentially.flatMap] &lt;value&gt; 2
&gt; [sequentially.flatMap] &lt;value&gt; 3
&gt; [sequentially.flatMap] &lt;value&gt; 3
&gt; [sequentially.flatMap] &lt;value&gt; 3
&gt; [sequentially.flatMap] &lt;end&gt;
</pre><pre title="events in time">source:      ----------1---------2---------3X

spawned 1:             ---1---1---1---1X
spawned 2:                       ---2---2---2---2X
spawned 3:                                 ---3---3---3---3X

result:      -------------1---1---1-2-1-2---2-3-2-3---3---3X</pre><div></div><p id="flat-map-latest"><a href="#flat-map-latest" class="header">flatMapLatest</a><code>obs.flatMapLatest([fn])</code><br/>Like <b>flatMap</b>, but repeats events only from the latest added observable.
I.e. it switching from one observable to another.
</p><pre title="example">var source = Kefir.sequentially(100, [1, 2, 3]);
var result = source.flatMapLatest(function(x) {
  return Kefir.interval(40, x).take(4);
});
result.log();
</pre><pre title="console output">&gt; [sequentially.flatMapLatest] &lt;value&gt; 1
&gt; [sequentially.flatMapLatest] &lt;value&gt; 1
&gt; [sequentially.flatMapLatest] &lt;value&gt; 2
&gt; [sequentially.flatMapLatest] &lt;value&gt; 2
&gt; [sequentially.flatMapLatest] &lt;value&gt; 3
&gt; [sequentially.flatMapLatest] &lt;value&gt; 3
&gt; [sequentially.flatMapLatest] &lt;value&gt; 3
&gt; [sequentially.flatMapLatest] &lt;value&gt; 3
&gt; [sequentially.flatMapLatest] &lt;end&gt;
</pre><pre title="events in time">source:      ----------1---------2---------3X

spawned 1:             ---1---1---1---1X
spawned 2:                       ---2---2---2---2X
spawned 3:                                 ---3---3---3---3X

result:      -------------1---1-----2---2-----3---3---3---3X</pre><div></div><p id="flat-map-first"><a href="#flat-map-first" class="header">flatMapFirst</a><code>obs.flatMapFirst([fn])</code><br/>Like <b>flatMap</b>, but adds new observable only if previous one ended,
in other case it just ignoring new observable.
</p><pre title="example">var source = Kefir.sequentially(100, [1, 2, 3]);
var result = source.flatMapFirst(function(x) {
  return Kefir.interval(40, x).take(4);
});
result.log();
</pre><pre title="console output">&gt; [sequentially.flatMapFirst] &lt;value&gt; 1
&gt; [sequentially.flatMapFirst] &lt;value&gt; 1
&gt; [sequentially.flatMapFirst] &lt;value&gt; 1
&gt; [sequentially.flatMapFirst] &lt;value&gt; 1
&gt; [sequentially.flatMapFirst] &lt;value&gt; 3
&gt; [sequentially.flatMapFirst] &lt;value&gt; 3
&gt; [sequentially.flatMapFirst] &lt;value&gt; 3
&gt; [sequentially.flatMapFirst] &lt;value&gt; 3
&gt; [sequentially.flatMapFirst] &lt;end&gt;
</pre><pre title="events in time">source:      ----------1---------2---------3X

spawned 1:             ---1---1---1---1X
spawned 2:                       ---2---2---2---2X
spawned 3:                                 ---3---3---3---3X

result:      -------------1---1---1---1-------3---3---3---3X</pre><div></div><p id="flat-map-concat"><a href="#flat-map-concat" class="header">flatMapConcat</a><code>obs.flatMapConcat([fn])</code><br/>Like <a href="#flat-map-first">flatMapFirst</a>, but instead of ignoring new observables
(if previous one still alive), it adds them to the queue.
Then, when current source ends, it takes the oldest observable from the queue,
and switches to it.
</p><pre title="example">var source = Kefir.sequentially(100, [1, 2, 3]);
var result = source.flatMapConcat(function(x) {
  return Kefir.interval(40, x).take(4);
});
result.log();
</pre><pre title="console output">&gt; [sequentially.flatMapConcat] &lt;value&gt; 1
&gt; [sequentially.flatMapConcat] &lt;value&gt; 1
&gt; [sequentially.flatMapConcat] &lt;value&gt; 1
&gt; [sequentially.flatMapConcat] &lt;value&gt; 1
&gt; [sequentially.flatMapConcat] &lt;value&gt; 2
&gt; [sequentially.flatMapConcat] &lt;value&gt; 2
&gt; [sequentially.flatMapConcat] &lt;value&gt; 2
&gt; [sequentially.flatMapConcat] &lt;value&gt; 2
&gt; [sequentially.flatMapConcat] &lt;value&gt; 3
&gt; [sequentially.flatMapConcat] &lt;value&gt; 3
&gt; [sequentially.flatMapConcat] &lt;value&gt; 3
&gt; [sequentially.flatMapConcat] &lt;value&gt; 3
&gt; [sequentially.flatMapConcat] &lt;end&gt;
</pre><pre title="events in time">source:      ----------1---------2---------3X

spawned 1:             ---1---1---1---1X
spawned 2:                             ---2---2---2---2X
spawned 3:                                             ---3---3---3---3X

result:      -------------1---1---1---1---2---2---2---2---3---3---3---3X</pre><div></div><p id="flat-map-with-concurrency-limit"><a href="#flat-map-with-concurrency-limit" class="header">flatMapConcurLimit</a><code>obs.flatMapConcurLimit([fn], limit)</code><br/>Like <a href="#flat-map-concat">flatMapConcat</a>, but with configurable number of concurent sources,
in other words <b>flatMapConcat</b> is <tt>flatMapConcurLimit(fn, 1)</tt>.
</p><pre title="example">var source = Kefir.sequentially(100, [1, 2, 3]);
var result = source.flatMapConcurLimit(function(x) {
  return Kefir.interval(40, x).take(6);
}, 2);
result.log();
</pre><pre title="console output">&gt; [sequentially.flatMapConcurLimit] &lt;value&gt; 1
&gt; [sequentially.flatMapConcurLimit] &lt;value&gt; 1
&gt; [sequentially.flatMapConcurLimit] &lt;value&gt; 1
&gt; [sequentially.flatMapConcurLimit] &lt;value&gt; 2
&gt; [sequentially.flatMapConcurLimit] &lt;value&gt; 1
&gt; [sequentially.flatMapConcurLimit] &lt;value&gt; 2
&gt; [sequentially.flatMapConcurLimit] &lt;value&gt; 1
&gt; [sequentially.flatMapConcurLimit] &lt;value&gt; 2
&gt; [sequentially.flatMapConcurLimit] &lt;value&gt; 1
&gt; [sequentially.flatMapConcurLimit] &lt;value&gt; 2
&gt; [sequentially.flatMapConcurLimit] &lt;value&gt; 3
&gt; [sequentially.flatMapConcurLimit] &lt;value&gt; 2
&gt; [sequentially.flatMapConcurLimit] &lt;value&gt; 3
&gt; [sequentially.flatMapConcurLimit] &lt;value&gt; 2
&gt; [sequentially.flatMapConcurLimit] &lt;value&gt; 3
&gt; [sequentially.flatMapConcurLimit] &lt;value&gt; 3
&gt; [sequentially.flatMapConcurLimit] &lt;value&gt; 3
&gt; [sequentially.flatMapConcurLimit] &lt;value&gt; 3
&gt; [sequentially.flatMapConcurLimit] &lt;end&gt;
</pre><pre title="events in time">source:      ----------1---------2---------3X

spawned 1:             ---1---1---1---1---1---1X
spawned 2:                       ---2---2---2---2---2---2X
spawned 3:                                     ---3---3---3---3---3---3X

result:      -------------1---1---1-2-1-2-1-2-1-2-3-2-3-2-3---3---3---3X</pre><div></div><h2 id="combine-two">Combine two observables</h2><p>Just like in <a href="#modify">"Modify an observable"</a> section,
all methods in this section return observables of same type as an original
observable (on which method was called). With one exception
for <a href="#awaiting">awaiting</a>, that always returns a property.


</p><p id="filter-by"><a href="#filter-by" class="header">filterBy</a><code>obs.filterBy(otherObs)</code><br/>Works like <a href="#filter">filter</a>, but instead of calling a predicate
on each value from <b>obs</b> observable, it checks last value from <b>otherObs</b>.
</p><pre title="example">var foo = Kefir.sequentially(100, [1, 2, 3, 4, 5, 6, 7, 8]);
var bar = Kefir.sequentially(200, [false, true, false]).delay(40).toProperty(true);
var result = foo.filterBy(bar);
result.log();
</pre><pre title="console output">&gt; [sequentially.filterBy] &lt;value&gt; 1
&gt; [sequentially.filterBy] &lt;value&gt; 2
&gt; [sequentially.filterBy] &lt;value&gt; 5
&gt; [sequentially.filterBy] &lt;value&gt; 6
&gt; [sequentially.filterBy] &lt;end&gt;
</pre><pre title="events in time">foo:     ----1----2----3----4----5----6----7----8X
bar:     t----------f---------t---------fX

result:  ----1----2--------------5----6----------X</pre><div></div><p id="take-while-by"><a href="#take-while-by" class="header">takeWhileBy</a><code>obs.takeWhileBy(otherObs)</code><br/>Works like <a href="#take-while">takeWhile</a>, but instead of using a
predicate function it uses another observable. It takes values from
<b>obs</b> observable until the first falsey value from <b>otherObs</b>.
</p><p><img data-emoji="point_up"> Note that it will not produce any value until
first value from <b>otherObs</b>, if that not what you need, just turn your
stream into property with current value <tt>true</tt>
by calling <tt>.toProperty(true)</tt>.
</p><pre title="example">var foo = Kefir.sequentially(100, [1, 2, 3, 4, 5, 6, 7, 8]);
var bar = Kefir.sequentially(200, [true, false, true]).delay(40).toProperty(true);
var result = foo.takeWhileBy(bar);
result.log();
</pre><pre title="console output">&gt; [sequentially.takeWhileBy] &lt;value&gt; 1
&gt; [sequentially.takeWhileBy] &lt;value&gt; 2
&gt; [sequentially.takeWhileBy] &lt;value&gt; 3
&gt; [sequentially.takeWhileBy] &lt;value&gt; 4
&gt; [sequentially.takeWhileBy] &lt;end&gt;
</pre><pre title="events in time">foo:     ----1----2----3----4----5----6----7----8X
bar:     t----------t---------f---------tX

result:  ----1----2----3----4-X</pre><div></div><p id="skip-while-by"><a href="#skip-while-by" class="header">skipWhileBy</a><code>obs.skipWhileBy(otherObs)</code><br/>Works like <a href="#skip-while">skipWhile</a>, but instead of using a
predicate function it uses another observable. It skips values from
<b>obs</b> observable until first falsey value from <b>otherObs</b>.
</p><pre title="example">var foo = Kefir.sequentially(100, [1, 2, 3, 4, 5, 6, 7, 8]);
var bar = Kefir.sequentially(200, [true, false, true]).delay(40);
var result = foo.skipWhileBy(bar);
result.log();
</pre><pre title="console output">&gt; [sequentially.skipWhileBy] &lt;value&gt; 1
&gt; [sequentially.skipWhileBy] &lt;value&gt; 2
&gt; [sequentially.skipWhileBy] &lt;value&gt; 3
&gt; [sequentially.skipWhileBy] &lt;value&gt; 4
&gt; [sequentially.skipWhileBy] &lt;end&gt;
</pre><pre title="events in time">foo:     ----1----2----3----4----5----6----7----8X
bar:     -----------t---------f---------tX

result:  ------------------------5----6----7----8X</pre><div></div><p id="skip-until-by"><a href="#skip-until-by" class="header">skipUntilBy</a><code>obs.skipUntilBy(otherObs)</code><br/>Similar to <a href="#skip-while-by">skipWhileBy</a>, but instead of
waiting for first falsey value from <b>otherObs</b>, it waits for just any value from it.
</p><pre title="example">var foo = Kefir.sequentially(100, [1, 2, 3, 4]);
var bar = Kefir.later(250, 0);
var result = foo.skipUntilBy(bar);
result.log();
</pre><pre title="console output">&gt; [sequentially.skipUntilBy] &lt;value&gt; 3
&gt; [sequentially.skipUntilBy] &lt;value&gt; 4
&gt; [sequentially.skipUntilBy] &lt;end&gt;
</pre><pre title="events in time">foo:     ----1----2----3----4X
bar:     -----------0X

result:  --------------3----4X</pre><div></div><p id="take-until-by"><a href="#take-until-by" class="header">takeUntilBy</a><code>obs.takeUntilBy(otherObs)</code><br/>Similar to <a href="#take-while-by">takeWhileBy</a>, but instead of
waiting for first falsey value from <b>otherObs</b>, it waits for just any value from it.
</p><pre title="example">var foo = Kefir.sequentially(100, [1, 2, 3, 4]);
var bar = Kefir.later(250, 0);
var result = foo.takeUntilBy(bar);
result.log();
</pre><pre title="console output">&gt; [sequentially.takeUntilBy] &lt;value&gt; 1
&gt; [sequentially.takeUntilBy] &lt;value&gt; 2
&gt; [sequentially.takeUntilBy] &lt;end&gt;
</pre><pre title="events in time">foo:     ----1----2----3----4X
bar:     -----------0X

result:  ----1----2-X</pre><div></div><p id="buffer-by"><a href="#buffer-by" class="header">bufferBy</a><code>obs.bufferBy(otherObs, [options])</code><br/>Buffers all values from <b>obs</b> observable,
and flushes the buffer on each value from <b>otherObs</b>.
Also flushes the buffer before end, but you can disable that
by passing <tt>{flushOnEnd: false}</tt> as <b>options</b>.
</p><pre title="example">var foo = Kefir.sequentially(100, [1, 2, 3, 4, 5, 6, 7, 8]).delay(40);
var bar = Kefir.sequentially(300, [1, 2])
var result = foo.bufferBy(bar);
result.log();
</pre><pre title="console output">&gt; [sequentially.delay.bufferBy] &lt;value&gt; [1, 2]
&gt; [sequentially.delay.bufferBy] &lt;value&gt; [3, 4, 5]
&gt; [sequentially.delay.bufferBy] &lt;value&gt; [6, 7, 8]
&gt; [sequentially.delay.bufferBy] &lt;end&gt;
</pre><pre title="events in time">foo:     ------1----2----3----4----5----6----7----8 X
bar:     --------------1--------------2X

result:  --------------•--------------•------------•X
                  [1, 2]      [3, 4, 5]    [6, 7, 8]</pre><div></div><p id="buffer-while-by"><a href="#buffer-while-by" class="header">bufferWhileBy</a><code>obs.bufferWhileBy(otherObs, [options])</code><br/>Similar to <a href="#buffer-while">bufferWhile</a>, but instead of using a
predicate function it uses another observable.
On each value from <b>obs</b> observable:
if last value from <b>otherObs</b> was truthy, adds new value to the buffer,
otherwise flushes the buffer (with new value included).
Also flushes the buffer before end, but you can disable that
by passing <tt>{flushOnEnd: false}</tt> as <b>options</b>.

</p><pre title="example">var foo = Kefir.sequentially(100, [1, 2, 3, 4, 5, 6, 7, 8]);
var bar = Kefir.sequentially(200, [false, true, false]).delay(40);
var result = foo.bufferWhileBy(bar);
result.log();
</pre><pre title="console output">&gt; [sequentially.bufferWhileBy] &lt;value&gt; [1, 2, 3]
&gt; [sequentially.bufferWhileBy] &lt;value&gt; [4]
&gt; [sequentially.bufferWhileBy] &lt;value&gt; [5, 6, 7]
&gt; [sequentially.bufferWhileBy] &lt;value&gt; [8]
&gt; [sequentially.bufferWhileBy] &lt;end&gt;
</pre><pre title="events in time">foo:     ----1----2----3----4----5----6----7----8X
bar:     -----------f---------t---------fX

result:  --------------•----•--------------•----•X
               [1, 2, 3]  [4]      [5, 6, 7]  [8]</pre><div></div><p id="awaiting"><a href="#awaiting" class="header">awaiting</a><code>obs.awaiting(otherObs)</code><br/>Returns a property that represents the awaiting status of two observables,
i.e. answers the question «Has <b>obs</b> observable emitted a value
since the last value from <b>otherObs</b> observable has been emitted?».
</p><pre title="example">var foo = Kefir.sequentially(100, [1, 2, 3]);
var bar = Kefir.sequentially(100, [1, 2, 3]).delay(40);
var result = foo.awaiting(bar);
result.log();
</pre><pre title="console output">&gt; [sequentially.awaiting] &lt;value:current&gt; false
&gt; [sequentially.awaiting] &lt;value&gt; true
&gt; [sequentially.awaiting] &lt;value&gt; false
&gt; [sequentially.awaiting] &lt;value&gt; true
&gt; [sequentially.awaiting] &lt;value&gt; false
&gt; [sequentially.awaiting] &lt;value&gt; true
&gt; [sequentially.awaiting] &lt;value&gt; false
&gt; [sequentially.awaiting] &lt;end&gt;
</pre><pre title="events in time">foo:     ----1----2----3X
bar:     ------1----2----3X

result:  f---t-f--t-f--t-fX</pre><div></div><h2 id="active-state">Active state</h2><p>Each stream or property at any given time may be in one of two states —
active or inactive. When an observable is in an inactive state, it does not emit any
events, and does not subscribe to it's original source.
Observables automatically become active when first listener is added,
and become inactive when last listener is removed.
</p><p>For example <tt>stream = Kefir.fromEvent(el, 'click')</tt> won't
immediately subscribe to <tt>'click'</tt> event on <tt>el</tt>,
it will subscribe only when the first listener will be added to the
<tt>stream</tt>. And it will automatically unsubscribe when the last listener
will be removed from the <tt>stream</tt>.
</p><pre>var stream = Kefir.fromEvent(el, &#x27;click&#x27;);
// at this moment event listener to _el_ not added

stream.onValue(someFn);
// now &#x27;click&#x27; listener added to _el_

stream.offValue(someFn);
// and now it is removed again
</pre><p>If one observable depends on another,
its active state propagates to its dependencies.
For example, in the following code,
<b>mapA</b> will activate <b>A</b>,
<b>filterMapA</b> will activate <b>mapA</b> and <b>A</b>,
<b>mergeAB</b> will activate <b>A</b> and <b>B</b>.
</p><pre>var A = Kefir.emitter();
var B = Kefir.emitter();

var mapA = A.map(function(){ ... });
var filterMapA = mapA.filter(function(){ ... });
var mergeAB = Kefir.merge(A, B);
</pre><p>In fact active state is just a convention that is strictly
followed in Kefir code, for better performance.
But you are free to not follow it in your custom plugins or combinators.
</p><p><img data-emoji="point_up"> Note that the current value of a
property won't update when that property is inactive.
For example, we convert an <b>emitter</b> to a property,
then emit some values, while the property has no subscribers (i.e. is inactive).
In this case the property won't get those values, and it
won't update its current value.
</p><pre>var emitter = Kefir.emitter();
var property = emitter.toProperty(0);

// 1 and 2 won&#x27;t become property current value
emitter.emit(1);
emitter.emit(2);

// now we activate property by subscribing to it,
// and also check current value
property.onValue(function(x) {  console.log(x)  }) // =&gt; 0

// those values will become property current
emitter.emit(3);
emitter.emit(4);

property.onValue(function(x) {  console.log(x)  }) // =&gt; 4
</pre><p>This issue applies not only to properties,
but also to all stateful observables
(like <a href="#take">take</a>, <a href="#diff">diff</a>, <a href="#scan">scan</a> etc.).
In rare cases you might need to activate an observable by adding
a dummy subscriber, to solve this issue. It's ok if you really need this,
but don't overuse that pattern. For example
<tt>obs.map(sideEffect).onValue(function(){})</tt> is a antipattern,
you should do <tt>obs.onValue(sideEffect)</tt> instead.</p><h2 id="emitter-object">Emitter object</h2><p>Emitter object is an object, that has three methods <b>emit</b>, <b>error</b>, and <b>end</b>.
It is used in several places in Kefir as a proxy to emit events to some observable.
</p><ul><li><tt>emiter.emit(value)</tt> accepts one argument (any value)</li><li><tt>emiter.error(error)</tt> accepts one argument (any value)</li><li><tt>emiter.end()</tt> accepts no arguments</li></ul><pre>emitter.emit(123);
emitter.error(&#x27;Oh, snap!&#x27;);
emitter.end();</pre><div></div><p>Do not confuse <b>emitter object</b> with <a href="#emitter">emitter stream</a>.
They both have similar methods,
but <b>emitter object</b> isn't actually a stream,
it has no stream methods or functionality.
Emitter object has only three methods, that's it.
</p><p>All <b>emitter object</b> methods are bound to its context,
and can be passed safely as callbacks without binding:
</p><pre>// instead of this
$(&#x27;.foo&#x27;).on(&#x27;click&#x27;, emitter.emit.bind(emitter));

// you can do just this
$(&#x27;.foo&#x27;).on(&#x27;click&#x27;, emitter.emit);</pre><div></div><h2 id="about-errors">Errors</h2><p>Kefir supports additional channel to pass data through observables — errors.
Unlike values, errors normally just flow through observable chain
without any transformation. Consider this example:
</p><pre title="example">function add2(x) {
  return x + 2;
}

function gt3(x) {
  return x &gt; 3;
}

var foo = Kefir.emitter();
var bar = foo.map(add2).filter(gt3);

bar.log();

foo.emit(0);
foo.emit(2);
foo.error(-1);
foo.emit(3);
foo.end();

</pre><pre title="console output">&gt; [emitter.map.filter] &lt;value&gt; 4
&gt; [emitter.map.filter] &lt;error&gt; -1
&gt; [emitter.map.filter] &lt;value&gt; 5
&gt; [emitter.map.filter] &lt;end&gt;
</pre><pre title="events in time">foo: ---0---2---e---3---X
                -1

bar: -------4---e---5---X
                -1</pre><div></div><p>As you can see values being mapped and filtered,
although errors just flows unchanged.
Also notice that observable doesn't end on an error by default,
but you can use <a href="#end-on-error">endOnError</a> method to make it happen.
</p><p>With multiple source observables it works same way.
Errors from each source show up in the result observable unchanged.
</p><pre title="example">function sum(a, b) {
  return a + b;
}

var foo = Kefir.emitter();
var bar = Kefir.emitter();
var baz = Kefir.combine([foo, bar], sum);

baz.log();

foo.emit(1);
bar.emit(2);
foo.error(-1);
foo.emit(3);
bar.error(-2);
bar.emit(4);
foo.end();
bar.end();
</pre><pre title="console output">&gt; [combine] &lt;value&gt; 3
&gt; [combine] &lt;error&gt; -1
&gt; [combine] &lt;value&gt; 5
&gt; [combine] &lt;error&gt; -2
&gt; [combine] &lt;value&gt; 7
&gt; [combine] &lt;end&gt;
</pre><pre title="events in time">foo: ---1-------e---3-----------X
                -1
bar: -------2-----------e---4-------X
                       -2

baz: -------3---e---5---e---7-------X
                -1      -2</pre><div></div><p>But notice that if multiple source observable isn't watch for some of it's
sources at some point in time it will also not emit errors from them.
This applies to observables like <a href="#concat">concat</a>,
<a href="#flat-map-concat">flatMapConcat</a> etc.</p><h2 id="current-in-streams">Current values/errors in streams</h2><p>Normally only properties have current values,
but sometimes streams also may emit them. What it means
is that sometimes a stream can emit a value (or error) in response to
first subscription (i.e. on <a href="#active-state">activation</a>),
and only first subscriber will get the value.
</p><p>In Bacon.js there's even methods that creates such streams (<tt>.once</tt>, <tt>.fromArray</tt>),
but in Kefir we trying to avoid them as they may cause some confusion
for beginners (actually that happens quite a lot for Bacon).
So in Kefir it less easier to create streams that emit current values,
but there's still situations when they can be created.
</p><p>Let see some examples.
Each of these streams will emit a value at the moment when first subscriber is added:
</p><pre title="example">var s1 = Kefir.merge([Kefir.constant(1), Kefir.never()]);

var s2 = Kefir.fromBinder(function(emitter) {
  emitter.emit(1);
});

var s3 = Kefir.combine([Kefir.constant(1), Kefir.constant(1)], function(x) {
  return x * x;
});
</pre><p>When a stream emits a value like this, it internally considered as a <b>current</b> value.
The <a href="#log">log</a> method will mark it as current,
and in <a href="#on-any">onAny</a> subscriber <tt>event.current</tt> will equal <b>true</b>.
</p><p>There is some issues with all this, but also some benefits.
Issue number one is that only the first subscriber gets this value (or error).
Even if it was an <b>onEnd</b> subscriber, it'll still eat all current values,
and further subscribers won't get them.
Second issue is that it may be considered as not semantically correct behaviour
i.e., the fact that moments when stream emits values depend on when it gets subscribers ...
</p><p>To benefits, first — it allows you to define current value in
<a href="#from-binder">fromBinder</a>, it's easier to show in example:
</p><pre title="example">var scrollTop = Kefir.fromBinder(function(emitter) {

  function emitScrollY() {
    emitter.emit(window.scrollY);
  }

  emitScrollY(); // here we are emitting the current value

  window.addEventListener(&#x27;scroll&#x27;, emitScrollY);

  return function() {
    window.removeEventListener(&#x27;scroll&#x27;, emitScrollY);
  };

}).toProperty();

scrollTop.log();
</pre><pre title="console output">&gt; [fromBinder.toProperty] &lt;value:current&gt; 0
&gt; [fromBinder.toProperty] &lt;value&gt; 4
&gt; [fromBinder.toProperty] &lt;value&gt; 9
&gt; [fromBinder.toProperty] &lt;value&gt; 23
</pre><p>Defining current value this way is better than
<tt>scrollYStream.toProperty(getScrollY())</tt>
because in <b>fromBinder</b> example the current value will be pulled
in moment of subscription, and with <tt>.toProperty(getScrollY())</tt>
it will be pulled at the moment of property creation and might
become obsolete when property will be used.
</p><p>Second benefit is that it makes it possible to not lose
current values when converting properties to streams and then back to properties.
For example, <a href="#combine">combine</a> always returns a stream
(<a href="https://github.com/pozadi/kefir/issues/44#issuecomment-72875317">why?</a>)
but it'll still emit current value.
So one can do <tt>Kefir.combine([p1, p2], fn).toProperty()</tt>,
and get a property combined from two other properties with correct current value.
</p><p>Also it's a good practise to convert all streams that might
emit current values to properties using <b>toProperty</b> method.
That should make your code more reliable as all subscribers will get current values.
And it's just better semantically as current values should live in the properties.</p></div><script src="bower-packages/jquery/jquery.js"></script><script src="bower-packages/transducers-js/transducers.js"></script><script src="dist/kefir.js"></script><script src="https://rawgit.com/pozadi/kefir-jquery/v1.0.0/kefir-jquery.js"></script><script>KefirJQuery.init(Kefir, $)
</script><script>$.getJSON('https://api.github.com/emojis', function(emojis){
  $('[data-emoji]').each(function(){
    var name = $(this).data('emoji');
    $(this).attr({
      src: emojis[name],
      title: ':' + name + ':',
      alt: ':' + name + ':'
    });
  });
});

var $window = $(window);
var $document = $(document);
var scrollLeft = $window.asKefirProperty('scroll', function() {
  return $window.scrollLeft();
});
var winWidth = $window.asKefirProperty('resize', function() {
  return $window.width();
});
var docWidth = $window.asKefirProperty('resize', function() {
  return $document.width();
});
Kefir.combine([scrollLeft, winWidth, docWidth], function(scrollLeft, winWidth, docWidth) {
  return -Math.min(docWidth - winWidth, Math.max(0, scrollLeft));
}).skipDuplicates().onValue(function(x) {$('.sidebar').css('left', x)});
</script><!-- Yandex.Metrika counter --><script type="text/javascript">(function (d, w, c) { (w[c] = w[c] || []).push(function() { try { w.yaCounter26158662 = new Ya.Metrika({id:26158662}); } catch(e) { } }); var n = d.getElementsByTagName("script")[0], s = d.createElement("script"), f = function () { n.parentNode.insertBefore(s, n); }; s.type = "text/javascript"; s.async = true; s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js"; if (w.opera == "[object Opera]") { d.addEventListener("DOMContentLoaded", f, false); } else { f(); } })(document, window, "yandex_metrika_callbacks");</script><noscript><div><img src="//mc.yandex.ru/watch/26158662" style="position:absolute; left:-9999px;" alt="" /></div></noscript><!-- /Yandex.Metrika counter --></body></html>