<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Kefir.js — fast and light Reactive Programming library for JavaScript inspired by Bacon.js and RxJS</title><meta name="viewport" content="width=device-width, initial-scale=1"><style type="text/css">html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block;vertical-align:baseline}audio:not([controls]){display:none;height:0}[hidden],template{display:none}a{background:0 0}a:active,a:hover{outline:0}abbr[title]{border-bottom:1px dotted}b,strong{font-weight:700}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sup{top:-.5em}sub{bottom:-.25em}img{border:0}svg:not(:root){overflow:hidden}figure{margin:1em 40px}hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}pre{overflow:auto}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}button{overflow:visible}button,select{text-transform:none}button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}button[disabled],html input[disabled]{cursor:default}button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}input{line-height:normal}input[type=checkbox],input[type=radio]{box-sizing:border-box;padding:0}input[type=number]::-webkit-inner-spin-button,input[type=number]::-webkit-outer-spin-button{height:auto}input[type=search]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}input[type=search]::-webkit-search-cancel-button,input[type=search]::-webkit-search-decoration{-webkit-appearance:none}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{border:0;padding:0}textarea{overflow:auto}optgroup{font-weight:700}table{border-collapse:collapse;border-spacing:0}td,th{padding:0}body{font-size:14px;line-height:22px;background:#f4f4f4;color:#000;min-width:700px}a{color:#476cff;text-decoration:none}a:hover{text-decoration:underline}p{margin:20px 0}h2{padding-top:1em}h2{font-size:20px}h2 small,h2 sup,h2 sub{font-weight:normal}h1 small{color:#b1b1b1;line-height:2}h1 sup{font-weight:normal}table,tr,td{margin:0;padding:0}td,th{padding:2px 14px 2px 0}th{text-align:left}table .rule{padding:5px 0}table .rule:after{content:'';display:block;border-bottom:solid 1px #ddd}ul{list-style-type:square;padding:0 0 0 20px}li{margin-bottom:10px}code,pre,tt{font-family:Monaco, Consolas, "Lucida Console", monospace;font-size:12px;line-height:18px;font-style:normal}tt{padding:0px 3px;background:#fbfbfb;border:1px solid #ddd;zoom:1;font-size:.8em}code{margin-left:20px}pre{font-size:12px;padding:2px 2px 2px 12px;border-left:2px solid #DFDFDF;margin:0 0 30px;overflow:auto;background:#fbfbfb;position:relative}pre[title]:after{content:attr(title);position:absolute;top:0;right:0;padding:0 .5em;font-size:.8em;color:#8b8b8b;background:rgba(251, 251, 251, 0.9)}pre + pre{margin-top:-10px}.sidebar{background:#fff;position:fixed;top:0;left:0;bottom:0;width:240px;overflow-y:auto;overflow-x:hidden;-webkit-overflow-scrolling:touch;padding:15px 30px 30px;border-right:1px solid #bbb;box-shadow:0 0 20px #ccc;font-family:"Lucida Grande", "Lucida Sans Unicode", Helvetica, Arial, sans-serif}@media (max-width: 1200px){.sidebar{width:170px}}.sidebar a{color:inherit}.toc-title{display:block;font-weight:bold;margin-top:20px;line-height:1.2;margin-bottom:10px}.toc-section{font-size:11px;line-height:14px;margin:5px 0 0 0;padding-left:0px;list-style-type:none}.toc-section li{margin:0 0 3px 0}.toc-section a{text-decoration:none}.toc-section a:hover{text-decoration:underline}.container{max-width:680px;margin:40px 10px 50px 330px;font-family:Helvetica, Arial, sans-serif}@media (max-width: 1200px){.container{margin-left:260px}}.header{font-size:16px;line-height:30px;font-weight:bold;color:inherit}.alias,.shorthand{display:block;margin-left:1em;margin-bottom:.4em}.alias:before,.shorthand:before{content:'Alias:';font-family:Helvetica, Arial, sans-serif;font-style:italic;font-size:1.1em;font-weight:bold;margin-right:.5em}.shorthand:before{content:'Shorthand for:'}p[id]{margin-top:4em}h2[id]:not(.no-extra-padding){margin-top:3em}h2[id] + p[id]{margin-top:3em}.logo-img{width:60px;height:60px;vertical-align:bottom;margin-bottom:-4px}[data-emoji]{width:20px;height:20px;visibility:hidden}[data-emoji][src]{visibility:visible}</style></head><body><div class="sidebar"><a href="#" class="toc-title">Kefir.js</a><ul class="toc-section"><li><a href="#downloads">Downloads</a></li><li><a href="#npm-bower">Install via NPM or Bower</a></li><li><a href="#demos">Demos and examples</a></li></ul><a href="#create-stream" class="toc-title">Create a stream</a><ul class="toc-section"><li>- <a href="#emitter">emitter</a></li><li>- <a href="#never">never</a></li><li>- <a href="#later">later</a></li><li>- <a href="#interval">interval</a></li><li>- <a href="#sequentially">sequentially</a></li><li>- <a href="#repeatedly">repeatedly</a></li><li>- <a href="#from-poll">fromPoll</a></li><li>- <a href="#with-interval">withInterval</a></li><li>- <a href="#from-callback">fromCallback</a></li><li>- <a href="#from-event">fromEvent</a></li><li>- <a href="#from-binder">fromBinder</a></li></ul><a href="#create-property" class="toc-title">Create a property</a><ul class="toc-section"><li>- <a href="#constant">constant</a></li></ul><a href="#jquery" class="toc-title">jQuery addon</a><ul class="toc-section"><li>- <a href="#as-kefir-stream">asKefirStream</a></li><li>- <a href="#as-kefir-property">asKefirProperty</a></li></ul><a href="#convert" class="toc-title">Convert observables</a><ul class="toc-section"><li>- <a href="#to-property">toProperty</a></li><li>- <a href="#changes">changes</a></li></ul><a href="#main-methods" class="toc-title">Main observable methods</a><ul class="toc-section"><li>- <a href="#on-value">onValue</a></li><li>- <a href="#off-value">offValue</a></li><li>- <a href="#on-end">onEnd</a></li><li>- <a href="#off-end">offEnd</a></li><li>- <a href="#on-any">onAny</a></li><li>- <a href="#off-any">offAny</a></li><li>- <a href="#log">log</a></li><li>- <a href="#off-log">offLog</a></li></ul><a href="#modify" class="toc-title">Modify an observable</a><ul class="toc-section"><li>- <a href="#map">map</a></li><li>- <a href="#map-to">mapTo</a></li><li>- <a href="#pluck">pluck</a></li><li>- <a href="#invoke">invoke</a></li><li>- <a href="#not">not</a></li><li>- <a href="#timestamp">timestamp</a></li><li>- <a href="#tap">tap</a></li><li>- <a href="#filter">filter</a></li><li>- <a href="#take">take</a></li><li>- <a href="#take-while">takeWhile</a></li><li>- <a href="#skip">skip</a></li><li>- <a href="#skip-while">skipWhile</a></li><li>- <a href="#skip-duplicates">skipDuplicates</a></li><li>- <a href="#diff">diff</a></li><li>- <a href="#scan">scan</a></li><li>- <a href="#reduce">reduce</a></li><li>- <a href="#sliding-window">slidingWindow</a></li><li>- <a href="#delay">delay</a></li><li>- <a href="#throttle">throttle</a></li><li>- <a href="#debounce">debounce</a></li><li>- <a href="#flatten">flatten</a></li><li>- <a href="#transduce">transduce</a></li><li>- <a href="#with-handler">withHandler</a></li></ul><a href="#combine-observables" class="toc-title">Combine observables</a><ul class="toc-section"><li>- <a href="#combine">combine</a></li><li>- <a href="#and">and</a></li><li>- <a href="#or">or</a></li><li>- <a href="#sampled-by">sampledBy</a></li><li>- <a href="#merge">merge</a></li><li>- <a href="#concat">concat</a></li><li>- <a href="#pool">pool</a></li><li>- <a href="#bus">bus</a></li><li>- <a href="#flat-map">flatMap</a></li><li>- <a href="#flat-map-latest">flatMapLatest</a></li><li>- <a href="#flat-map-first">flatMapFirst</a></li><li>- <a href="#flat-map-concat">flatMapConcat</a></li><li>- <a href="#flat-map-with-concurrency-limit">flatMapConcurLimit</a></li></ul><a href="#combine-two" class="toc-title">Combine two observables</a><ul class="toc-section"><li>- <a href="#filter-by">filterBy</a></li><li>- <a href="#take-while-by">takeWhileBy</a></li><li>- <a href="#skip-while-by">skipWhileBy</a></li><li>- <a href="#skip-until-by">skipUntilBy</a></li><li>- <a href="#take-until-by">takeUntilBy</a></li><li>- <a href="#awaiting">awaiting</a></li></ul><a href="#active-state" class="toc-title">Active state</a><a href="#callbacks" class="toc-title">About callbacks</a><a href="#emitter-object" class="toc-title">Emitter object</a></div><div class="container"><h1><img src="Kefir.svg" class="logo-img"> Kefir.js <sup>0.3.0 (<a href="https://github.com/pozadi/kefir/blob/master/changelog.md">changelog</a>)</sup></h1><p>Kefir &mdash; is an Reactive Programming
library for JavaScript inspired by
<a href="https://github.com/baconjs/bacon.js">Bacon.js</a>
and
<a href="http://reactive-extensions.github.io/RxJS/">RxJS</a>
with focus on high perfomance and low memory usage.

</p><p>Kefir has
<a href="https://github.com/pozadi/kefir">
  <img data-emoji="octocat"> GitHub repository</a>, where you can
<a href="https://github.com/pozadi/kefir/pulls">send pull requests</a>,
<a href="https://github.com/pozadi/kefir/issues">report bugs</a>,
and have fun reading
<a href="https://github.com/pozadi/kefir/tree/master/src">source code</a>.
</p><p>If you spot a typo or grammar error, or know how to improve this documentation,
please help the project by
<a href="https://github.com/pozadi/kefir/issues/new">filing an issue</a>
or sending a pull request.
</p><h2 id="downloads">Downloads <sup>(0.3.0)</sup></h2><table><tr><th rowspan="2" valign="top">Main file</th><td><a href="dist/kefir.js">kefir.js</a></td><td><i>~ 50 kb</i></td></tr><tr><td><a href="dist/kefir.min.js">kefir.min.js</a></td><td><i>~ 7 kb (when gzipped)</i></td></tr><tr id="jquery-addon-download"><th rowspan="2" valign="top">jQuery addon</th><td><a href="dist/addons/kefir-jquery.js">kefir-jquery.js</a></td><td><i>~ 1 kb</i></td></tr><tr><td><a href="dist/addons/kefir-jquery.min.js">kefir-jquery.min.js</a></td><td><i>&lt; 1 kb</i></td></tr><tr><td colspan="3" class="rule"></td></tr><tr><th>All files</th><td><a href="https://github.com/pozadi/kefir/archive/0.3.0.zip">kefir-0.3.0.zip</a></td><td>... including documentation, demos, tests, source maps, etc.</td></tr></table><p>You can also
<a href="https://github.com/pozadi/kefir/tree/master/dist">
  get edge versions from GitHub</a>
(<a href="https://github.com/pozadi/kefir/archive/master.zip">.zip</a>),
but use it at your own risk

</p><h2 id="npm-bower">NPM and Bower</h2><pre>npm install kefir
</pre><pre>bower install kefir</pre><div></div><h2 id="demos">Demos and examples</h2><ul><li><a href="demos/counter.html">Counter</a> — most basic example</li><li><a href="demos/position.html">Position</a> — another basic example</li><li><a href="demos/custom-stream.html">Custom stream</a> — how to create custom event stream from any source of events</li><li><a href="demos/tree.html">Tree</a> — Bacon.js vs Kefir.js perfomance comparison, and also nice tree animation demo</li></ul><p><img data-emoji="information_desk_person">
Also almost any code snippet below can be ran in browser console on this page.
So you can play with Kefir right now, just open up browser console.</p><h2 id="create-stream">Create a stream</h2><p id="emitter"><a href="#emitter" class="header">emitter</a><code>Kefir.emitter()</code><br/>Creates an emitter, that is ordinary stream, but also has additional methods:
<tt>.emit(value)</tt> and <tt>.end()</tt>.
Then you can easily send events to stream via <b>emit()</b>.
</p><pre title="example">var emitter = Kefir.emitter();
emitter.log(); // log events to console (see <a href="#log">log</a>)
emitter.emit(1);
emitter.emit(2);
emitter.end();
</pre><pre title="console output">&gt; [emitter] &lt;value&gt; 1
&gt; [emitter] &lt;value&gt; 2
&gt; [emitter] &lt;end&gt;
</pre><pre title="events in time">emitter:  ----1----2----X</pre><div></div><p><img data-emoji="point_up"> <b>Emitter</b> is the easiest way
to create general purpose stream,
but it doesn't give control over <b>active</b> state of stream
(see <a href="#active-state">active state</a>).
If you want to create general purpose stream and
have control over <b>active</b> state, you should use
<a href="from-binder">fromBinder</a>.



</p><p id="never"><a href="#never" class="header">never</a><code>Kefir.never()</code><br/>Creates a stream, that already ended and will never produce any events.
</p><pre title="example">var stream = Kefir.never();
stream.log();
</pre><pre title="console output">&gt; [never] &lt;end:current&gt;
</pre><pre title="events in time">stream:  X</pre><div></div><p id="later"><a href="#later" class="header">later</a><code>Kefir.later(wait, value)</code><br/>Creates a stream, that produces single <b>value</b>
after <b>wait</b> milliseconds then ends.
</p><pre title="example">var stream = Kefir.later(1000, 1);
stream.log();
</pre><pre title="console output (after 1 second)">&gt; [later] &lt;value&gt; 1
&gt; [later] &lt;end&gt;
</pre><pre title="events in time">stream:  ----1X</pre><div></div><p id="interval"><a href="#interval" class="header">interval</a><code>Kefir.interval(interval, value)</code><br/>Creates a stream, that produces same <b>value</b>
each <b>interval</b> milliseconds. Never ends.
</p><pre title="example">var stream = Kefir.interval(1000, 1);
stream.log();
</pre><pre title="console output">&gt; [interval] &lt;value&gt; 1
&gt; [interval] &lt;value&gt; 1
&gt; [interval] &lt;value&gt; 1
...
</pre><pre title="events in time">stream:  ----1----1----1----1---</pre><div></div><p id="sequentially"><a href="#sequentially" class="header">sequentially</a><code>Kefir.sequentially(interval, values)</code><br/>Creates a stream containing given <b>values</b> (array),
delivered with given <b>interval</b> in milliseconds.
Ends after all <b>values</b> delivered.
</p><pre title="example">var stream = Kefir.sequentially(1000, [1, 2, 3]);
stream.log();
</pre><pre title="console output">&gt; [sequentially] &lt;value&gt; 1
&gt; [sequentially] &lt;value&gt; 2
&gt; [sequentially] &lt;value&gt; 3
&gt; [sequentially] &lt;end&gt;
</pre><pre title="events in time">stream:  ----1----2----3X</pre><div></div><p id="repeatedly"><a href="#repeatedly" class="header">repeatedly</a><code>Kefir.repeatedly(interval, values)</code><br/>Creates a stream, that produces given <b>values</b> (array),
with given <b>interval</b> in milliseconds.
When all values emitted, it begins to produce them again from start.
Never ends.
</p><pre title="example">var stream = Kefir.repeatedly(1000, [1, 2, 3]);
stream.log();
</pre><pre title="console output">&gt; [repeatedly] &lt;value&gt; 1
&gt; [repeatedly] &lt;value&gt; 2
&gt; [repeatedly] &lt;value&gt; 3
&gt; [repeatedly] &lt;value&gt; 1
&gt; [repeatedly] &lt;value&gt; 2
&gt; [repeatedly] &lt;value&gt; 3
&gt; [repeatedly] &lt;value&gt; 1
...
</pre><pre title="events in time">stream:  ----1----2----3----1----2----3----1---</pre><div></div><p id="from-poll"><a href="#from-poll" class="header">fromPoll</a><code>Kefir.fromPoll(interval, fn)</code><br/>Creates a stream, that polls given <b>fn</b> function,
with given <b>interval</b> in milliseconds,
and emits values returned by <b>fn</b>.
Never ends.
</p><pre title="example">var start = new Date();
var stream = Kefir.fromPoll(1000, function(){ return new Date() - start });
stream.log();
</pre><pre title="console output">&gt; [fromPoll] &lt;value&gt; 1001
&gt; [fromPoll] &lt;value&gt; 2002
&gt; [fromPoll] &lt;value&gt; 3004
&gt; [fromPoll] &lt;value&gt; 4006
&gt; [fromPoll] &lt;value&gt; 5007
&gt; [fromPoll] &lt;value&gt; 6007
...
</pre><pre title="events in time">stream:  ----(1001)----(2002)----(3004)----(4006)---</pre><div></div><p id="with-interval"><a href="#with-interval" class="header">withInterval</a><code>Kefir.withInterval(interval, handler)</code><br/>General method to create an interval based stream.
Creates a stream, that call given <b>handler</b> function,
with given <b>interval</b> in milliseconds.
<b>Handler</b> is called with one argument — <b>emitter object</b>
(it's similar to <a href="#emitter">emitter stream</a>
but not actualy a stream, you can read more about emitter object
<a href="#emitter-object">here</a>).
</p><pre title="example">var start = new Date();
var stream = Kefir.withInterval(1000, function(emitter) {
  var time = new Date() - start;
  if (time &lt; 4000) {
    emitter.emit(time);   // emit a value
  } else {
    emitter.end();        // end the stream
  }
});
stream.log();
</pre><pre title="console output">&gt; [withInterval] &lt;value&gt; 1002
&gt; [withInterval] &lt;value&gt; 2003
&gt; [withInterval] &lt;value&gt; 3005
&gt; [withInterval] &lt;end&gt;
</pre><pre title="events in time">stream:  ----(1002)----(2003)----(3005)----X</pre><div></div><p>You may call <b>emitter.emit</b> several times on each interval tick,
or not call it at all.


</p><p id="from-callback"><a href="#from-callback" class="header">fromCallback</a><code>Kefir.fromCallback(fn)</code><br/>Convert a <b>fn</b> function than accepts <b>callback</b>
as first argument to a stream.
Emits at most one value when <b>callback</b> is called then ends.
<b>Fn</b> will be called at most
once on first <a href="#active-state">activation</a> of a stream
(i.e. when first subscriber added).
</p><pre title="example">var stream = Kefir.fromCallback(function(callback) {
  // we use setTimeout here just to simulate some asynchronous activity
  setTimeout(function() {  callback(1)  }, 1000);
});
stream.log();
</pre><pre title="console output">&gt; [fromCallback] &lt;value&gt; 1
&gt; [fromCallback] &lt;end&gt;
</pre><pre title="events in time">stream:  ----1X</pre><div></div><p>Another example where we use <a href="#callbacks">an array form of function</a>:</p><pre title="example">var url = &#x27;http://pozadi.github.io/kefir/&#x27;;
var stream = Kefir.fromCallback([jQuery.get, null, url]);
stream.log();
</pre><pre title="console output">&gt; [fromCallback] &lt;value&gt; &lt;!DOCTYPE html&gt;&lt;html...
&gt; [fromCallback] &lt;end&gt;</pre><div></div><pre title="events in time">stream:  ----(&quot;&lt;!DOCTYPE html&gt;&lt;html...&quot;)X</pre><div></div><p id="from-event"><a href="#from-event" class="header">fromEvent</a><code>Kefir.fromEvent(target, eventName, [transform])</code><br/>Creates an stream from events on a DOM EventTarget or Node.JS EventEmitter
object, or an object that supports event listeners using <tt>on/off</tt> methods.
You can also pass optional transformation function like in
<a href="#as-kefir-stream">asKefirStream</a> method.
</p><pre title="example">var stream = Kefir.fromEvent(document.body, &#x27;click&#x27;);
stream.log()
</pre><pre title="console output">&gt; [fromEvent] &lt;value&gt; MouseEvent {dataTransfer: null, y: 474, x: 551 ...}
&gt; [fromEvent] &lt;value&gt; MouseEvent {dataTransfer: null, y: 361, x: 751 ...}
&gt; [fromEvent] &lt;value&gt; MouseEvent {dataTransfer: null, y: 444, x: 1120 ...}
</pre><pre title="events in time">stream:  ----e--e----e---</pre><div></div><p>Note that it uses <tt>addEventListener()</tt> for DOM events,
which is not supported by IE8. If you need IE8 support use
<a href="#jquery">jQuery addon</a>.


</p><p id="from-binder"><a href="#from-binder" class="header">fromBinder</a><code>Kefir.fromBinder(subscribe)</code><br/>Another method for creation general purpose stream,
along with <a href="#emitter">emitter</a>.
Unlike <b>emitter</b> it gives you control over
<a href="#active-state">active state</a> of the stream.
</p><p>Creates stream which call <b>subscribe</b> function on each <b>activation</b>,
passing to it an <a href="#emitter-object">emitter object</a>.
Then you can call <b>emiter.emit</b> or <b>emitter.end</b> at any time
to emit value or end the stream.
<b>Subscribe</b> function can also return an <b>unsubscribe</b> function,
that will be called on <b>deactivation</b> of the stream.
Read about <a href="#active-state">active state</a> to understand what
<b>activation</b> and <b>deactivation</b> means.
</p><pre title="example">var stream = Kefir.fromBinder(function(emitter) {
  console.log(&#x27;!activation&#x27;);
  var i = 0;
  var intervalId = setInterval(function() {
    emitter.emit(++i);
  }, 1000);
  return function() {
    console.log(&#x27;!deactivation&#x27;);
    clearInterval(intervalId);
  }
});
stream.log();
setTimeout(function() {
  stream.offLog(); // turn off logging to deactivate stream
}, 3500);
</pre><pre title="console output">&gt; !activation
&gt; [fromBinder] &lt;value&gt; 1
&gt; [fromBinder] &lt;value&gt; 2
&gt; [fromBinder] &lt;value&gt; 3
&gt; !deactivation
</pre><pre title="events in time">stream:  ----1----2----3---</pre><div></div><p>See also <a href="demos/custom-stream.html">Custom stream demo</a>
as another <b>fromBinder</b> usage example.



</p><h2 id="create-property">Create a property</h2><p>For now there is only one method that creates a property directly —
<tt>constant()</tt>. But you can always convert any stream to a property using
<a href="#to-property">toProperty</a> method.
</p><p id="constant"><a href="#constant" class="header">constant</a><code>Kefir.constant(value)</code><br/>Creates ended property, with specified <b>current value</b>.
</p><pre title="example">var property = Kefir.constant(1);
property.log();
</pre><pre title="console output">&gt; [constant] &lt;value:current&gt; 1
&gt; [constant] &lt;end:current&gt;
</pre><pre title="events in time">property: 1X</pre><div></div><h2 id="jquery">jQuery addon</h2><p>jQuery functionality comes as an addon for core Kefir.js library.
In order to use it you should include addon JavaScript file,
that can be found in <a href="#downloads">downloads section</a>.
</p><p id="as-kefir-stream"><a href="#as-kefir-stream" class="header">asKefirStream</a><code>$(...).asKefirStream(eventName, [selector], [eventTransformer])</code><br/>Creates a stream from events on a jQuery object. This methods mimics
<a href="http://api.jquery.com/on/" target="_balnk">jQuery .on method</a> with
two exceptions: it not accepts <b>data</b> argument, and instead of
<b>handler</b> function it accepts optional <b>eventTransformer</b> function,
which, if provided, will be called on each event with same arguments and
context as jQuery <b>handler</b> callback, and value returned by
<b>eventTransformer</b> will be emitted to Kefir stream.
If no <b>eventTransformer</b> provided, jQuery event object
will be emited in stream.
</p><pre title="example">var clicks = $('body').asKefirStream('click');
clicks.log();
</pre><pre title="console output">&gt; [asKefirStream] &lt;value&gt; jQuery.Event {originalEvent: MouseEvent...}
&gt; [asKefirStream] &lt;value&gt; jQuery.Event {originalEvent: MouseEvent...}
&gt; [asKefirStream] &lt;value&gt; jQuery.Event {originalEvent: MouseEvent...}
</pre><pre title="events in time">clicks: --e----e--e---</pre><div></div><p>Example with optional arguments:
</p><pre title="example">var clicksOnContainer = $('body').asKefirStream('click', '.container');
clicksOnContainer.log('[clicks on .container]');

var clicksPageX = $('body').asKefirStream('click', function(e) {return e.pageX});
clicksPageX.log('[e.pageX]');
</pre><pre title="console output">&gt; [clicks on .container] &lt;value&gt; jQuery.Event {originalEvent: MouseEvent...}
&gt; [e.pageX] &lt;value&gt; 643
&gt; [e.pageX] &lt;value&gt; 15
&gt; [clicks on .container] &lt;value&gt; jQuery.Event {originalEvent: MouseEvent...}
&gt; [e.pageX] &lt;value&gt; 721
</pre><pre title="events in time">clicksOnContainer: ----( e )----------( e )---
clicksPageX:       ----(643)---(15)---(721)---</pre><div></div><p id="as-kefir-property"><a href="#as-kefir-property" class="header">asKefirProperty</a><code>$(...).asKefirProperty(eventName, [selector], getter)</code><code class="shorthand">$(...).asKefirStream(eventName, [selector], getter).toProperty(getter())</code>Like <b>asKefirStream</b>, but instead of optional <b>eventTransformer</b> accepts
required <b>getter</b> function, which is called like <b>eventTransformer</b>
for each new event, but also called once without any argument
at moment when property is created.
Also unlike <b>asKefirStream</b> returns a property.
</p><pre title="example">var cursorPosition = $('body').asKefirProperty('mousemove', function(event) {
  if (!event) { // if no event passed then it's an "on creation" call
    return [0, 0];
  } else {
    return [event.pageX, event.pageY];
  }
});
cursorPosition.log();
</pre><pre title="console output">&gt; [asKefirProperty] &lt;value:current&gt; [0, 0]
&gt; [asKefirProperty] &lt;value&gt; [551, 1168]
&gt; [asKefirProperty] &lt;value&gt; [551, 1168]
&gt; [asKefirProperty] &lt;value&gt; [556, 1161]
&gt; ...
</pre><pre title="events in time">cursorPosition: ([0, 0])---([551, 1168])----([551, 1168])--([556, 1161])---</pre><div></div><h2 id="convert">Convert observables</h2><p id="to-property"><a href="#to-property" class="header">toProperty</a><code>stream.toProperty([current])</code><br/>Converts a stream to a property.
Accepts optional <b>current</b> argument, which becomes current value of the
property.
</p><pre title="example">var source = Kefir.sequentially(100, [1, 2, 3]);
var result = source.toProperty(0);
result.log();
</pre><pre title="console output">&gt; [sequentially.toProperty] &lt;value:current&gt; 0
&gt; [sequentially.toProperty] &lt;value&gt; 1
&gt; [sequentially.toProperty] &lt;value&gt; 2
&gt; [sequentially.toProperty] &lt;value&gt; 3
&gt; [sequentially.toProperty] &lt;end&gt;
</pre><pre title="events in time">source:  ----1----2----3X
result: 0----1----2----3X</pre><div></div><p id="changes"><a href="#changes" class="header">changes</a><code>property.changes()</code><br/>Converts a property to a stream.
If property has current value, it will be ignored
(stream's subscribers won't get it).
</p><pre title="example">var source = Kefir.sequentially(100, [1, 2, 3]);
var property = source.toProperty(0);
var result = property.changes();
result.log();
</pre><pre title="console output">&gt; [sequentially.toProperty.changes] &lt;value&gt; 1
&gt; [sequentially.toProperty.changes] &lt;value&gt; 2
&gt; [sequentially.toProperty.changes] &lt;value&gt; 3
&gt; [sequentially.toProperty.changes] &lt;end&gt;
</pre><pre title="events in time">property: 0----1----2----3X
result:    ----1----2----3X</pre><div></div><h2 id="main-methods">Main observable* methods</h2><p><b>*</b> stream or property

</p><p id="on-value"><a href="#on-value" class="header">onValue</a><code>obs.onValue(fn)</code><br/>Subscribes <b>fn</b> functions to values on an observable.
If <b>onValue</b> called on a property, and property has
current value, <b>fn</b> will be called
immediately with property current value as argument.
</p><pre title="example">var emitter = Kefir.emitter();
emitter.onValue(function(x) {  console.log('value:', x)  });
emitter.emit(1);
emitter.emit(2);
</pre><pre title="console output">&gt; value: 1
&gt; value: 2
</pre><p id="off-value"><a href="#off-value" class="header">offValue</a><code>obs.offValue(fn)</code><br/>Unsubscribes <b>fn</b> from values on an observable.
</p><p id="on-end"><a href="#on-end" class="header">onEnd</a><code>obs.onEnd(fn)</code><br/>Subscribes <b>fn</b> functions to ending off an observable.
If observable already ended, <b>fn</b> will be called immediately.
</p><pre title="example">var emitter = Kefir.emitter();
emitter.onEnd(function(x) {  console.log('stream ended')  });
emitter.end();
</pre><pre title="console output">&gt; stream ended
</pre><p id="off-end"><a href="#off-end" class="header">offEnd</a><code>obs.offEnd(fn)</code><br/>Unsubscribes <b>fn</b> from ending off an observable.
</p><p id="on-any"><a href="#on-any" class="header">onAny</a><code>obs.onAny(fn)</code><br/>Subscribes <b>fn</b> functions to both ending and values on an observable.
Callback is called with <b>event object</b> as argument. Each event object
contains three attributes — <b>type</b>, <b>value</b>, and <b>current</b>.
</p><ul><li><b>type</b> is a <tt>'value'</tt> or <tt>'end'</tt> string</li><li><b>value</b> is a value that was emitted,
or <tt>undefined</tt> if <b>type</b> was <tt>'end'</tt></li><li><b>current</b> is a boolean, that equals <tt>true</tt> if callback was
called with current value of a property, or on end of already ended observable</li></ul><pre title="example">var emitter = Kefir.emitter();
emitter.onAny(function(event) {  console.log('event:', event)  });
emitter.emit(1);
emitter.emit(2);
emitter.end();
</pre><pre title="console output">&gt; event: Object {type: &quot;value&quot;, value: 1, current: false}
&gt; event: Object {type: &quot;value&quot;, value: 2, current: false}
&gt; event: Object {type: &quot;end&quot;, value: undefined, current: false}
</pre><p id="off-any"><a href="#off-any" class="header">offAny</a><code>obs.offAny(fn)</code><br/>Unsubscribes an <b>onAny</b> subscriber.
</p><p id="log"><a href="#log" class="header">log</a><code>obs.log([name])</code><br/>Turns on logging of any events on an observable to browser console.
Accepts optional <b>name</b> argument that will be shown in log if provided.
</p><pre title="example">var emitter = Kefir.emitter();
emitter.log('myEmitter');
emitter.emit(1);
emitter.emit(2);
emitter.end();
</pre><pre title="console output">&gt; myEmitter &lt;value&gt; 1
&gt; myEmitter &lt;value&gt; 2
&gt; myEmitter &lt;end&gt;
</pre><p id="off-log"><a href="#off-log" class="header">offLog</a><code>obs.offLog([name])</code><br/>Turns off logging. If <b>.log</b> was called with <b>name</b> argument,
<b>offLog</b> must be called with same <b>name</b> argument.</p><h2 id="modify">Modify an observable</h2><p>All methods in this section create a new observable of same kind* from an original one.
New observable applies some transformation to each event from original
and emits result of transformation.
In most cases a transformation is applied only to <b>value events</b>,
but <b>end event</b> just passes through (i.e. new observable ends when original ends).
</p><p><b>*</b> For example if original observable was a stream,
then new one also will be a stream. Same for properties.
This rule has one exception for <a href="#scan">scan method</a>,
that always returns a property.


</p><p id="map"><a href="#map" class="header">map</a><code>obs.map(fn)</code><br/>Applies given <b>fn</b> function to each value from original observable
and emits value returned by <b>fn</b>.
</p><pre title="example">var source = Kefir.sequentially(100, [1, 2, 3]);
var result = source.map(function(x) {  return x + 1  });
result.log();
</pre><pre title="console output">&gt; [sequentially.map] &lt;value&gt; 2
&gt; [sequentially.map] &lt;value&gt; 3
&gt; [sequentially.map] &lt;value&gt; 4
&gt; [sequentially.map] &lt;end&gt;</pre><div></div><pre title="events in time">source: ---1---2---3X
result: ---2---3---4X</pre><div></div><p id="map-to"><a href="#map-to" class="header">mapTo</a><code>obs.mapTo(value)</code><code class="shorthand">obs.map(function() {return value})</code>On each value from original observable emits given <b>value</b>.<br>
</p><pre title="example">var source = Kefir.sequentially(100, [1, 2, 3]);
var result = source.mapTo(5);
result.log();
</pre><pre title="console output">&gt; [sequentially.mapTo] &lt;value&gt; 5
&gt; [sequentially.mapTo] &lt;value&gt; 5
&gt; [sequentially.mapTo] &lt;value&gt; 5
&gt; [sequentially.mapTo] &lt;end&gt;
</pre><pre title="events in time">source: ---1---2---3X
result: ---5---5---5X</pre><div></div><p id="pluck"><a href="#pluck" class="header">pluck</a><code>obs.pluck(propertyName)</code><code class="shorthand">obs.map(function(x) {return x.foo})</code>On each value from original observable emits <tt>value[propertyName]</tt>.<br>
</p><pre title="example">var source = Kefir.sequentially(100, [{num: 1}, {num: 2}, {num: 3}]);
var result = source.pluck('num');
result.log();
</pre><pre title="console output">&gt; [sequentially.pluck] &lt;value&gt; 1
&gt; [sequentially.pluck] &lt;value&gt; 2
&gt; [sequentially.pluck] &lt;value&gt; 3
&gt; [sequentially.pluck] &lt;end&gt;</pre><div></div><pre title="events in time">source: ---({num: 1})---({num: 2})---({num: 3})X
result: ---(   1    )---(   2    )---(   3    )X</pre><div></div><p id="invoke"><a href="#invoke" class="header">invoke</a><code>obs.invoke(methodName)</code><code class="shorthand">obs.map(function(x) {return x.foo()})</code>Just like <b>.pluck</b>, but instead of emitting <tt>value[propertyName]</tt>
it emits <tt>value[methodName]()</tt>,
i.e. calls method <b>methodName</b> of each value object
and emits whatever it returns.<br>
</p><pre title="example">var source = Kefir.sequentially(100, [
  {foo: function(){return 1}},
  {foo: function(){return 2}},
  {foo: function(){return 3}}
]);
var result = source.invoke('foo');
result.log();
</pre><pre title="console output">&gt; [sequentially.invoke] &lt;value&gt; 1
&gt; [sequentially.invoke] &lt;value&gt; 2
&gt; [sequentially.invoke] &lt;value&gt; 3
&gt; [sequentially.invoke] &lt;end&gt;
</pre><pre title="events in time">source: ---({foo: ()=&gt;1})---({foo: ()=&gt;2})---({foo: ()=&gt;3})X
result: ---(     1      )---(     2      )---(     3      )X</pre><div></div><p id="not"><a href="#not" class="header">not</a><code>obs.not()</code><code class="shorthand">obs.map(function(x) {return !x})</code>Inverts every value from original observable using <tt>!</tt> operator.<br>
</p><pre title="example">var source = Kefir.sequentially(100, [true, false, true]);
var result = source.not();
result.log();
</pre><pre title="console output">&gt; [sequentially.not] &lt;value&gt; false
&gt; [sequentially.not] &lt;value&gt; true
&gt; [sequentially.not] &lt;value&gt; false
&gt; [sequentially.not] &lt;end&gt;
</pre><pre title="events in time">source: ---t---f---tX
result: ---f---t---fX</pre><div></div><p id="timestamp"><a href="#timestamp" class="header">timestamp</a><code>obs.timestamp()</code><code class="shorthand">obs.map(function(x) {return {value: x, time: new Date().getTime()}})</code>Wraps each value to object with timestamp of the event.
</p><pre title="example">var source = Kefir.sequentially(100, [1, 2]);
var result = source.timestamp();
result.log();
</pre><pre title="console output">&gt; [sequentially.timestamp] &lt;value&gt; Object {value: 1, time: 1413022203878}
&gt; [sequentially.timestamp] &lt;value&gt; Object {value: 2, time: 1413022203980}
&gt; [sequentially.timestamp] &lt;end&gt;
</pre><pre title="events in time">source: ---(          1          )---(          2          )X
result: ---({value: 1, time: ...})---({value: 2, time: ...})X</pre><div></div><p id="tap"><a href="#tap" class="header">tap</a><code>obs.tap(fn)</code><br/>Just like <b>.map</b> applies given <b>fn</b>
function to each value from original observable, but emits original value
(not what <b>fn</b> returns).
</p><pre title="example">var source = Kefir.sequentially(100, [1, 2, 3]);
var result = source.tap(function(x) {
  console.log('from tap fn:', x);
  return 5; // will be ignored
});
result.log();
</pre><pre title="console output">&gt; from tap fn: 1
&gt; [sequentially.tap] &lt;value&gt; 1
&gt; from tap fn: 2
&gt; [sequentially.tap] &lt;value&gt; 2
&gt; from tap fn: 3
&gt; [sequentially.tap] &lt;value&gt; 3
&gt; [sequentially.tap] &lt;end&gt;
</pre><pre title="events in time">source: ---1---2---3X
result: ---1---2---3X</pre><div></div><p id="filter"><a href="#filter" class="header">filter</a><code>obs.filter(predicate)</code><br/>Filters values from original observable
using given <b>predicate</b> function.
</p><pre title="example">var source = Kefir.sequentially(100, [1, 2, 3]);
var result = source.filter(function(x) {  return x &gt; 1  });
result.log();
</pre><pre title="console output">&gt; [sequentially.filter] &lt;value&gt; 2
&gt; [sequentially.filter] &lt;value&gt; 3
&gt; [sequentially.filter] &lt;end&gt;
</pre><pre title="events in time">source: ---1---2---3X
result: -------2---3X</pre><div></div><p>See also <a href="#filter-by">filterBy</a>.


</p><p id="take"><a href="#take" class="header">take</a><code>obs.take(n)</code><br/>Emits first <b>n</b> values from original observable, then ends.
</p><pre title="example">var source = Kefir.sequentially(100, [1, 2, 3]);
var result = source.take(2);
result.log();
</pre><pre title="console output">&gt; [sequentially.take] &lt;value&gt; 1
&gt; [sequentially.take] &lt;value&gt; 2
&gt; [sequentially.take] &lt;end&gt;
</pre><pre title="events in time">source: ---1---2---3X
result: ---1---2X</pre><div></div><p id="take-while"><a href="#take-while" class="header">takeWhile</a><code>obs.takeWhile(predicate)</code><br/>Emits values from original observable until given <b>predicate</b>
function applied to a value returns false.
Ends when <b>predicate</b> returns false.
</p><pre title="example">var source = Kefir.sequentially(100, [1, 2, 3]);
var result = source.takeWhile(function(x) {  return x &lt; 3  });
result.log();
</pre><pre title="console output">&gt; [sequentially.takeWhile] &lt;value&gt; 1
&gt; [sequentially.takeWhile] &lt;value&gt; 2
&gt; [sequentially.takeWhile] &lt;end&gt;
</pre><pre title="events in time">source: ---1---2---3X
result: ---1---2---X</pre><div></div><p>See also <a href="#take-while-by">takeWhileBy</a>.

</p><p id="skip"><a href="#skip" class="header">skip</a><code>obs.skip(n)</code><br/>Skips first <b>n</b> values from original observable, then emits all rest.
</p><pre title="example">var source = Kefir.sequentially(100, [1, 2, 3]);
var result = source.skip(2);
result.log();
</pre><pre title="console output">&gt; [sequentially.skip] &lt;value&gt; 3
&gt; [sequentially.skip] &lt;end&gt;
</pre><pre title="events in time">source: ---1---2---3X
result: -----------3X</pre><div></div><p id="skip-while"><a href="#skip-while" class="header">skipWhile</a><code>obs.skipWhile(predicate)</code><br/>Skips values from original observable until given <b>predicate</b>
function applied to a value returns false,
then stops applying <b>predicate</b> to values and emits all of them.
</p><pre title="example">var source = Kefir.sequentially(100, [1, 3, 2]);
var result = source.skipWhile(function(x) {  return x &lt; 3  });
result.log();
</pre><pre title="console output">&gt; [sequentially.skipWhile] &lt;value&gt; 3
&gt; [sequentially.skipWhile] &lt;value&gt; 2
&gt; [sequentially.skipWhile] &lt;end&gt;
</pre><pre title="events in time">source: ---1---3---2X
result: -------3---2X</pre><div></div><p>See also <a href="#skip-while-by">skipWhileBy</a>.


</p><p id="skip-duplicates"><a href="#skip-duplicates" class="header">skipDuplicates</a><code>obs.skipDuplicates([comparator])</code><br/>Skips duplicate values using <tt>===</tt> for comparison by default.
Accepts optional <b>comparator</b> function,
that, if provided, is used for comparison instead of <tt>===</tt>.
</p><pre title="example">var source = Kefir.sequentially(100, [1, 2, 2, 3, 1]);
var result = source.skipDuplicates();
result.log();
</pre><pre title="console output">&gt; [sequentially.skipDuplicates] &lt;value&gt; 1
&gt; [sequentially.skipDuplicates] &lt;value&gt; 2
&gt; [sequentially.skipDuplicates] &lt;value&gt; 3
&gt; [sequentially.skipDuplicates] &lt;value&gt; 1
&gt; [sequentially.skipDuplicates] &lt;end&gt;
</pre><pre title="events in time">source: ---1---2---2---3---1X
result: ---1---2-------3---1X</pre><div></div><p>With custom <b>comparator</b> function:</p><pre title="example">var source = Kefir.sequentially(100, [1, 2, 2.1, 3, 1]);
var result = source.skipDuplicates(function(a, b) {
  return Math.round(a) === Math.round(b);
});
result.log();
</pre><pre title="console output">&gt; [sequentially.skipDuplicates] &lt;value&gt; 1
&gt; [sequentially.skipDuplicates] &lt;value&gt; 2
&gt; [sequentially.skipDuplicates] &lt;value&gt; 3
&gt; [sequentially.skipDuplicates] &lt;value&gt; 1
&gt; [sequentially.skipDuplicates] &lt;end&gt;
</pre><pre title="events in time">source: ---1---2---(2.1)---3---1X
result: ---1---2-----------3---1X</pre><div></div><p id="diff"><a href="#diff" class="header">diff</a><code>obs.diff([fn], [seed])</code><br/>On each value from original observable calls <b>fn</b>
function with previous and current value as arguments.
At first time calls <b>fn</b> with <b>seed</b> and current value.
Emits whatever <b>fn</b> returns.
</p><p>If no <b>seed</b> provided the first value will be used as a seed,
and result observable won't emit on first value.
</p><p>If you want to omit <b>fn</b> place <tt>null</tt> in its place.
If no <b>fn</b> function provided,
<tt>function(a, b) {return [a, b]}</tt> will be used as default.
</p><pre title="example">var source = Kefir.sequentially(100, [1, 2, 2, 3]);
var result = source.diff(function(prev, next) {
  return next - prev;
}, 0);
result.log();
</pre><pre title="console output">&gt; [sequentially.diff] &lt;value&gt; 1
&gt; [sequentially.diff] &lt;value&gt; 1
&gt; [sequentially.diff] &lt;value&gt; 0
&gt; [sequentially.diff] &lt;value&gt; 1
&gt; [sequentially.diff] &lt;end&gt;
</pre><pre title="events in time">source: ---1---2---2---3X
result: ---1---1---0---1X</pre><div></div><p id="scan"><a href="#scan" class="header">scan</a><code>obs.scan(fn, [seed])</code><br/>On each value from original
observable calls <b>fn</b> function with
previous result returned by <b>fn</b> and
current value emitted by original observable.
At first time calls <b>fn</b> with <b>seed</b> and current value.
Emits whatever <b>fn</b> returns. Always creates a property.
</p><p>If no <b>seed</b> provided the first value will be used as a seed.
</p><pre title="example">var source = Kefir.sequentially(100, [1, 2, 2, 3]);
var result = source.scan(function(prev, next) {
  return next + prev;
}, 0);
result.log();
</pre><pre title="console output">&gt; [sequentially.scan] &lt;value:current&gt; 0
&gt; [sequentially.scan] &lt;value&gt; 1
&gt; [sequentially.scan] &lt;value&gt; 3
&gt; [sequentially.scan] &lt;value&gt; 5
&gt; [sequentially.scan] &lt;value&gt; 8
&gt; [sequentially.scan] &lt;end&gt;
</pre><pre title="events in time">source:  ---1---2---2---3X
result: 0---1---3---5---8X</pre><div></div><p id="reduce"><a href="#reduce" class="header">reduce</a><code>obs.reduce(fn, [seed])</code><br/>Similar to <b>.scan</b>, but emits only last result just before end.
</p><p>If no <b>seed</b> provided the first value will be used as a seed.
</p><pre title="example">var source = Kefir.sequentially(100, [1, 2, 2, 3]);
var result = source.reduce(function(prev, next) {
  return next + prev;
}, 0);
result.log();
</pre><pre title="console output">&gt; [sequentially.reduce] &lt;value&gt; 8
&gt; [sequentially.reduce] &lt;end&gt;
</pre><pre title="events in time">source:  ---1---2---2---3 X
result:  ----------------8X</pre><div></div><p id="sliding-window"><a href="#sliding-window" class="header">slidingWindow</a><code>obs.slidingWindow(max, [min])</code><br/>Will emit arrays containing the last <b>n</b> values from <b>obs</b> observable,
where <b>n</b> is between <b>max</b> and <b>min</b> arguments.
By default <b>min</b> equals <tt>0</tt>.
</p><pre title="example">var source = Kefir.sequentially(100, [1, 2, 3, 4, 5]);
var result = source.slidingWindow(3, 2)
result.log();
</pre><pre title="console output">&gt; [sequentially.slidingWindow] &lt;value&gt; [1, 2]
&gt; [sequentially.slidingWindow] &lt;value&gt; [1, 2, 3]
&gt; [sequentially.slidingWindow] &lt;value&gt; [2, 3, 4]
&gt; [sequentially.slidingWindow] &lt;value&gt; [3, 4, 5]
&gt; [sequentially.slidingWindow] &lt;end&gt;
</pre><pre title="events in time">source:  ---1---(   2  )---(    3    )---(    4    )---(    5    )X
result:  -------([1, 2])---([1, 2, 3])---([2, 3, 4])---([3, 4, 5])X</pre><div></div><p id="delay"><a href="#delay" class="header">delay</a><code>obs.delay(wait)</code><br/>Delays all events by <b>wait</b> milliseconds,
with exception for current value of property,
or current end for already ended observable.
</p><pre title="example">var source = Kefir.sequentially(200, [1, 2, 3]);
var result = source.delay(100);
result.log();

</pre><pre title="console output">&gt; [sequentially.delay] &lt;value&gt; 1
&gt; [sequentially.delay] &lt;value&gt; 2
&gt; [sequentially.delay] &lt;value&gt; 3
&gt; [sequentially.delay] &lt;end&gt;
</pre><pre title="events in time">source:  -----1-----2-----3X
result:  --------1-----2-----3X</pre><div></div><p id="throttle"><a href="#throttle" class="header">throttle</a><code>obs.throttle(wait, [options])</code><br/>Return new throttled version of <b>obs</b> observable, which will emit values
only at most once per every <b>wait</b> milliseconds.
If used on a property current value will always pass intact without any delay.
</p><p>Accepts optional <b>options</b> object similar to
<a href="http://underscorejs.org/#throttle" target="_blank">underscore.throttle</a>.
By default, will emit event as soon as it comes for the first time, and,
if any new events will come during the wait period,
will emit last of them as soon as that period is over.
If you'd like to disable the leading-edge emit,
pass <tt>{leading: false}</tt>, and if you'd like to disable the emit
on the trailing-edge, pass <tt>{trailing: false}</tt>.
</p><pre title="example">var source = Kefir.sequentially(750, [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]);
var result = stream.throttle(2500);
result.log();
</pre><pre title="console output">&gt; [sequentially.throttle] &lt;value&gt; 1
&gt; [sequentially.throttle] &lt;value&gt; 4
&gt; [sequentially.throttle] &lt;value&gt; 7
&gt; [sequentially.throttle] &lt;value&gt; 0
&gt; [sequentially.throttle] &lt;end&gt;</pre><div></div><pre title="events in time">source:  --1--2--3--4--5--6--7--8--9--0X
result:  --1---------4---------7---------0X</pre><div></div><p id="debounce"><a href="#debounce" class="header">debounce</a><code>obs.debounce(wait, [options])</code><br/>Creates new debounced version of <b>obs</b> observable.
Will emit a value only after <b>wait</b> milliseconds period of no events.
Pass <tt>{immediate: true}</tt> as an <b>options</b> object to cause
observable to emit value on leading instead of the
trailing edge of the <b>wait</b> interval.
If used on a property current value will always pass intact without any delay.
</p><pre title="example">var source = Kefir.sequentially(100, [1, 2, 3, 0, 0, 0, 4, 5, 6]);
source = source.filter(function(x) {return x &gt; 0});
var result = source.debounce(250);
result.log();
</pre><pre title="console output">&gt; [sequentially.filter.debounce] &lt;value&gt; 3
&gt; [sequentially.filter.debounce] &lt;value&gt; 6
&gt; [sequentially.filter.debounce] &lt;end&gt;</pre><div></div><pre title="events in time">source:  ---1---2---3---------------4---5---6X
result:  ----------------------3---------------------6X</pre><div></div><p id="flatten"><a href="#flatten" class="header">flatten</a><code>obs.flatten([transformer])</code><br/>For this method it's expected that <b>obs</b> observable emits arrays.
The result observable (that <b>flatten</b> returns) will emit each element of those arrays.
</p><pre title="example">var source = Kefir.sequentially(100, [[1], [], [2,3]]);
var result = source.flatten();
result.log();
</pre><pre title="console output">&gt; [sequentially.flatten] &lt;value&gt; 1
&gt; [sequentially.flatten] &lt;value&gt; 2
&gt; [sequentially.flatten] &lt;value&gt; 3
&gt; [sequentially.flatten] &lt;end&gt;
</pre><pre title="events in time">source:  ---([1])---([])---([2, 3])X
result:  ---( 1 )----------(2 )(3 )X</pre><div></div><p>You can also provide the <b>transformer</b> function
which will be applied to each value from <b>obs</b> observable,
and supposed to return an array. This makes <b>flatten</b>
pretty powerful transformation method.
It allows you to do three kind
of transformation on each value: change value (like map), skip value (like filter),
and respond with several values to single value.
If you want to skip a value, return an empty array. If you want to change value,
return array with single new value. And if you want to respond with several values,
return them in array.
</p><pre title="example">var source = Kefir.sequentially(100, [1, 2, 3, 4]);
var result = source.flatten(function(x) {
  if (x % 2 === 0) {
    return [x * 10];
  } else {
    return [];
  }
});
result.log();
</pre><pre title="console output">&gt; [sequentially.flatten] &lt;value&gt; 20
&gt; [sequentially.flatten] &lt;value&gt; 40
&gt; [sequentially.flatten] &lt;end&gt;
</pre><pre title="events in time">source:  ---1---(2 )---3---(4 )X
result:  -------(20)-------(40)X</pre><div></div><p>See also <a href="#flat-map">flatMap</a>





</p><p id="transduce"><a href="#transduce" class="header">transduce</a><code>obs.transduce(transducer)</code><br/>This method allows you to use transducers in Kefir.
It supports any transducers implementation that follows
<a href="https://github.com/cognitect-labs/transducers-js#the-transducer-protocol">the transducer protocol</a>, for example
<a href="https://github.com/cognitect-labs/transducers-js">cognitect-labs/transducers-js</a> or
<a href="https://github.com/jlongster/transducers.js">jlongster/transducers.js</a>.
To learn more about transducers please visit those libraries pages.
</p><p>Here is an example with <a href="https://github.com/cognitect-labs/transducers-js">cognitect-labs/transducers-js</a>:
</p><pre title="example">var t = transducers;
var source = Kefir.sequentially(100, [1, 2, 3, 4, 5, 6]);
var result = source.transduce(t.comp(
  t.map(function(x) {return x + 10}),
  t.filter(function(x) {return x % 2 === 0}),
  t.take(2)
));
result.log();
</pre><pre title="console output">&gt; [sequentially.transduce] &lt;value&gt; 12
&gt; [sequentially.transduce] &lt;value&gt; 14
&gt; [sequentially.transduce] &lt;end&gt;
</pre><pre title="events in time">source:  ---1---(2 )---3---(4 )---5---6X
result:  -------(12)-------(14)X</pre><div></div><p id="with-handler"><a href="#with-handler" class="header">withHandler</a><code>obs.withHandler(handler)</code><br/>The most general transformation method. All other transformation methods above
can be implemented via <b>withHandler</b>.
Will call <b>handler</b> function on each event from <b>obs</b> observable
passing to it two arguments: an <a href="#emitter-object">emitter object</a>,
and an event object (with same format as in <a href="#on-any">.onAny</a> callback).
</p><p>By default will not emit any values, and will not end when <b>obs</b>
observable ends. Instead you should implement desired behaviour in
<b>handler</b> function, i.e. analyse <b>event object</b> and call
<tt>emitter.emit()</tt> or <tt>emitter.end()</tt> if necessary. You can call
<b>emitter</b> methods several times in each <b>handler</b> execution,
and you can also call them at any time later, for example to implement
<a href="#delay">.delay()</a>.
</p><pre title="example">var source = Kefir.sequentially(100, [0, 1, 2, 3]);
var result = source.withHandler(function(emitter, event) {
  if (event.type === &#x27;end&#x27;) {
    emitter.emit(&#x27;bye&#x27;);
    emitter.end();
  }
  if (event.type === &#x27;value&#x27;) {
    for (var i = 0; i &lt; event.value; i++) {
      emitter.emit(event.value);
    }
  }
});
result.log();
</pre><pre title="console output">&gt; [sequentially.withHandler] &lt;value&gt; 1
&gt; [sequentially.withHandler] &lt;value&gt; 2
&gt; [sequentially.withHandler] &lt;value&gt; 2
&gt; [sequentially.withHandler] &lt;value&gt; 3
&gt; [sequentially.withHandler] &lt;value&gt; 3
&gt; [sequentially.withHandler] &lt;value&gt; 3
&gt; [sequentially.withHandler] &lt;value&gt; bye
&gt; [sequentially.withHandler] &lt;end&gt;</pre><div></div><pre title="events in time">source:  ---0---1---( 2  )---(   3   )(  X   )
result:  -------1---(2)(2)---(3)(3)(3)(bye)(X)</pre><div></div><h2 id="combine-observables">Combine observables</h2><p id="combine"><a href="#combine" class="header">combine</a><code>Kefir.combine(obss, [fn])</code><code class="alias">obs.combine(otherObs, [fn])</code>Returns a stream.
Combines two or more observables together. On each value from any of source
observables (<b>obss</b> array) emits combined value, generated by <b>fn</b>
function from latest values from each source observable. <b>Fn</b>
is called with latest values as arguments.
If no <b>fn</b> provided, it emits an array containing latest values.
</p><p>It emits a value only when all source observables have emitted at least once.
Ends when all source observables ends.
</p><p>You can also combine two observables by calling <tt>a.combine(b, fn)</tt> if you like.
</p><pre title="example">var foo = Kefir.emitter();
var bar = Kefir.emitter();
var sum = Kefir.combine([foo, bar], function(f, b) {
  return f + b;
});
foo.log('foo');
bar.log('bar');
sum.log();

foo.emit(1);
bar.emit(2);
foo.emit(3);
bar.end();
foo.end();
</pre><pre title="console output">&gt; foo &lt;value&gt; 1
&gt; bar &lt;value&gt; 2
&gt; [combine] &lt;value&gt; 3
&gt; foo &lt;value&gt; 3
&gt; [combine] &lt;value&gt; 5
&gt; bar &lt;end&gt;
&gt; foo &lt;end&gt;
&gt; [combine] &lt;end&gt;
</pre><pre title="events in time">foo:  --1-----3-----X
bar:  -----2-----X

sum:  -----3--5-----X</pre><div></div><p id="and"><a href="#and" class="header">and</a><code>Kefir.and(obss)</code><code class="alias">obs.and(otherObs)</code>Combines <b>obss</b> observables using <tt>&amp;&amp;</tt> (logical and) operator.
</p><pre title="example">var a = Kefir.emitter();
var b = Kefir.emitter();
var c = Kefir.emitter();
var isAllTrue = Kefir.and([a, b, c]);
isAllTrue.log();

a.emit(true);
b.emit(false);
c.emit(true);
b.emit(true);
a.emit(false);
</pre><pre title="console output">&gt; [and] &lt;value&gt; false
&gt; [and] &lt;value&gt; true
&gt; [and] &lt;value&gt; false
</pre><pre title="events in time">a:          --t-----------f--
b:          -----f-----t-----
c:          --------t--------

isAllTrue:  --------f--t--f--</pre><div></div><p id="or"><a href="#or" class="header">or</a><code>Kefir.or(obss)</code><code class="alias">obs.or(otherObs)</code>Combines <b>obss</b> observables using <tt>||</tt> (logical or) operator.
</p><pre title="example">var a = Kefir.emitter();
var b = Kefir.emitter();
var c = Kefir.emitter();
var isAnyTrue = Kefir.or([a, b, c]);
isAnyTrue.log();

a.emit(true);
b.emit(false);
c.emit(true);
b.emit(true);
a.emit(false);
</pre><pre title="console output">&gt; [or] &lt;value&gt; true
&gt; [or] &lt;value&gt; true
&gt; [or] &lt;value&gt; true
</pre><pre title="events in time">a:          --t-----------f--
b:          -----f-----t-----
c:          --------t--------

isAnyTrue:  --------t--t--t--</pre><div></div><p id="sampled-by"><a href="#sampled-by" class="header">sampledBy</a><code>Kefir.sampledBy(passiveObss, activeObss, [fn])</code><code class="alias">obs.sampledBy(otherObs, [fn])</code>Like <a href="#combine">combine</a>, but instead of one array of source
observables it accepts two — <b>passiveObss</b> and <b>activeObss</b>,
then works just like <b>combine</b> except emits values only on values
from <b>activeObss</b>. But in <b>fn</b>
function you have values from both <b>passiveObss</b> and <b>activeObss</b>.
</p><p>If no <b>fn</b> provided emits an array of latest values, just like <b>combine</b>.
Actually <b>combine</b> is a <b>sampledBy</b> with empty array as <b>passiveObss</b>,
and all source observables as <b>activeObss</b>.
</p><p>Ends when all of <b>activeObss</b> ends.
</p><pre title="example">var a = Kefir.repeatedly(100, [0, 1, 2]);
var b = Kefir.repeatedly(100, [0, 1, 2]).delay(20);
var c = Kefir.sequentially(100, [0, 1, 2]).delay(40);
var d = Kefir.sequentially(100, [0, 1, 2]).delay(60);
var sum = Kefir.sampledBy([a, b], [c, d], function(_a, _b, _c, _d) {
  return _a + _b + _c + _d;
});
sum.log();
</pre><pre title="console output">&gt; [sampledBy] &lt;value&gt; 0
&gt; [sampledBy] &lt;value&gt; 3
&gt; [sampledBy] &lt;value&gt; 4
&gt; [sampledBy] &lt;value&gt; 7
&gt; [sampledBy] &lt;value&gt; 8
&gt; [sampledBy] &lt;end&gt;
</pre><pre title="events in time">a:    ----------0---------1---------2---------0-----
b:    ------------0---------1---------2---------0---
c:    --------------0---------1---------2X
d:    ----------------0---------1---------2X

sum:  ----------------0-------3-4-------7-8X
</pre><p>As you can see on a graph, <b>sampledBy</b> emits only on events
from <b>active sources</b>, and only when it has at least one value from each source.
Also it not waits for <b>passive sources</b> to end, only for active.
</p><p>You can also sample one observable by another like this <tt>a.sampledBy(b, fn)</tt>,
it is an equivalent of <tt>Kefir.sampledBy([a], [b], fn)</tt>.

</p><p id="merge"><a href="#merge" class="header">merge</a><code>Kefir.merge(obss)</code><code class="alias">obs.merge(otherObs)</code>Merges several <b>obss</b> observables into single stream,
i.e. simply repeats values from each source observable.
Ends when all <b>obss</b> observables ends.
</p><p>You can also merge two observables by calling <tt>a.merge(b)</tt>, if you like.
</p><pre title="example">var a = Kefir.sequentially(100, [0, 1, 2]);
var b = Kefir.sequentially(100, [0, 1, 2]).delay(30);
var c = Kefir.sequentially(100, [0, 1, 2]).delay(60);
var abc = Kefir.merge([a, b, c]);
abc.log();
</pre><pre title="console output">&gt; [merge] &lt;value&gt; 0
&gt; [merge] &lt;value&gt; 0
&gt; [merge] &lt;value&gt; 0
&gt; [merge] &lt;value&gt; 1
&gt; [merge] &lt;value&gt; 1
&gt; [merge] &lt;value&gt; 1
&gt; [merge] &lt;value&gt; 2
&gt; [merge] &lt;value&gt; 2
&gt; [merge] &lt;value&gt; 2
&gt; [merge] &lt;end&gt;
</pre><pre title="events in time">a:    ----------0---------1---------2X
b:    ------------0---------1---------2X
c:    --------------0---------1---------2X

abc:  ----------0-0-0-----1-1-1-----2-2-2X</pre><div></div><p id="concat"><a href="#concat" class="header">concat</a><code>Kefir.concat(obss)</code><code class="alias">obs.concat(otherObs)</code>Concatenates several <b>obss</b> observables into one stream. Like <a href="#merge">merge</a>,
but it starts emitting values from next source only after previous source ends,
ignoring any values from next sources before that.
</p><pre title="example">var a = Kefir.emitter();
var b = Kefir.emitter();
var c = Kefir.emitter();

var abc = Kefir.concat([a, b, c]);
abc.log();

a.emit(0).emit(1);
b.emit(0);
a.emit(2).end();
c.emit(0);
b.emit(1);
c.emit(1);
b.emit(2).end();
c.emit(2).end();
</pre><pre title="console output">&gt; [concat] &lt;value&gt; 0
&gt; [concat] &lt;value&gt; 1
&gt; [concat] &lt;value&gt; 2
&gt; [concat] &lt;value&gt; 1
&gt; [concat] &lt;value&gt; 2
&gt; [concat] &lt;value&gt; 2
&gt; [concat] &lt;end&gt;
</pre><pre title="events in time">a:    ---0---1---2X
b:    ---------0-----1---2X
c:    -------------0---1---2X

abc:  ---0---1---2---1---2-2X</pre><div></div><p id="pool"><a href="#pool" class="header">pool</a><code>Kefir.pool()</code><br/><b>Pool</b> is like <a href="#merge">merge</a> to which you
can dynamically add and remove sources.
When you create new <b>pool</b> it has no sources, then you can
add observables to it using <b>plug</b> method,
and remove using <b>unplug</b>. <b>Pool</b> never ends.
</p><pre title="example">var a = Kefir.emitter();
var b = Kefir.emitter();

var pool = Kefir.pool();
pool.log();

a.emit(1);
b.emit(1);
pool.plug(a);
a.emit(2);
b.emit(2);
pool.plug(b);
a.emit(3);
b.emit(3);
pool.unplug(a);
a.emit(4);
b.emit(4);
a.end();
b.end();
</pre><pre title="console output">&gt; [pool] &lt;value&gt; 2
&gt; [pool] &lt;value&gt; 3
&gt; [pool] &lt;value&gt; 3
&gt; [pool] &lt;value&gt; 4
</pre><pre title="events in time">a:       ---1-----2-----3----4-----X
b:       ----1------2------3----4---X

plug:    ------a------b------------------
unplug:  -------------------a------------

pool:    ---------2-----3--3----4--------
</pre><p>In this graph <b>plug</b> and <b>unplug</b> shown just to illustrate
moments when we plug and unplug sources, don't be confused that
there is some <b>plug</b> or <b>unplug</b> streams somewhere.


</p><p id="bus"><a href="#bus" class="header">bus</a><code>Kefir.bus()</code><br/><b>Bus</b> is a pool with <a href="#emitter">emitter</a> methods.
You can emit values from it directly. It is the best choice to expose
an input from a module, so module users could easily send events to your
module directly or by plugging an observable.
</p><pre title="example">var bus = Kefir.bus();
var emitter = Kefir.emitter();
bus.log();

bus.plug(emitter);
bus.emit(1);
emitter.emit(2);
bus.end();
</pre><pre title="console output">&gt; [bus] &lt;value&gt; 1
&gt; [bus] &lt;value&gt; 2
&gt; [bus] &lt;end&gt;</pre><div></div><p id="flat-map"><a href="#flat-map" class="header">flatMap</a><code>obs.flatMap([transform])</code><br/>Works similar to <a href="#flatten">flatten</a>,
but instead of array handles observables. Like in <b>flatten</b> you can
either provide a <b>transform</b> function which will return observables,
or you can use source <b>obs</b> observable that already emits observables.
</p><p><b>flatMap</b> ends when <b>obs</b> and all spawned observables ends.
</p><pre title="example">var source = Kefir.sequentially(100, [1, 2, 3]);
var result = source.flatMap(function(x) {
  return Kefir.interval(40, x).take(4);
});
result.log();
</pre><pre title="console output">&gt; [sequentially.flatMap] &lt;value&gt; 1
&gt; [sequentially.flatMap] &lt;value&gt; 1
&gt; [sequentially.flatMap] &lt;value&gt; 1
&gt; [sequentially.flatMap] &lt;value&gt; 2
&gt; [sequentially.flatMap] &lt;value&gt; 1
&gt; [sequentially.flatMap] &lt;value&gt; 2
&gt; [sequentially.flatMap] &lt;value&gt; 2
&gt; [sequentially.flatMap] &lt;value&gt; 3
&gt; [sequentially.flatMap] &lt;value&gt; 2
&gt; [sequentially.flatMap] &lt;value&gt; 3
&gt; [sequentially.flatMap] &lt;value&gt; 3
&gt; [sequentially.flatMap] &lt;value&gt; 3
&gt; [sequentially.flatMap] &lt;end&gt;
</pre><pre title="events in time">source:      ----------1---------2---------3X

spawned 1:             ---1---1---1---1X
spawned 2:                       ---2---2---2---2X
spawned 3:                                 ---3---3---3---3X

result:      -------------1---1---1-2-1-2---2-3-2-3---3---3X</pre><div></div><p id="flat-map-latest"><a href="#flat-map-latest" class="header">flatMapLatest</a><code>obs.flatMapLatest([fn])</code><br/>Like <b>flatMap</b>, but repeats events only from the latest added observable.
I.e. it switching from one observable to another.
</p><pre title="example">var source = Kefir.sequentially(100, [1, 2, 3]);
var result = source.flatMapLatest(function(x) {
  return Kefir.interval(40, x).take(4);
});
result.log();
</pre><pre title="console output">&gt; [sequentially.flatMapLatest] &lt;value&gt; 1
&gt; [sequentially.flatMapLatest] &lt;value&gt; 1
&gt; [sequentially.flatMapLatest] &lt;value&gt; 2
&gt; [sequentially.flatMapLatest] &lt;value&gt; 2
&gt; [sequentially.flatMapLatest] &lt;value&gt; 3
&gt; [sequentially.flatMapLatest] &lt;value&gt; 3
&gt; [sequentially.flatMapLatest] &lt;value&gt; 3
&gt; [sequentially.flatMapLatest] &lt;value&gt; 3
&gt; [sequentially.flatMapLatest] &lt;end&gt;
</pre><pre title="events in time">source:      ----------1---------2---------3X

spawned 1:             ---1---1---1---1X
spawned 2:                       ---2---2---2---2X
spawned 3:                                 ---3---3---3---3X

result:      -------------1---1-----2---2-----3---3---3---3X</pre><div></div><p id="flat-map-first"><a href="#flat-map-first" class="header">flatMapFirst</a><code>obs.flatMapFirst([fn])</code><br/>Like <b>flatMap</b>, but adds new observable only if previous one ended,
in other case it just ignoring new observable.
</p><pre title="example">var source = Kefir.sequentially(100, [1, 2, 3]);
var result = source.flatMapFirst(function(x) {
  return Kefir.interval(40, x).take(4);
});
result.log();
</pre><pre title="console output">&gt; [sequentially.flatMapFirst] &lt;value&gt; 1
&gt; [sequentially.flatMapFirst] &lt;value&gt; 1
&gt; [sequentially.flatMapFirst] &lt;value&gt; 1
&gt; [sequentially.flatMapFirst] &lt;value&gt; 1
&gt; [sequentially.flatMapFirst] &lt;value&gt; 3
&gt; [sequentially.flatMapFirst] &lt;value&gt; 3
&gt; [sequentially.flatMapFirst] &lt;value&gt; 3
&gt; [sequentially.flatMapFirst] &lt;value&gt; 3
&gt; [sequentially.flatMapFirst] &lt;end&gt;
</pre><pre title="events in time">source:      ----------1---------2---------3X

spawned 1:             ---1---1---1---1X
spawned 2:                       ---2---2---2---2X
spawned 3:                                 ---3---3---3---3X

result:      -------------1---1---1---1-------3---3---3---3X</pre><div></div><p id="flat-map-concat"><a href="#flat-map-concat" class="header">flatMapConcat</a><code>obs.flatMapConcat([fn])</code><br/>Like <b>flatMapFirst</b>, but instead of ignoring new observable
(if previous one still alive), <b>flatMapConcat</b> adds it to the queue.
Then, when current source ends, it takes oldest observable from the queue,
and switches to it.
</p><pre title="example">var source = Kefir.sequentially(100, [1, 2, 3]);
var result = source.flatMapConcat(function(x) {
  return Kefir.interval(40, x).take(4);
});
result.log();
</pre><pre title="console output">&gt; [sequentially.flatMapConcat] &lt;value&gt; 1
&gt; [sequentially.flatMapConcat] &lt;value&gt; 1
&gt; [sequentially.flatMapConcat] &lt;value&gt; 1
&gt; [sequentially.flatMapConcat] &lt;value&gt; 1
&gt; [sequentially.flatMapConcat] &lt;value&gt; 2
&gt; [sequentially.flatMapConcat] &lt;value&gt; 2
&gt; [sequentially.flatMapConcat] &lt;value&gt; 2
&gt; [sequentially.flatMapConcat] &lt;value&gt; 2
&gt; [sequentially.flatMapConcat] &lt;value&gt; 3
&gt; [sequentially.flatMapConcat] &lt;value&gt; 3
&gt; [sequentially.flatMapConcat] &lt;value&gt; 3
&gt; [sequentially.flatMapConcat] &lt;value&gt; 3
&gt; [sequentially.flatMapConcat] &lt;end&gt;
</pre><pre title="events in time">source:      ----------1---------2---------3X

spawned 1:             ---1---1---1---1X
spawned 2:                             ---2---2---2---2X
spawned 3:                                             ---3---3---3---3X

result:      -------------1---1---1---1---2---2---2---2---3---3---3---3X</pre><div></div><p id="flat-map-with-concurrency-limit"><a href="#flat-map-with-concurrency-limit" class="header">flatMapConcurLimit</a><code>obs.flatMapConcurLimit([fn], limit)</code><br/>Like <b>flatMapConcat</b>, but with configurable number of concurent sources, i.e. <b>flatMapConcat</b> is <tt>flatMapConcurLimit(fn, 1)</tt>.
</p><pre title="example">var source = Kefir.sequentially(100, [1, 2, 3]);
var result = source.flatMapConcurLimit(function(x) {
  return Kefir.interval(40, x).take(6);
}, 2);
result.log();
</pre><pre title="console output">&gt; [sequentially.flatMapConcurLimit] &lt;value&gt; 1
&gt; [sequentially.flatMapConcurLimit] &lt;value&gt; 1
&gt; [sequentially.flatMapConcurLimit] &lt;value&gt; 1
&gt; [sequentially.flatMapConcurLimit] &lt;value&gt; 2
&gt; [sequentially.flatMapConcurLimit] &lt;value&gt; 1
&gt; [sequentially.flatMapConcurLimit] &lt;value&gt; 2
&gt; [sequentially.flatMapConcurLimit] &lt;value&gt; 1
&gt; [sequentially.flatMapConcurLimit] &lt;value&gt; 2
&gt; [sequentially.flatMapConcurLimit] &lt;value&gt; 1
&gt; [sequentially.flatMapConcurLimit] &lt;value&gt; 2
&gt; [sequentially.flatMapConcurLimit] &lt;value&gt; 3
&gt; [sequentially.flatMapConcurLimit] &lt;value&gt; 2
&gt; [sequentially.flatMapConcurLimit] &lt;value&gt; 3
&gt; [sequentially.flatMapConcurLimit] &lt;value&gt; 2
&gt; [sequentially.flatMapConcurLimit] &lt;value&gt; 3
&gt; [sequentially.flatMapConcurLimit] &lt;value&gt; 3
&gt; [sequentially.flatMapConcurLimit] &lt;value&gt; 3
&gt; [sequentially.flatMapConcurLimit] &lt;value&gt; 3
&gt; [sequentially.flatMapConcurLimit] &lt;end&gt;
</pre><pre title="events in time">source:      ----------1---------2---------3X

spawned 1:             ---1---1---1---1---1---1X
spawned 2:                       ---2---2---2---2---2---2X
spawned 3:                                     ---3---3---3---3---3---3X

result:      -------------1---1---1-2-1-2-1-2-1-2-3-2-3-2-3---3---3---3X</pre><div></div><h2 id="combine-two">Combine two observables</h2><p>Just like in <a href="#modify">"Modify an observable"</a> section,
all methods in this section return observables of same kind as an original
observable (on which method was called). With one exception
for <a href="#awaiting">awaiting</a>, that always returns a property.
</p><p id="filter-by"><a href="#filter-by" class="header">filterBy</a><code>obs.filterBy(otherObs)</code><br/>Works like <a href="#filter">filter</a>, but instead of calling a predicate
on each value from <b>obs</b> observable, it checks last value from <b>otherObs</b>.
</p><pre title="example">var foo = Kefir.sequentially(100, [1, 2, 3, 4, 5, 6, 7, 8]);
var bar = Kefir.sequentially(200, [false, true, false]).delay(40).toProperty(true);
var result = foo.filterBy(bar);
result.log();
</pre><pre title="console output">&gt; [sequentially.filterBy] &lt;value&gt; 1
&gt; [sequentially.filterBy] &lt;value&gt; 2
&gt; [sequentially.filterBy] &lt;value&gt; 5
&gt; [sequentially.filterBy] &lt;value&gt; 6
&gt; [sequentially.filterBy] &lt;end&gt;
</pre><pre title="events in time">foo:     ----1----2----3----4----5----6----7----8X
bar:     t----------f---------t---------fX

result:  ----1----2--------------5----6----------X</pre><div></div><p id="take-while-by"><a href="#take-while-by" class="header">takeWhileBy</a><code>obs.takeWhileBy(otherObs)</code><br/>Works like <a href="#take-while">takeWhile</a>, but instead of using a
predicate function it uses another observable. It takes values from
<b>obs</b> observable until the first falsey value from <b>otherObs</b>.
</p><p><img data-emoji="point_up"> Note that it will not produce any value until
first value from <b>otherObs</b>, if that not what you need, just turn your
stream into property with current value <tt>true</tt>
by calling <tt>.toProperty(true)</tt>.
</p><pre title="example">var foo = Kefir.sequentially(100, [1, 2, 3, 4, 5, 6, 7, 8]);
var bar = Kefir.sequentially(200, [true, false, true]).delay(40).toProperty(true);
var result = foo.takeWhileBy(bar);
result.log();
</pre><pre title="console output">&gt; [sequentially.takeWhileBy] &lt;value&gt; 1
&gt; [sequentially.takeWhileBy] &lt;value&gt; 2
&gt; [sequentially.takeWhileBy] &lt;value&gt; 3
&gt; [sequentially.takeWhileBy] &lt;value&gt; 4
&gt; [sequentially.takeWhileBy] &lt;end&gt;
</pre><pre title="events in time">foo:     ----1----2----3----4----5----6----7----8X
bar:     t----------t---------f---------tX

result:  ----1----2----3----4-X</pre><div></div><p id="skip-while-by"><a href="#skip-while-by" class="header">skipWhileBy</a><code>obs.skipWhileBy(otherObs)</code><br/>Works like <a href="#skip-while">skipWhile</a>, but instead of using a
predicate function it uses another observable. It skips values from
<b>obs</b> observable until first falsey value from <b>otherObs</b>.
</p><pre title="example">var foo = Kefir.sequentially(100, [1, 2, 3, 4, 5, 6, 7, 8]);
var bar = Kefir.sequentially(200, [true, false, true]).delay(40);
var result = foo.skipWhileBy(bar);
result.log();
</pre><pre title="console output">&gt; [sequentially.skipWhileBy] &lt;value&gt; 1
&gt; [sequentially.skipWhileBy] &lt;value&gt; 2
&gt; [sequentially.skipWhileBy] &lt;value&gt; 3
&gt; [sequentially.skipWhileBy] &lt;value&gt; 4
&gt; [sequentially.skipWhileBy] &lt;end&gt;
</pre><pre title="events in time">foo:     ----1----2----3----4----5----6----7----8X
bar:     -----------t---------f---------tX

result:  ------------------------5----6----7----8X</pre><div></div><p id="skip-until-by"><a href="#skip-until-by" class="header">skipUntilBy</a><code>obs.skipUntilBy(otherObs)</code><br/>Similar to <a href="#skip-while-by">skipWhileBy</a>, but instead of
waiting for first falsey value from <b>otherObs</b>, it waits for just any value from it.
</p><pre title="example">var foo = Kefir.sequentially(100, [1, 2, 3, 4]);
var bar = Kefir.later(250, 0);
var result = foo.skipUntilBy(bar);
result.log();
</pre><pre title="console output">&gt; [sequentially.skipUntilBy] &lt;value&gt; 3
&gt; [sequentially.skipUntilBy] &lt;value&gt; 4
&gt; [sequentially.skipUntilBy] &lt;end&gt;
</pre><pre title="events in time">foo:     ----1----2----3----4X
bar:     -----------0X

result:  --------------3----4X</pre><div></div><p id="take-until-by"><a href="#take-until-by" class="header">takeUntilBy</a><code>obs.takeUntilBy(otherObs)</code><br/>Similar to <a href="#take-while-by">takeWhileBy</a>, but instead of
waiting for first falsey value from <b>otherObs</b>, it waits for just any value from it.
</p><pre title="example">var foo = Kefir.sequentially(100, [1, 2, 3, 4]);
var bar = Kefir.later(250, 0);
var result = foo.takeUntilBy(bar);
result.log();
</pre><pre title="console output">&gt; [sequentially.takeUntilBy] &lt;value&gt; 1
&gt; [sequentially.takeUntilBy] &lt;value&gt; 2
&gt; [sequentially.takeUntilBy] &lt;end&gt;
</pre><pre title="events in time">foo:     ----1----2----3----4X
bar:     -----------0X

result:  ----1----2-X</pre><div></div><p id="awaiting"><a href="#awaiting" class="header">awaiting</a><code>obs.awaiting(otherObs)</code><br/>Returns a property that represents the awaiting status of two observables,
i.e. answers the question «Has <b>obs</b> observable emitted a value
since the last value from <b>otherObs</b> observable has been emitted?».
</p><pre title="example">var foo = Kefir.sequentially(100, [1, 2, 3]);
var bar = Kefir.sequentially(100, [1, 2, 3]).delay(40);
var result = foo.awaiting(bar);
result.log();
</pre><pre title="console output">&gt; [sequentially.awaiting] &lt;value:current&gt; false
&gt; [sequentially.awaiting] &lt;value&gt; true
&gt; [sequentially.awaiting] &lt;value&gt; false
&gt; [sequentially.awaiting] &lt;value&gt; true
&gt; [sequentially.awaiting] &lt;value&gt; false
&gt; [sequentially.awaiting] &lt;value&gt; true
&gt; [sequentially.awaiting] &lt;value&gt; false
&gt; [sequentially.awaiting] &lt;end&gt;
</pre><pre title="events in time">foo:     ----1----2----3X
bar:     ------1----2----3X

result:  f---t-f--t-f--t-fX</pre><div></div><h2 id="active-state">Active state</h2><p>Each stream or property at any time may be in one of two states —
active or inactive. When observable in inactive state it not emits any
events, and not subscribes to it's original source.
Observables automatically became active when first listener added,
and became inactive when last listener removed.
</p><p>For example <tt>stream = $('.foo').asKefirStream('click')</tt> won't
immediately subscribe to <tt>'click'</tt> event on <tt>$('.foo')</tt>,
it will subscribe only when first listener will be added to
<tt>stream</tt>. And will automatically unsubscribe when last listener
will be removed from <tt>stream</tt>.
</p><pre>var stream = $(&#x27;.foo&#x27;).asKefirStream(&#x27;click&#x27;)
// at this moment event listener to .foo not added

stream.onValue(someFn);
// now &#x27;click&#x27; listener added to .foo

stream.offValue(someFn);
// and now it removed again
</pre><p>If one observable depends on another,
its active state propagates to its dependencies.
For example, in following code,
<b>mapA</b> will activate <b>A</b>,
<b>filterMapA</b> will activate <b>mapA</b> and <b>A</b>,
<b>mergeAB</b> will activate <b>A</b> and <b>B</b>.
</p><pre>var A = Kefir.emitter();
var B = Kefir.emitter();

var mapA = A.map(function(){ ... });
var filterMapA = mapA.filter(function(){ ... });
var mergeAB = Kefir.merge(A, B);
</pre><p><img data-emoji="point_up"> Note that current value of a
property won't update when property is inactive.
For example, we convert an <b>emitter</b> to property,
then emit some values via <b>emitter</b>,
while property has no subscribers (i.e. inactive).
In this case property won't get those values and
won't update its current value.
</p><pre>var emitter = Kefir.emitter();
var property = emitter.toProperty(0);

// 1 and 2 won&#x27;t become property current value
emitter.emit(1);
emitter.emit(2);

// now we activate property by subscribing to it,
// and also check current value
property.onValue(function(x) {  console.log(x)  }) // =&gt; 0

// those values will become property current
emitter.emit(3);
emitter.emit(4);

property.onValue(function(x) {  console.log(x)  }) // =&gt; 4
</pre><p>In fact active state is just a convention that strictly
followed in Kefir code, for better performance.
But you free to not follow it in your custom plugins or combinators.
For example you can create your own jQuery <tt>.asKefirStream()</tt>
plugin using <b>emitter</b> and always subscribe to DOM event, even when
stream has no subscribers. Or you can create your own <tt>.map()</tt>
combinator that always keeps subscription to its source observable
(i.e keeps it in active state).</p><h2 id="callbacks">About callbacks</h2><p>In Kefir wherever you pass functions as arguments, you can as well pass
an array containing <b>this context</b> and <b>additional arguments</b>
with which function will be called.
</p><p>It works everywhere in Kefir where function passes as argument,
for example in <tt>.map(fn)</tt>, <tt>.filter(fn)</tt>,
<tt>.fromPoll(wait, fn)</tt> — everywhere.
</p><p>All following code snippets are equivalent.
</p><pre>someStream.onValue(function(x) {
  someObj.someMethod(1, 2, x);
});
</pre><pre title="equivalent to above">someStream.onValue([someObj.someMethod, someObj, 1, 2]);
</pre><pre title="equivalent to above">someStream.onValue([&#x27;someMethod&#x27;, someObj, 1, 2]);
</pre><pre title="also equivalent but slower and consumes more memory than all above">&nbsp;
someStream.onValue(someObj.someMethod.bind(someObj, 1, 2));
</pre><p>You can pass method name as a string instead
of method itself in first position of array.
Here some real world example where it can be useful:
</p><pre>isVisibleProperty.onValue(function(x) {
  $(&#x27;.foo&#x27;).toggleClass(&#x27;is-visible&#x27;, x);
});
</pre><pre title="equivalent to above">isVisibleProperty.onValue([&#x27;toggleClass&#x27;, $(&#x27;.foo&#x27;), &#x27;is-visible&#x27;]);
</pre><p>If you don't need aditional arguments, but only <tt>this</tt> context,
just don't add them to array: <tt>[foo.bar, foo]</tt>.
And if you don't need context, pass <tt>null</tt>
in its place: <tt>[foo, null, 1, 2, 3]</tt>.
</p><p><img data-emoji="point_up"> In order to unsubscribe from observable,
you must call <tt>.offValue(fn)</tt> or <tt>.offEnd(fn)</tt>
with exact same array with which you called
<tt>.onValue(fn)</tt> or <tt>.onEnd(fn)</tt>.
</p><pre title="unsubscribe example">someStream.onValue([&#x27;someMethod&#x27;, someObj, 1, 2]);
someStream.offValue([&#x27;someMethod&#x27;, someObj, 1, 2]);</pre><h2 id="emitter-object">Emitter object</h2><p>Emitter object is an object, that has two methods <b>emit</b> and <b>end</b>.
It is used in several places in Kefir as a proxy to emit events to some stream.
</p><p><b>emiter.emit</b> accepts one argument (any value).<br>
<b>emiter.end</b> accepts no arguments.<br>
</p><pre>emitter.emit(123)
emitter.end()</pre><div></div><p>Do not confuse <b>emitter object</b> with <a href="#emitter">emitter stream</a>.
They both have <b>emit</b> and <b>end</b> methods,
but <b>emitter object</b> isn't actually a stream,
it has no stream methods or functionality.
Emitter object has only two methods <b>emit</b> and <b>end</b>, that's it.
</p><p>All <b>emitter object</b> methods are bound to its context,
and can be passed safely as callbacks without binding (see example).
</p><pre>// instead of this
$(&#x27;.foo&#x27;).on(&#x27;click&#x27;, emitter.emit.bind(emitter))

// you can do just this
$(&#x27;.foo&#x27;).on(&#x27;click&#x27;, emitter.emit)</pre><div></div></div><script src="bower-packages/jquery/jquery.js"></script><script src="bower-packages/transducers-js/transducers.js"></script><script src="dist/kefir.js"></script><script src="dist/addons/kefir-jquery.js"></script><script>$.getJSON('https://api.github.com/emojis', function(emojis){
  $('[data-emoji]').each(function(){
    var name = $(this).data('emoji');
    $(this).attr({
      src: emojis[name],
      title: ':' + name + ':',
      alt: ':' + name + ':'
    });
  });
});

var $window = $(window);
var $document = $(document);
var scrollLeft = $window.asKefirProperty('scroll', function() {
  return $window.scrollLeft();
});
var winWidth = $window.asKefirProperty('resize', function() {
  return $window.width();
});
var docWidth = $window.asKefirProperty('resize', function() {
  return $document.width();
});
Kefir.combine([scrollLeft, winWidth, docWidth], function(scrollLeft, winWidth, docWidth) {
  return -Math.min(docWidth - winWidth, Math.max(0, scrollLeft));
}).skipDuplicates().onValue(['css', $('.sidebar'), 'left']);
</script><!-- Yandex.Metrika counter --><script type="text/javascript">(function (d, w, c) { (w[c] = w[c] || []).push(function() { try { w.yaCounter26158662 = new Ya.Metrika({id:26158662}); } catch(e) { } }); var n = d.getElementsByTagName("script")[0], s = d.createElement("script"), f = function () { n.parentNode.insertBefore(s, n); }; s.type = "text/javascript"; s.async = true; s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js"; if (w.opera == "[object Opera]") { d.addEventListener("DOMContentLoaded", f, false); } else { f(); } })(document, window, "yandex_metrika_callbacks");</script><noscript><div><img src="//mc.yandex.ru/watch/26158662" style="position:absolute; left:-9999px;" alt="" /></div></noscript><!-- /Yandex.Metrika counter --></body></html>