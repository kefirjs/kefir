h2#combine-observables Combine observables



+descr-method('combine', 'combine', 'Kefir.combine(obss, [fn])', 'obs.combine(otherObs, [fn])').
  Returns a stream.
  Combines two or more observables together. On each value from any of source
  observables (<b>obss</b> array) emits combined value, generated by <b>fn</b>
  function from latest values from each source observable. <b>Fn</b>
  is called with latest values as arguments.
  If no <b>fn</b> provided, it emits an array containing latest values.

p.
  It emits a value only when all source observables have emitted at least once.
  Ends when all source observables ends.

p.
  You can also combine two observables by calling <tt>a.combine(b, fn)</tt> if you like.

pre(title='example').
  var foo = Kefir.emitter();
  var bar = Kefir.emitter();
  var sum = Kefir.combine([foo, bar], function(f, b) {
    return f + b;
  });
  foo.log('foo');
  bar.log('bar');
  sum.log();

  foo.emit(1);
  bar.emit(2);
  foo.emit(3);
  bar.end();
  foo.end();

pre(title='console output')
  :escapehtml
    > foo <value> 1
    > bar <value> 2
    > [combine] <value> 3
    > foo <value> 3
    > [combine] <value> 5
    > bar <end>
    > foo <end>
    > [combine] <end>

pre(title='events in time').
  foo:  --1-----3-----X
  bar:  -----2-----X

  sum:  -----3--5-----X
div


+descr-method('and', 'and', 'Kefir.and(obss)', 'obs.and(otherObs)').
  Combines <b>obss</b> observables using <tt>&amp;&amp;</tt> (logical and) operator.

pre(title='example').
  var a = Kefir.emitter();
  var b = Kefir.emitter();
  var c = Kefir.emitter();
  var isAllTrue = Kefir.and([a, b, c]);
  isAllTrue.log();

  a.emit(true);
  b.emit(false);
  c.emit(true);
  b.emit(true);
  a.emit(false);

pre(title='console output')
  :escapehtml
    > [and] <value> false
    > [and] <value> true
    > [and] <value> false

pre(title='events in time').
  a:          --t-----------f--
  b:          -----f-----t-----
  c:          --------t--------

  isAllTrue:  --------f--t--f--
div

p.
  See also #[a(href="#not") not].


+descr-method('or', 'or', 'Kefir.or(obss)', 'obs.or(otherObs)').
  Combines <b>obss</b> observables using <tt>||</tt> (logical or) operator.

pre(title='example').
  var a = Kefir.emitter();
  var b = Kefir.emitter();
  var c = Kefir.emitter();
  var isAnyTrue = Kefir.or([a, b, c]);
  isAnyTrue.log();

  a.emit(true);
  b.emit(false);
  c.emit(true);
  b.emit(true);
  a.emit(false);

pre(title='console output')
  :escapehtml
    > [or] <value> true
    > [or] <value> true
    > [or] <value> true

pre(title='events in time').
  a:          --t-----------f--
  b:          -----f-----t-----
  c:          --------t--------

  isAnyTrue:  --------t--t--t--
div

p.
  See also #[a(href="#not") not].


+descr-method('sampled-by', 'sampledBy', 'Kefir.sampledBy(passiveObss, activeObss, [fn])', 'obs.sampledBy(otherObs, [fn])').
  Like <a href="#combine">combine</a>, but instead of one array of source
  observables it accepts two â€” <b>passiveObss</b> and <b>activeObss</b>,
  then works just like <b>combine</b> except emits values only on values
  from <b>activeObss</b>. But in <b>fn</b>
  function you have values from both <b>passiveObss</b> and <b>activeObss</b>.

p.
  If no <b>fn</b> provided emits an array of latest values, just like <b>combine</b>.
  Actually <b>combine</b> is a <b>sampledBy</b> with empty array as <b>passiveObss</b>,
  and all source observables as <b>activeObss</b>.

p.
  Ends when all of <b>activeObss</b> ends.

pre(title='example').
  var a = Kefir.repeatedly(100, [0, 1, 2]);
  var b = Kefir.repeatedly(100, [0, 1, 2]).delay(20);
  var c = Kefir.sequentially(100, [0, 1, 2]).delay(40);
  var d = Kefir.sequentially(100, [0, 1, 2]).delay(60);
  var sum = Kefir.sampledBy([a, b], [c, d], function(_a, _b, _c, _d) {
    return _a + _b + _c + _d;
  });
  sum.log();

pre(title='console output')
  :escapehtml
    > [sampledBy] <value> 0
    > [sampledBy] <value> 3
    > [sampledBy] <value> 4
    > [sampledBy] <value> 7
    > [sampledBy] <value> 8
    > [sampledBy] <end>

pre(title='events in time').
  a:    ----------0---------1---------2---------0-----
  b:    ------------0---------1---------2---------0---
  c:    --------------0---------1---------2X
  d:    ----------------0---------1---------2X

  sum:  ----------------0-------3-4-------7-8X

p.
  As you can see on a graph, <b>sampledBy</b> emits only on events
  from <b>active sources</b>, and only when it has at least one value from each source.
  Also it not waits for <b>passive sources</b> to end, only for active.

p.
  You can also sample one observable by another like this <tt>a.sampledBy(b, fn)</tt>,
  it is an equivalent of <tt>Kefir.sampledBy([a], [b], fn)</tt>.
  If you omit #[b fn], #[tt function(a, b) {return a}] will be used in
  <tt>a.sampledBy(b)</tt>.


+descr-method('merge', 'merge', 'Kefir.merge(obss)', 'obs.merge(otherObs)').
  Merges several <b>obss</b> observables into single stream,
  i.e. simply repeats values from each source observable.
  Ends when all <b>obss</b> observables ends.

p.
  You can also merge two observables by calling <tt>a.merge(b)</tt>, if you like.

pre(title='example').
  var a = Kefir.sequentially(100, [0, 1, 2]);
  var b = Kefir.sequentially(100, [0, 1, 2]).delay(30);
  var c = Kefir.sequentially(100, [0, 1, 2]).delay(60);
  var abc = Kefir.merge([a, b, c]);
  abc.log();

pre(title='console output')
  :escapehtml
    > [merge] <value> 0
    > [merge] <value> 0
    > [merge] <value> 0
    > [merge] <value> 1
    > [merge] <value> 1
    > [merge] <value> 1
    > [merge] <value> 2
    > [merge] <value> 2
    > [merge] <value> 2
    > [merge] <end>

pre(title='events in time').
  a:    ----------0---------1---------2X
  b:    ------------0---------1---------2X
  c:    --------------0---------1---------2X

  abc:  ----------0-0-0-----1-1-1-----2-2-2X
div


+descr-method('concat', 'concat', 'Kefir.concat(obss)', 'obs.concat(otherObs)').
  Concatenates several <b>obss</b> observables into one stream. Like <a href="#merge">merge</a>,
  but it starts emitting values from next source only after previous source ends,
  ignoring any values from next sources before that.

pre(title='example').
  var a = Kefir.emitter();
  var b = Kefir.emitter();
  var c = Kefir.emitter();

  var abc = Kefir.concat([a, b, c]);
  abc.log();

  a.emit(0).emit(1);
  b.emit(0);
  a.emit(2).end();
  c.emit(0);
  b.emit(1);
  c.emit(1);
  b.emit(2).end();
  c.emit(2).end();

pre(title='console output')
  :escapehtml
    > [concat] <value> 0
    > [concat] <value> 1
    > [concat] <value> 2
    > [concat] <value> 1
    > [concat] <value> 2
    > [concat] <value> 2
    > [concat] <end>

pre(title='events in time').
  a:    ---0---1---2X
  b:    ---------0-----1---2X
  c:    -------------0---1---2X

  abc:  ---0---1---2---1---2-2X
div



+descr-method('pool', 'pool', 'Kefir.pool()').
  <b>Pool</b> is like <a href="#merge">merge</a> to which you
  can dynamically add and remove sources.
  When you create new <b>pool</b> it has no sources, then you can
  add observables to it using <b>plug</b> method,
  and remove using <b>unplug</b>. <b>Pool</b> never ends.

pre(title='example').
  var a = Kefir.emitter();
  var b = Kefir.emitter();

  var pool = Kefir.pool();
  pool.log();

  a.emit(1);
  b.emit(1);
  pool.plug(a);
  a.emit(2);
  b.emit(2);
  pool.plug(b);
  a.emit(3);
  b.emit(3);
  pool.unplug(a);
  a.emit(4);
  b.emit(4);
  a.end();
  b.end();

pre(title='console output')
  :escapehtml
    > [pool] <value> 2
    > [pool] <value> 3
    > [pool] <value> 3
    > [pool] <value> 4

pre(title='events in time').
  a:       ---1-----2-----3----4-----X
  b:       ----1------2------3----4---X

  plug:    ------a------b------------------
  unplug:  -------------------a------------

  pool:    ---------2-----3--3----4--------

p.
  In this graph <b>plug</b> and <b>unplug</b> shown just to illustrate
  moments when we plug and unplug sources, don't be confused that
  there is some <b>plug</b> or <b>unplug</b> streams somewhere.



+descr-method('bus', 'bus', 'Kefir.bus()').
  <b>Bus</b> is a pool with <a href="#emitter">emitter</a> methods.
  You can emit values from it directly. It is the best choice to expose
  an input from a module, so module users could easily send events to your
  module directly or by plugging an observable.

pre(title='example').
  var bus = Kefir.bus();
  var emitter = Kefir.emitter();
  bus.log();

  bus.plug(emitter);
  bus.emit(1);
  emitter.emit(2);
  bus.end();

pre(title='console output')
  :escapehtml
    > [bus] <value> 1
    > [bus] <value> 2
    > [bus] <end>
div




+descr-method('flat-map', 'flatMap', 'obs.flatMap([transform])').
  Works similar to <a href="#flatten">flatten</a>,
  but instead of array handles observables. Like in <b>flatten</b> you can
  either provide a <b>transform</b> function which will return observables,
  or you can use source <b>obs</b> observable that already emits observables.

p.
  <b>flatMap</b> ends when <b>obs</b> and all spawned observables ends.

pre(title='example').
  var source = Kefir.sequentially(100, [1, 2, 3]);
  var result = source.flatMap(function(x) {
    return Kefir.interval(40, x).take(4);
  });
  result.log();

pre(title='console output')
  :escapehtml
    > [sequentially.flatMap] <value> 1
    > [sequentially.flatMap] <value> 1
    > [sequentially.flatMap] <value> 1
    > [sequentially.flatMap] <value> 2
    > [sequentially.flatMap] <value> 1
    > [sequentially.flatMap] <value> 2
    > [sequentially.flatMap] <value> 2
    > [sequentially.flatMap] <value> 3
    > [sequentially.flatMap] <value> 2
    > [sequentially.flatMap] <value> 3
    > [sequentially.flatMap] <value> 3
    > [sequentially.flatMap] <value> 3
    > [sequentially.flatMap] <end>

pre(title='events in time').
  source:      ----------1---------2---------3X

  spawned 1:             ---1---1---1---1X
  spawned 2:                       ---2---2---2---2X
  spawned 3:                                 ---3---3---3---3X

  result:      -------------1---1---1-2-1-2---2-3-2-3---3---3X
div




+descr-method('flat-map-latest', 'flatMapLatest', 'obs.flatMapLatest([fn])').
  Like <b>flatMap</b>, but repeats events only from the latest added observable.
  I.e. it switching from one observable to another.

pre(title='example').
  var source = Kefir.sequentially(100, [1, 2, 3]);
  var result = source.flatMapLatest(function(x) {
    return Kefir.interval(40, x).take(4);
  });
  result.log();

pre(title='console output')
  :escapehtml
    > [sequentially.flatMapLatest] <value> 1
    > [sequentially.flatMapLatest] <value> 1
    > [sequentially.flatMapLatest] <value> 2
    > [sequentially.flatMapLatest] <value> 2
    > [sequentially.flatMapLatest] <value> 3
    > [sequentially.flatMapLatest] <value> 3
    > [sequentially.flatMapLatest] <value> 3
    > [sequentially.flatMapLatest] <value> 3
    > [sequentially.flatMapLatest] <end>

pre(title='events in time').
  source:      ----------1---------2---------3X

  spawned 1:             ---1---1---1---1X
  spawned 2:                       ---2---2---2---2X
  spawned 3:                                 ---3---3---3---3X

  result:      -------------1---1-----2---2-----3---3---3---3X
div



+descr-method('flat-map-first', 'flatMapFirst', 'obs.flatMapFirst([fn])').
  Like <b>flatMap</b>, but adds new observable only if previous one ended,
  in other case it just ignoring new observable.

pre(title='example').
  var source = Kefir.sequentially(100, [1, 2, 3]);
  var result = source.flatMapFirst(function(x) {
    return Kefir.interval(40, x).take(4);
  });
  result.log();

pre(title='console output')
  :escapehtml
    > [sequentially.flatMapFirst] <value> 1
    > [sequentially.flatMapFirst] <value> 1
    > [sequentially.flatMapFirst] <value> 1
    > [sequentially.flatMapFirst] <value> 1
    > [sequentially.flatMapFirst] <value> 3
    > [sequentially.flatMapFirst] <value> 3
    > [sequentially.flatMapFirst] <value> 3
    > [sequentially.flatMapFirst] <value> 3
    > [sequentially.flatMapFirst] <end>

pre(title='events in time').
  source:      ----------1---------2---------3X

  spawned 1:             ---1---1---1---1X
  spawned 2:                       ---2---2---2---2X
  spawned 3:                                 ---3---3---3---3X

  result:      -------------1---1---1---1-------3---3---3---3X
div



+descr-method('flat-map-concat', 'flatMapConcat', 'obs.flatMapConcat([fn])').
  Like <b>flatMapFirst</b>, but instead of ignoring new observable
  (if previous one still alive), <b>flatMapConcat</b> adds it to the queue.
  Then, when current source ends, it takes oldest observable from the queue,
  and switches to it.

pre(title='example').
  var source = Kefir.sequentially(100, [1, 2, 3]);
  var result = source.flatMapConcat(function(x) {
    return Kefir.interval(40, x).take(4);
  });
  result.log();

pre(title='console output')
  :escapehtml
    > [sequentially.flatMapConcat] <value> 1
    > [sequentially.flatMapConcat] <value> 1
    > [sequentially.flatMapConcat] <value> 1
    > [sequentially.flatMapConcat] <value> 1
    > [sequentially.flatMapConcat] <value> 2
    > [sequentially.flatMapConcat] <value> 2
    > [sequentially.flatMapConcat] <value> 2
    > [sequentially.flatMapConcat] <value> 2
    > [sequentially.flatMapConcat] <value> 3
    > [sequentially.flatMapConcat] <value> 3
    > [sequentially.flatMapConcat] <value> 3
    > [sequentially.flatMapConcat] <value> 3
    > [sequentially.flatMapConcat] <end>

pre(title='events in time').
  source:      ----------1---------2---------3X

  spawned 1:             ---1---1---1---1X
  spawned 2:                             ---2---2---2---2X
  spawned 3:                                             ---3---3---3---3X

  result:      -------------1---1---1---1---2---2---2---2---3---3---3---3X
div



+descr-method('flat-map-with-concurrency-limit', 'flatMapConcurLimit', 'obs.flatMapConcurLimit([fn], limit)').
  Like <b>flatMapConcat</b>, but with configurable number of concurent sources, i.e. <b>flatMapConcat</b> is <tt>flatMapConcurLimit(fn, 1)</tt>.

pre(title='example').
  var source = Kefir.sequentially(100, [1, 2, 3]);
  var result = source.flatMapConcurLimit(function(x) {
    return Kefir.interval(40, x).take(6);
  }, 2);
  result.log();

pre(title='console output')
  :escapehtml
    > [sequentially.flatMapConcurLimit] <value> 1
    > [sequentially.flatMapConcurLimit] <value> 1
    > [sequentially.flatMapConcurLimit] <value> 1
    > [sequentially.flatMapConcurLimit] <value> 2
    > [sequentially.flatMapConcurLimit] <value> 1
    > [sequentially.flatMapConcurLimit] <value> 2
    > [sequentially.flatMapConcurLimit] <value> 1
    > [sequentially.flatMapConcurLimit] <value> 2
    > [sequentially.flatMapConcurLimit] <value> 1
    > [sequentially.flatMapConcurLimit] <value> 2
    > [sequentially.flatMapConcurLimit] <value> 3
    > [sequentially.flatMapConcurLimit] <value> 2
    > [sequentially.flatMapConcurLimit] <value> 3
    > [sequentially.flatMapConcurLimit] <value> 2
    > [sequentially.flatMapConcurLimit] <value> 3
    > [sequentially.flatMapConcurLimit] <value> 3
    > [sequentially.flatMapConcurLimit] <value> 3
    > [sequentially.flatMapConcurLimit] <value> 3
    > [sequentially.flatMapConcurLimit] <end>

pre(title='events in time').
  source:      ----------1---------2---------3X

  spawned 1:             ---1---1---1---1---1---1X
  spawned 2:                       ---2---2---2---2---2---2X
  spawned 3:                                     ---3---3---3---3---3---3X

  result:      -------------1---1---1-2-1-2-1-2-1-2-3-2-3-2-3---3---3---3X
div
