h2#modify Modify an observable

p.
  All methods in this section create a new observable of same kind* from an original one.
  New observable applies some transformation to each event from original
  and emits result of transformation.
  In most cases a transformation is applied only to <b>value events</b>,
  but <b>end event</b> just passes through (i.e. new observable ends when original ends).

p.
  <b>*</b> For example if original observable was a stream,
  then new one also will be a stream. Same for properties.
  This rule has one exception for <a href="#scan">scan method</a>,
  that always returns a property.


+descr-method('map', 'map', 'obs.map(fn)').
  Applies given <b>fn</b> function to each value from original observable
  and emits value returned by <b>fn</b>.

pre(title='example').
  var source = Kefir.sequentially(100, [1, 2, 3]);
  var result = source.map(function(x) {  return x + 1  });
  result.log();

pre(title='console output')
  :escapehtml
    > [sequentially.map] <value> 2
    > [sequentially.map] <value> 3
    > [sequentially.map] <value> 4
    > [sequentially.map] <end>
div


+descr-method('map-to', 'mapTo', 'obs.mapTo(value)', null, 'obs.map(function() {return value})').
  On each value from original observable emits given <b>value</b>.<br>

pre(title='example').
  var source = Kefir.sequentially(100, [1, 2, 3]);
  var result = source.mapTo(5);
  result.log();

pre(title='console output')
  :escapehtml
    > [sequentially.mapTo] <value> 5
    > [sequentially.mapTo] <value> 5
    > [sequentially.mapTo] <value> 5
    > [sequentially.mapTo] <end>
div


+descr-method('pluck', 'pluck', 'obs.pluck(propertyName)', null, 'obs.map(function(x) {return x.foo})').
  On each value from original observable emits <tt>value[propertyName]</tt>.<br>

pre(title='example').
  var source = Kefir.sequentially(100, [{num: 1}, {num: 2}, {num: 3}]);
  var result = source.pluck('num');
  result.log();

pre(title='console output')
  :escapehtml
    > [sequentially.pluck] <value> 1
    > [sequentially.pluck] <value> 2
    > [sequentially.pluck] <value> 3
    > [sequentially.pluck] <end>
div


+descr-method('invoke', 'invoke', 'obs.invoke(methodName)', null, 'obs.map(function(x) {return x.foo()})').
  Just like <b>.pluck</b>, but instead of emitting <tt>value[propertyName]</tt>
  it emits <tt>value[methodName]()</tt>,
  i.e. calls method <b>methodName</b> of each value object
  and emits whatever it returns.<br>

pre(title='example').
  var source = Kefir.sequentially(100, [
    {getNum: function(){return 1}},
    {getNum: function(){return 2}},
    {getNum: function(){return 3}}
  ]);
  var result = source.invoke('getNum');
  result.log();

pre(title='console output')
  :escapehtml
    > [sequentially.invoke] <value> 1
    > [sequentially.invoke] <value> 2
    > [sequentially.invoke] <value> 3
    > [sequentially.invoke] <end>
div



+descr-method('not', 'not', 'obs.not()', null, 'obs.map(function(x) {return !x})').
  Inverts every value from original observable using <tt>!</tt> operator.<br>

pre(title='example').
  var source = Kefir.sequentially(100, [true, false, true]);
  var result = source.not();
  result.log();

pre(title='console output')
  :escapehtml
    > [sequentially.not] <value> false
    > [sequentially.not] <value> true
    > [sequentially.not] <value> false
    > [sequentially.not] <end>
div


+descr-method('timestamp', 'timestamp', 'obs.timestamp()', null, 'obs.map(function(x) {return {value: x, time: new Date().getTime()}})').
  Wraps each value to object with timestamp of the event.

pre(title='example').
  var source = Kefir.sequentially(100, [1, 2, 3]);
  var result = source.timestamp();
  result.log();

pre(title='console output')
  :escapehtml
    > [sequentially.timestamp] <value> Object {value: 1, time: 1413022203878}
    > [sequentially.timestamp] <value> Object {value: 2, time: 1413022203980}
    > [sequentially.timestamp] <value> Object {value: 3, time: 1413022204081}
    > [sequentially.timestamp] <end>
div


+descr-method('tap', 'tap', 'obs.tap(fn)').
  Just like <b>.map</b> applies given <b>fn</b>
  function to each value from original observable, but emits original value
  (not what <b>fn</b> returns).

pre(title='example').
  var source = Kefir.sequentially(100, [1, 2, 3]);
  var result = source.tap(function(x) {
    console.log('from tap fn:', x);
    return 5; // will be ignored
  });
  result.log();

pre(title='console output')
  :escapehtml
    > from tap fn: 1
    > [sequentially.tap] <value> 1
    > from tap fn: 2
    > [sequentially.tap] <value> 2
    > from tap fn: 3
    > [sequentially.tap] <value> 3
    > [sequentially.tap] <end>
div


+descr-method('filter', 'filter', 'obs.filter(predicate)').
  Filters values from original observable
  using given <b>predicate</b> function.

pre(title='example')
  :escapehtml
    var source = Kefir.sequentially(100, [1, 2, 3]);
    var result = source.filter(function(x) {  return x > 1  });
    result.log();

pre(title='console output')
  :escapehtml
    > [sequentially.filter] <value> 2
    > [sequentially.filter] <value> 3
    > [sequentially.filter] <end>

p.
  See also <a href="#filter-by">filterBy</a>.


+descr-method('take', 'take', 'obs.take(n)').
  Emits first <b>n</b> values from original observable, then ends.

pre(title='example')
  :escapehtml
    var source = Kefir.sequentially(100, [1, 2, 3]);
    var result = source.take(2);
    result.log();

pre(title='console output')
  :escapehtml
    > [sequentially.take] <value> 1
    > [sequentially.take] <value> 2
    > [sequentially.take] <end>
div


+descr-method('take-while', 'takeWhile', 'obs.takeWhile(predicate)').
  Emits values from original observable until given <b>predicate</b>
  function applied to a value returns false.
  Ends when <b>predicate</b> returns false.

pre(title='example')
  :escapehtml
    var source = Kefir.sequentially(100, [1, 2, 3]);
    var result = source.takeWhile(function(x) {  return x < 3  });
    result.log();

pre(title='console output')
  :escapehtml
    > [sequentially.takeWhile] <value> 1
    > [sequentially.takeWhile] <value> 2
    > [sequentially.takeWhile] <end>
div


+descr-method('skip', 'skip', 'obs.skip(n)').
  Skips first <b>n</b> values from original observable, then emits all rest.

pre(title='example')
  :escapehtml
    var source = Kefir.sequentially(100, [1, 2, 3]);
    var result = source.skip(2);
    result.log();

pre(title='console output')
  :escapehtml
    > [sequentially.skip] <value> 3
    > [sequentially.skip] <end>
div


+descr-method('skip-while', 'skipWhile', 'obs.skipWhile(predicate)').
  Skips values from original observable until given <b>predicate</b>
  function applied to a value returns false,
  then stops applying <b>predicate</b> to values and emits all of them.

pre(title='example')
  :escapehtml
    var source = Kefir.sequentially(100, [1, 3, 2]);
    var result = source.skipWhile(function(x) {  return x < 3  });
    result.log();

pre(title='console output')
  :escapehtml
    > [sequentially.skipWhile] <value> 3
    > [sequentially.skipWhile] <value> 2
    > [sequentially.skipWhile] <end>
div


+descr-method('skip-duplicates', 'skipDuplicates', 'obs.skipDuplicates([comparator])').
  Skips duplicate values using <tt>===</tt> for comparison by default.
  Accepts optional <b>comparator</b> function,
  that, if provided, is used for comparison instead of <tt>===</tt>.

pre(title='example')
  :escapehtml
    var source = Kefir.sequentially(100, [1, 2, 2, 3, 1]);
    var result = source.skipDuplicates();
    result.log();

pre(title='console output')
  :escapehtml
    > [sequentially.skipDuplicates] <value> 1
    > [sequentially.skipDuplicates] <value> 2
    > [sequentially.skipDuplicates] <value> 3
    > [sequentially.skipDuplicates] <value> 1
    > [sequentially.skipDuplicates] <end>

p With custom <b>comparator</b> function:

pre(title='example')
  :escapehtml
    var source = Kefir.sequentially(100, [1, 2, 2.1, 3, 1]);
    var result = source.skipDuplicates(function(a, b) {
      return Math.round(a) === Math.round(b);
    });
    result.log();

pre(title='console output')
  :escapehtml
    > [sequentially.skipDuplicates] <value> 1
    > [sequentially.skipDuplicates] <value> 2
    > [sequentially.skipDuplicates] <value> 3
    > [sequentially.skipDuplicates] <value> 1
    > [sequentially.skipDuplicates] <end>
div


+descr-method('diff', 'diff', 'obs.diff(seed, fn)').
  On each value from original observable calls <b>fn</b>
  function with previous and current value as arguments.
  At first time calls <b>fn</b> with <b>seed</b> and current value.
  Emits whatever <b>fn</b> returns.

pre(title='example')
  :escapehtml
    var source = Kefir.sequentially(100, [1, 2, 2, 3]);
    var result = source.diff(0, function(prev, next) {
      return next - prev;
    });
    result.log();

pre(title='console output')
  :escapehtml
    > [sequentially.diff] <value> 1
    > [sequentially.diff] <value> 1
    > [sequentially.diff] <value> 0
    > [sequentially.diff] <value> 1
    > [sequentially.diff] <end>
div


+descr-method('scan', 'scan', 'obs.scan(seed, fn)').
  On each value from original
  observable calls <b>fn</b> function with
  previous result returned by <b>fn</b> and
  current value emitted by original observable.
  At first time calls <b>fn</b> with <b>seed</b> and current value.
  Emits whatever <b>fn</b> returns. Always creates a property.

pre(title='example')
  :escapehtml
    var source = Kefir.sequentially(100, [1, 2, 2, 3]);
    var result = source.scan(0, function(prev, next) {
      return next + prev;
    });
    result.log();

pre(title='console output')
  :escapehtml
    > [sequentially.scan] <value:current> 0
    > [sequentially.scan] <value> 1
    > [sequentially.scan] <value> 3
    > [sequentially.scan] <value> 5
    > [sequentially.scan] <value> 8
    > [sequentially.scan] <end>
div


+descr-method('reduce', 'reduce', 'obs.reduce(seed, fn)').
  Similar to <b>.scan</b>, but emits only last result just before end.

pre(title='example')
  :escapehtml
    var source = Kefir.sequentially(100, [1, 2, 2, 3]);
    var result = source.reduce(0, function(prev, next) {
      return next + prev;
    });
    result.log();

pre(title='console output')
  :escapehtml
    > [sequentially.reduce] <value> 8
    > [sequentially.reduce] <end>
div


+descr-method('delay', 'delay', 'obs.delay(wait)').
  Delays all events by <b>wait</b> milliseconds,
  with exception for current value of property,
  or current end for already ended observable.

pre(title='example')
  :escapehtml
    var emitter = Kefir.emitter();
    emitter.delay(100).map(function(originalEmitTime){
      return new Date() - originalEmitTime;
    }).log();
    emitter.emit(new Date());
    emitter.emit(new Date());
    emitter.end();

pre(title='console output')
  :escapehtml
    > [emitter.delay.map] <value> 100
    > [emitter.delay.map] <value> 100
    > [emitter.delay.map] <end>
div




+descr-method('throttle', 'throttle', 'obs.throttle(wait, [options])').
  Return new throttled version of <b>obs</b> observable, which will emit values
  only at most once per every <b>wait</b> milliseconds.
  If used on a property current value will always pass intact without any delay.

p.
  Accepts optional <b>options</b> object similar to
  <a href="http://underscorejs.org/#throttle" target="_blank">underscore.throttle</a>.
  By default, will emit event as soon as it comes for the first time, and,
  if any new events will come during the wait period,
  will emit last of them as soon as that period is over.
  If you'd like to disable the leading-edge emit,
  pass <tt>{leading: false}</tt>, and if you'd like to disable the emit
  on the trailing-edge, pass <tt>{trailing: false}</tt>.

pre(title='example')
  :escapehtml
    var stream = Kefir.sequentially(100, [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]);
    var throttled = stream.throttle(250);
    throttled.log();

pre(title='console output')
  :escapehtml
    > [sequentially.throttle] <value> 1
    > [sequentially.throttle] <value> 3
    > [sequentially.throttle] <value> 5
    > [sequentially.throttle] <value> 8
    > [sequentially.throttle] <value> 0
    > [sequentially.throttle] <end>
div





+descr-method('debounce', 'debounce', 'obs.debounce(wait, [options])').
  Creates new debounced version of <b>obs</b> observable.
  Will emit a value only after <b>wait</b> milliseconds period of no events.
  Pass <tt>{immediate: true}</tt> as an <b>options</b> object to cause
  observable to emit value on leading instead of the
  trailing edge of the <b>wait</b> interval.
  If used on a property current value will always pass intact without any delay.

pre(title='example')
  :escapehtml
    var stream = Kefir.sequentially(100, [1, 2, 3, -1, -2, -3, 4, 5, 6]);
    stream = stream.filter(function(x) {return x > 0});
    var debounced = stream.debounce(250);
    debounced.log();

pre(title='console output')
  :escapehtml
    > [sequentially.filter.debounce] <value> 3
    > [sequentially.filter.debounce] <value> 6
    > [sequentially.filter.debounce] <end>
div





+descr-method('flatten', 'flatten', 'obs.flatten([handler])').
  General transformation method. It allows you to do three kind
  of transformation on each value: change value (like map), skip value (like filter),
  and respond with several values to single value.

p.
  The <b>handler</b> function is called with each value emitted by source <b>obs</b> observable,
  and supposed to return an array of values. All values from that array will be emitted.
  If you want to skip a value, return an empty array. If you want to change value,
  return array with single new value. And if you want to respond with several values,
  return them in array.

p.
  If no <b>handler</b> function provided it assumed that <b>obs</b> observable
  emits arrays directly.

pre(title='example')
  :escapehtml
    var source = Kefir.sequentially(100, [1, 2, 3, 4]);
    var result = source.flatten(function(x) {
      if (x % 2 === 0) {
        return [x * 10];
      } else {
        return [];
      }
    });
    result.log();

pre(title='console output')
  :escapehtml
    > [sequentially.flatten] <value> 20
    > [sequentially.flatten] <value> 40
    > [sequentially.flatten] <end>
div






+descr-method('transduce', 'transduce', 'obs.transduce(transducer)').
  This method allows you to use transducers in Kefir.
  It supports any transducers implementation that follows
  <a href="https://github.com/cognitect-labs/transducers-js#the-transducer-protocol">the transducer protocol</a>, for example
  <a href="https://github.com/cognitect-labs/transducers-js">cognitect-labs/transducers-js</a> or
  <a href="https://github.com/jlongster/transducers.js">jlongster/transducers.js</a>.
  To learn more about transducers please visit those libraries pages.

p.
  Here is an example with <a href="https://github.com/cognitect-labs/transducers-js">cognitect-labs/transducers-js</a>:

pre(title='example')
  :escapehtml
    var t = transducers;
    var source = Kefir.sequentially(100, [1, 2, 3, 4, 5, 6]);
    var result = source.transduce(t.comp(
      t.map(function(x) {return x + 10}),
      t.filter(function(x) {return x % 2 === 0}),
      t.take(2)
    ));
    result.log();

pre(title='console output')
  :escapehtml
    > [sequentially.transduce] <value> 12
    > [sequentially.transduce] <value> 14
    > [sequentially.transduce] <end>
div





+descr-method('with-handler', 'withHandler', 'obs.withHandler(handler)').
  The most general transformation method. All other transformation methods above
  can be implemented via <b>withHandler</b>.
  Will call <b>handler</b> function on each event from <b>obs</b> observable
  passing to it two arguments: an <a href="#emitter-object">emitter object</a>,
  and an event object (with same format as in <a href="#on-any">.onAny</a> callback).

p.
  By default will not emit any values, and will not end when <b>obs</b>
  observable ends. Instead you should implement desired behaviour in
  <b>handler</b> function, i.e. analyse <b>event object</b> and call
  <tt>emitter.emit()</tt> or <tt>emitter.end()</tt> if necessary. You can call
  <b>emitter</b> methods several times in each <b>handler</b> execution,
  and you can also call them at any time later, for example to implement
  <a href="#delay">.delay()</a>.

pre(title='example')
  :escapehtml
    var source = Kefir.sequentially(100, [0, 1, 2, 3]);
    var result = source.withHandler(function(emitter, event) {
      if (event.type === 'end') {
        emitter.emit('bye');
        emitter.end();
      }
      if (event.type === 'value') {
        for (var i = 0; i < event.value; i++) {
          emitter.emit(event.value);
        }
      }
    });
    result.log();

pre(title='console output')
  :escapehtml
    > [sequentially.withHandler] <value> 1
    > [sequentially.withHandler] <value> 2
    > [sequentially.withHandler] <value> 2
    > [sequentially.withHandler] <value> 3
    > [sequentially.withHandler] <value> 3
    > [sequentially.withHandler] <value> 3
    > [sequentially.withHandler] <value> bye
    > [sequentially.withHandler] <end>
div
